<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Future Re" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Value - NewScanmem Documentation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Value";
        var mkdocs_page_input_path = "en/value.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../" class="icon icon-home"> NewScanmem Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../API_REFERENCE/">API Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../endianness/">Endianness</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../main/">Main</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../maps/">Maps</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../process_checker/">Process Checker</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../sets/">Sets</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../show_message/">Show Message</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../target_mem/">Target Memory</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Value</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#module-structure">Module Structure</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dependencies">Dependencies</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#core-features">Core Features</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-match-flags-enumeration">1. Match Flags Enumeration</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-value-structure-byte-centric">2. Value Structure (byte-centric)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-mem64-structure-current-bytes-buffer">3. Mem64 Structure (current bytes buffer)</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#methods">Methods</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4-wildcard-enumeration">4. Wildcard Enumeration</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5-uservalue-structure">5. UserValue Structure</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#usage-examples">Usage Examples</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#basic-value-creation-strict-numeric-free-form-bytes">Basic Value Creation (strict numeric + free-form bytes)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-mem64">Working with Mem64</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#user-value-input">User Value Input</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#flag-operations">Flag Operations</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#byte-array-handling">Byte Array Handling</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#memory-layout-and-packing">Memory Layout and Packing</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#structure-packing">Structure Packing</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#alignment">Alignment</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#type-safety-and-error-handling">Type Safety and Error Handling</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#runtime-type-checking">Runtime Type Checking</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compile-time-type-checking">Compile-time Type Checking</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#integration-examples">Integration Examples</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#with-target-memory-module">With Target Memory Module</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#with-endianness-module">With Endianness Module</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#testing">Testing</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#performance-considerations">Performance Considerations</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#memory-usage">Memory Usage</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#runtime-performance">Runtime Performance</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#best-practices">Best Practices</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#see-also">See Also</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#future-enhancements">Future Enhancements</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#platform-compatibility">Platform Compatibility</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#migration-guide">Migration Guide</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#from-c-style-unions">From C-style unions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#from-raw-pointers">From raw pointers</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../NamingConvention/">Naming Convention</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../">NewScanmem Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../" class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Value</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/future-re/NewScanmem/edit/master/docs/en/value.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="value-module-documentation">Value Module Documentation</h1>
<h2 id="overview">Overview</h2>
<p>The <code>value</code> module provides comprehensive value type definitions and match flags for the NewScanmem project. It defines various data type representations, memory layouts, and utility structures for handling different numeric types, byte arrays, and wildcard patterns used in memory scanning operations.</p>
<h2 id="module-structure">Module Structure</h2>
<pre><code class="language-cpp">export module value;
</code></pre>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li><code>&lt;cstdint&gt;</code> - Fixed-width integer types</li>
<li><code>&lt;cstring&gt;</code> - Byte copy</li>
<li><code>&lt;optional&gt;</code> - Optional type support</li>
<li><code>&lt;span&gt;</code> - Byte views</li>
<li><code>&lt;string&gt;</code> - String operations</li>
<li><code>&lt;type_traits&gt;</code> - Type utilities</li>
<li><code>&lt;vector&gt;</code> - Dynamic array container</li>
</ul>
<h2 id="core-features">Core Features</h2>
<h3 id="1-match-flags-enumeration">1. Match Flags Enumeration</h3>
<pre><code class="language-cpp">enum class [[gnu::packed]] MatchFlags : uint16_t {
    EMPTY = 0,

    // Basic numeric types
    U8B = 1 &lt;&lt; 0,   // Unsigned 8-bit
    S8B = 1 &lt;&lt; 1,   // Signed 8-bit
    U16B = 1 &lt;&lt; 2,  // Unsigned 16-bit
    S16B = 1 &lt;&lt; 3,  // Signed 16-bit
    U32B = 1 &lt;&lt; 4,  // Unsigned 32-bit
    S32B = 1 &lt;&lt; 5,  // Signed 32-bit
    U64B = 1 &lt;&lt; 6,  // Unsigned 64-bit
    S64B = 1 &lt;&lt; 7,  // Signed 64-bit

    // Floating point types
    F32B = 1 &lt;&lt; 8,  // 32-bit float
    F64B = 1 &lt;&lt; 9,  // 64-bit float

    // Composite types
    I8B = U8B | S8B,      // Any 8-bit integer
    I16B = U16B | S16B,   // Any 16-bit integer
    I32B = U32B | S32B,   // Any 32-bit integer
    I64B = U64B | S64B,   // Any 64-bit integer

    INTEGER = I8B | I16B | I32B | I64B,  // All integer types
    FLOAT = F32B | F64B,                  // All floating point types
    ALL = INTEGER | FLOAT,                // All supported types

    // Byte-based groupings
    B8 = I8B,           // 8-bit block
    B16 = I16B,         // 16-bit block
    B32 = I32B | F32B,  // 32-bit block
    B64 = I64B | F64B,  // 64-bit block

    MAX = 0xffffU  // Maximum flag value
};
</code></pre>
<h3 id="2-value-structure-byte-centric">2. Value Structure (byte-centric)</h3>
<p>Value stores historical (old) values as raw bytes. Type/width semantics are carried by <code>flags</code>.</p>
<pre><code class="language-cpp">struct [[gnu::packed]] Value {
    std::vector&lt;uint8_t&gt; bytes;     // Snapshot bytes
    MatchFlags flags = MatchFlags::EMPTY; // Type/width flag (required for numeric)

    constexpr static void zero(Value&amp; val);

    // Views and setters
    std::span&lt;const uint8_t&gt; view() const noexcept;
    void setBytes(const uint8_t* data, std::size_t len);
    void setBytes(const std::vector&lt;uint8_t&gt;&amp; val);
    void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f);
    void setBytesWithFlag(const std::vector&lt;uint8_t&gt;&amp; val, MatchFlags f);

    template &lt;typename T&gt; void setScalar(const T&amp; v);
    template &lt;typename T&gt; void setScalarWithFlag(const T&amp; v, MatchFlags f);
    template &lt;typename T&gt; void setScalarTyped(const T&amp; v); // auto-set correct flag
};
</code></pre>
<p>Notes:
- Numeric comparisons are strict: old value is decoded only if <code>flags</code> matches the requested type and the byte width is sufficient.
- Byte array/string comparisons do not rely on <code>flags</code>.</p>
<h3 id="3-mem64-structure-current-bytes-buffer">3. Mem64 Structure (current bytes buffer)</h3>
<p>Mem64 represents the current bytes read at a memory location.</p>
<pre><code class="language-cpp">struct [[gnu::packed]] Mem64 {
    std::vector&lt;uint8_t&gt; buffer;

    template &lt;typename T&gt; T get() const;              // memcpy decode
    std::span&lt;const uint8_t&gt; bytes() const noexcept;  // read-only view
    void setBytes(const uint8_t* data, std::size_t len);
    void setBytes(const std::vector&lt;uint8_t&gt;&amp; data);
    void setString(const std::string&amp; s);
    template &lt;typename T&gt; void setScalar(const T&amp; v);
};
</code></pre>
<h4 id="methods">Methods</h4>
<ul>
<li><code>get&lt;T&gt;()</code>: Decode the first <code>sizeof(T)</code> bytes using <code>memcpy</code> (throws if insufficient bytes).</li>
<li><code>bytes()</code>: Read-only span view over underlying bytes.</li>
<li><code>setBytes(...)</code>, <code>setString(...)</code>, <code>setScalar&lt;T&gt;(...)</code>: Write helpers.</li>
</ul>
<h3 id="4-wildcard-enumeration">4. Wildcard Enumeration</h3>
<pre><code class="language-cpp">enum class Wildcard : uint8_t {
    FIXED = 0xffU,    // Fixed value (no wildcard)
    WILDCARD = 0x00U  // Wildcard value (matches anything)
};
</code></pre>
<h3 id="5-uservalue-structure">5. UserValue Structure</h3>
<p>Comprehensive user input value representation with optional fields.</p>
<pre><code class="language-cpp">struct [[gnu::packed]] UserValue {
    // Basic numeric values
    int8_t int8_value = 0;
    uint8_t uint8_value = 0;
    int16_t int16_value = 0;
    uint16_t uint16_value = 0;
    int32_t int32_value = 0;
    uint32_t uint32_value = 0;
    int64_t int64_value = 0;
    uint64_t uint64_value = 0;
    float float32_value = 0.0F;
    double float64_value = 0.0;

    // Optional complex types
    std::optional&lt;std::vector&lt;uint8_t&gt;&gt; bytearray_value;
    std::optional&lt;std::vector&lt;uint8_t&gt;&gt; byteMask; // 0xFF=fixed, 0x00=wildcard
    std::optional&lt;Wildcard&gt; wildcard_value;

    // String and flags
    std::string string_value;
    MatchFlags flags = MatchFlags::EMPTY;
};
</code></pre>
<h2 id="usage-examples">Usage Examples</h2>
<h3 id="basic-value-creation-strict-numeric-free-form-bytes">Basic Value Creation (strict numeric + free-form bytes)</h3>
<pre><code class="language-cpp">import value;

// Create values with different types
Value uint8_val; uint8_val.setScalarTyped&lt;uint8_t&gt;(255);
Value int32_val; int32_val.setScalarTyped&lt;int32_t&gt;(-42);
Value float_val; float_val.setScalarTyped&lt;float&gt;(3.14f);
</code></pre>
<h3 id="working-with-mem64">Working with Mem64</h3>
<pre><code class="language-cpp">Mem64 mem64;
mem64.setScalar&lt;int64_t&gt;(INT64_MAX);
auto int64_value = mem64.get&lt;int64_t&gt;();

mem64.setScalar&lt;double&gt;(M_PI);
auto double_value = mem64.get&lt;double&gt;();
</code></pre>
<h3 id="user-value-input">User Value Input</h3>
<pre><code class="language-cpp">UserValue user_val;

// Set numeric values if needed
user_val.int32_value = 42;
user_val.float64_value = 1.23;

// Set string value
user_val.string_value = &quot;test_string&quot;;

// Set byte array
user_val.bytearray_value = std::vector&lt;uint8_t&gt;{0x01, 0x02, 0x03, 0x04};

// Optional wildcard intent (used with masked matching at higher level)
user_val.wildcard_value = Wildcard::WILDCARD;
</code></pre>
<h3 id="flag-operations">Flag Operations</h3>
<pre><code class="language-cpp">// Check if flags include specific type
bool is_integer = (flags &amp; MatchFlags::INTEGER) != MatchFlags::EMPTY;
bool is_float = (flags &amp; MatchFlags::FLOAT) != MatchFlags::EMPTY;

// Check specific bit width
bool is_32bit = (flags &amp; MatchFlags::B32) != MatchFlags::EMPTY;

// Combine flags
MatchFlags combined = MatchFlags::U8B | MatchFlags::U16B | MatchFlags::U32B;
</code></pre>
<h3 id="byte-array-handling">Byte Array Handling</h3>
<pre><code class="language-cpp">// Create value with byte array
Value byte_val;
std::vector&lt;uint8_t&gt; bytes{0x01, 0x02, 0x03, 0x04};
byte_val.setBytes(bytes);

// Iterate bytes via view
for (auto b : byte_val.view()) {
    std::cout &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(b) &lt;&lt; &quot; &quot;;
}
</code></pre>
<h2 id="memory-layout-and-packing">Memory Layout and Packing</h2>
<h3 id="structure-packing">Structure Packing</h3>
<p>All structures use <code>[[gnu::packed]]</code> attribute to minimize memory usage:</p>
<ul>
<li><strong>Value</strong>: bytes vector + flag</li>
<li><strong>Mem64</strong>: bytes vector buffer</li>
<li><strong>UserValue</strong>: ~200+ bytes (including string and vectors)</li>
</ul>
<h3 id="alignment">Alignment</h3>
<p>Structures are packed to minimize memory usage, which may impact performance on some architectures.</p>
<h2 id="type-safety-and-error-handling">Type Safety and Error Handling</h2>
<h3 id="runtime-type-checking">Runtime Type Checking</h3>
<pre><code class="language-cpp">Mem64 mem64;
mem64.setScalar&lt;int32_t&gt;(42);
// Decoding to a mismatched type or with insufficient bytes throws
double val = mem64.get&lt;double&gt;();
</code></pre>
<h3 id="compile-time-type-checking">Compile-time Type Checking</h3>
<pre><code class="language-cpp">// Static assertions ensure type safety
static_assert(std::is_trivially_copyable_v&lt;int64_t&gt;);
static_assert(sizeof(std::array&lt;uint8_t, 8&gt;) == 8);
</code></pre>
<h2 id="integration-examples">Integration Examples</h2>
<h3 id="with-target-memory-module">With Target Memory Module</h3>
<pre><code class="language-cpp">import value;
import targetmem;

void create_match_entry(void* addr, uint8_t byte, const Value&amp; value) {
    OldValueAndMatchInfo info;
    info.old_value = byte;
    // Determine flags from context (example: 8-bit unsigned)
    info.match_info = MatchFlags::U8B;
}
</code></pre>
<h3 id="with-endianness-module">With Endianness Module</h3>
<pre><code class="language-cpp">import value;
import endianness;

void handle_endianness(Value&amp; val, bool reverse_endianness) {
    if (reverse_endianness) {
        endianness::fix_endianness(val, true);
    }
}
</code></pre>
<h2 id="testing">Testing</h2>
<pre><code class="language-cpp">void test_value_module() {
    // Test Value creation
    Value val; val.setScalarTyped&lt;uint32_t&gt;(42);

    // Test Mem64
    Mem64 mem64;
    mem64.setScalar&lt;float&gt;(3.14f);
    assert(mem64.get&lt;float&gt;() == 3.14f);

    // Test flags
    MatchFlags flags = MatchFlags::U8B | MatchFlags::U16B;
    assert((flags &amp; MatchFlags::U8B) != MatchFlags::EMPTY);

    // Test UserValue
    UserValue user_val;
    user_val.int32_value = 123;
    assert(user_val.int32_value == 123);

    std::cout &lt;&lt; &quot;All tests passed!\n&quot;;
}
</code></pre>
<h2 id="performance-considerations">Performance Considerations</h2>
<h3 id="memory-usage">Memory Usage</h3>
<ul>
<li><strong>Value</strong>: Byte vector storage + strict flags</li>
<li><strong>Mem64</strong>: Byte buffer with memcpy decode</li>
<li><strong>UserValue</strong>: Larger due to optional containers and string</li>
</ul>
<h3 id="runtime-performance">Runtime Performance</h3>
<ul>
<li><strong>Variant access</strong>: O(1) via std::visit or std::get</li>
<li><strong>Type checking</strong>: Compile-time with std::get_if</li>
<li><strong>Memory alignment</strong>: Packed structures may have alignment overhead</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<ol>
<li><strong>Use appropriate types</strong>: Choose specific numeric types over generic ones</li>
<li><strong>Initialize flags</strong>: Always set appropriate MatchFlags</li>
<li><strong>Handle type mismatches</strong>: Guard reads and check sizes for <code>get&lt;T&gt;()</code></li>
<li><strong>Consider alignment</strong>: Packed structures may impact performance</li>
</ol>
<h2 id="see-also">See Also</h2>
<ul>
<li><a href="../target_mem/">Target Memory Module</a> - Uses Value and MatchFlags</li>
<li><a href="../endianness/">Endianness Module</a> - Handles byte order for values</li>
<li><a href="../show_message/">Show Message Module</a> - For value reporting and debugging</li>
</ul>
<h2 id="future-enhancements">Future Enhancements</h2>
<ul>
<li>Support for 128-bit types</li>
<li>SIMD type support</li>
<li>Custom allocator support</li>
<li>Serialization/deserialization</li>
<li>JSON conversion utilities</li>
<li>Memory-mapped file support</li>
<li>Zero-copy operations</li>
<li>Type reflection capabilities</li>
<li>Performance profiling utilities</li>
<li>Cross-platform endianness detection helpers</li>
</ul>
<h2 id="platform-compatibility">Platform Compatibility</h2>
<ul>
<li><strong>Linux</strong>: Full support</li>
<li><strong>macOS</strong>: Full support</li>
<li><strong>Windows</strong>: Full support</li>
<li><strong>32-bit systems</strong>: Limited 64-bit type support</li>
<li><strong>Big-endian</strong>: Full support with appropriate endianness handling</li>
</ul>
<h2 id="migration-guide">Migration Guide</h2>
<h3 id="from-c-style-unions">From C-style unions</h3>
<pre><code class="language-cpp">// Old C-style union
union ValueUnion {
    uint8_t u8;
    uint16_t u16;
    uint32_t u32;
    float f32;
};

// New C++23 variant
Value val = uint32_t{42};  // Type-safe and extensible
</code></pre>
<h3 id="from-raw-pointers">From raw pointers</h3>
<p>```cpp
// Old raw pointer approach
void<em> ptr = malloc(sizeof(int32_t));
</em>(int32_t*)ptr = 42;</p>
<p>// New type-safe approach
Mem64 mem64;
mem64.set<int32_t>(42);  // Safe and automatic cleanup</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../target_mem/" class="btn btn-neutral float-left" title="Target Memory"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../NamingConvention/" class="btn btn-neutral float-right" title="Naming Convention">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/future-re/NewScanmem" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../target_mem/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../NamingConvention/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
