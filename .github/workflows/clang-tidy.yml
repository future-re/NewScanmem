name: clang-tidy check

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

jobs:
  clang-tidy:
    runs-on: ubuntu-22.04
    container:
      image: ghcr.io/future-re/ubuntu22.04-clang20-boost1.89-gtest1.17:0.2

    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Show tool versions
        run: |
          clang-tidy --version || true
          clang++ --version || true
          cmake --version || true
          python3 --version || true

      - name: Configure (generate compile_commands.json)
        shell: bash -l {0}
        run: |
          set -euo pipefail
          cmake -B build -G Ninja \
            -DENABLE_CLANG_TIDY=OFF \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
            -DCMAKE_C_COMPILER=clang-20 \
            -DCMAKE_CXX_COMPILER=clang++-20 \
            -DCMAKE_CXX_STANDARD=23

      - name: Determine source files to check (changed files if PR)
        id: files
        shell: bash -l {0}
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # ensure base ref is available for diff
            git fetch origin ${{ github.base_ref }} --no-tags --depth=1 || true
            FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '\.(c|cc|cpp|cxx|cppm)$' || true)
          else
            FILES=$(git ls-files '*.c' '*.cc' '*.cpp' '*.cxx' '*.cppm' || true)
          fi
          # write multi-line output to GITHUB_OUTPUT
          echo "list<<EOF" >> $GITHUB_OUTPUT
          echo "$FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run clang-tidy and fail on any diagnostic
        shell: bash -l {0}
        run: |
          set -euo pipefail
          FILES="${{ steps.files.outputs.list }}"
          if [ -z "$FILES" ]; then
            echo "No C/C++ files to check."
            exit 0
          fi

          if [ ! -f build/compile_commands.json ]; then
            echo "ERROR: build/compile_commands.json not found"
            ls -la build || true
            exit 1
          fi

          # prefer run-clang-tidy.py if available (it parallelizes and filters)
          if command -v run-clang-tidy.py >/dev/null 2>&1; then
            echo "$FILES" | tr ' ' '\n' > /tmp/clang_tidy_files.txt
            python3 $(command -v run-clang-tidy.py) -p build -j $(nproc) --warnings-as-errors='*' $(cat /tmp/clang_tidy_files.txt) || exit $?
          else
            # fallback: per-file clang-tidy (stop on first failure)
            echo "$FILES" | tr ' ' '\n' > /tmp/clang_tidy_files.txt
            while read -r f; do
              [ -z "$f" ] && continue
              # skip files not present in compile_commands.json
              if ! grep -F -- "$f" build/compile_commands.json >/dev/null 2>&1; then
                echo "Skipping (no compile_commands entry): $f"
                continue
              fi
              echo "Running clang-tidy on: $f"
              if ! clang-tidy -p build --warnings-as-errors='*' "$f"; then
                echo "clang-tidy failed for: $f"
                exit 2
              fi
            done < /tmp/clang_tidy_files.txt
          fi

          echo "clang-tidy passed"