<!DOCTYPE html>
<html class="writer-html5" lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Future Re" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>API 参考 - NewScanmem Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "API \u53c2\u8003";
        var mkdocs_page_input_path = "API_REFERENCE.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> NewScanmem Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" title="在此输入需要搜索的内容" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航栏">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">首页</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">API 参考</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">模块索引</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#maps">maps</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#region_type">枚举：region_type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#region_scan_level">枚举：region_scan_level</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#region_flags">结构：region_flags</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#region">结构：region</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#maps_readererror">结构：maps_reader::error</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#maps_reader">类：maps_reader</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_2">静态方法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_3">便利函数</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_4">使用示例</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#endianness">endianness</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#endianness_1">命名空间: endianness</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_5">函数</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_6">概念</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#process_checker">process_checker</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#processstate">枚举: ProcessState</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#processchecker">类: ProcessChecker</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#processchecker_1">ProcessChecker 静态方法</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sets">sets</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#set">结构体: Set</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#set_1">Set 函数</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#show_message">show_message</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#messagetype">枚举: MessageType</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#messagecontext">结构体: MessageContext</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#messageprinter">类: MessagePrinter</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_7">构造函数</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_8">方法</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#targetmem">targetmem</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#oldvalueandmatchinfo">结构体: OldValueAndMatchInfo</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#matchesandoldvaluesswath">类: MatchesAndOldValuesSwath</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_9">成员变量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#matchesandoldvaluesswath_1">MatchesAndOldValuesSwath 方法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#matchesandoldvaluesarray">类: MatchesAndOldValuesArray</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#matchesandoldvaluesarray_1">MatchesAndOldValuesArray 成员变量</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#matchesandoldvaluesarray_2">MatchesAndOldValuesArray 方法</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#value">value</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#matchflags">枚举: MatchFlags</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#value_1">结构体: Value</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#mem64">结构体: Mem64</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_10">详细函数说明</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#endianness_2">endianness 模块</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#is_big_endian">is_big_endian()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#is_little_endian">is_little_endian()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#swap_bytest-value">swap_bytes(T value)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#swap_bytes_inplacevoid-data-size_t-size">swap_bytes_inplace(void* data, size_t size)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#fix_endiannessvalue-value-bool-reverse_endianness">fix_endianness(Value&amp; value, bool reverse_endianness)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#process_checker_1">process_checker 模块</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#processcheckercheck_processpid_t-pid">ProcessChecker::check_process(pid_t pid)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#processcheckeris_process_deadpid_t-pid">ProcessChecker::is_process_dead(pid_t pid)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sets_1">sets 模块</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#setsize">Set::size()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#setclear">Set::clear()</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#setcmpconst-size_t-i1-const-size_t-i2">Set::cmp(const size_t&amp; i1, const size_t&amp; i2)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#parse_uintsetstdstring_view-lptr-set-set-size_t-maxsz">parse_uintset(std::string_view lptr, Set&amp; set, size_t maxSZ)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#show_message_1">show_message 模块</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#messageprinterprintmessagetype-type-stdstring_view-fmt-args-args">MessagePrinter::print(MessageType type, std::string_view fmt, Args&amp;&amp;... args)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#messageprinterinfowarnerrordebuguserfmt-args">MessagePrinter::info/warn/error/debug/user(fmt, args...)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#targetmem_1">targetmem 模块</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#matchesandoldvaluesswathaddelementvoid-addr-uint8_t-byte-matchflags-matchflags">MatchesAndOldValuesSwath::addElement(void* addr, uint8_t byte, MatchFlags matchFlags)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#matchesandoldvaluesswathtoprintablestringsize_t-idx-size_t-len">MatchesAndOldValuesSwath::toPrintableString(size_t idx, size_t len)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#matchesandoldvaluesarrayfindswathindexvoid-addr">MatchesAndOldValuesArray::findSwathIndex(void* addr)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#matchesandoldvaluesarraygetelementvoid-addr">MatchesAndOldValuesArray::getElement(void* addr)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#value_2">value 模块</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#valuezerovalue-val">Value::zero(Value&amp; val)</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#api_1">API 使用示例</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_11">基本用法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_12">高级用法</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../endianness/">大端小端</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../main/">主程序</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../maps/">内存映射</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../process_checker/">进程检查器</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../sets/">集合</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../show_message/">显示消息</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../target_mem/">目标内存</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../value/">值</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../NamingConvention/">命名规则</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="移动导航栏">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">NewScanmem Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="文档"></a></li>
      <li class="breadcrumb-item active">API 参考</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/future-re/NewScanmem/edit/master/docs/API_REFERENCE.md" class="icon icon-github"> 在GitHub上编辑</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="api">API 参考</h1>
<h2 id="_1">模块索引</h2>
<ul>
<li><a href="#endianness">endianness</a></li>
<li><a href="#maps">maps</a>  </li>
<li><a href="#process_checker">process_checker</a></li>
<li><a href="#sets">sets</a></li>
<li><a href="#show_message">show_message</a></li>
<li><a href="#targetmem">targetmem</a></li>
<li><a href="#value">value</a></li>
</ul>
<hr />
<h2 id="maps">maps</h2>
<h3 id="region_type">枚举：<code>region_type</code></h3>
<pre><code class="language-cpp">enum class region_type : uint8_t {
    misc,   // 杂项内存区域
    exe,    // 可执行文件二进制区域
    code,   // 代码段（共享库等）
    heap,   // 堆内存区域
    stack   // 栈内存区域
};

constexpr std::array&lt;std::string_view, 5&gt; region_type_names;
</code></pre>
<h3 id="region_scan_level">枚举：<code>region_scan_level</code></h3>
<pre><code class="language-cpp">enum class region_scan_level : uint8_t {
    all,                       // 所有可读区域
    all_rw,                    // 所有可读/可写区域
    heap_stack_executable,     // 堆、栈和可执行区域
    heap_stack_executable_bss  // 上述加上 BSS 段
};
</code></pre>
<h3 id="region_flags">结构：<code>region_flags</code></h3>
<pre><code class="language-cpp">struct region_flags {
    bool read : 1;    // 读权限
    bool write : 1;   // 写权限
    bool exec : 1;    // 执行权限
    bool shared : 1;  // 共享映射
    bool private_ : 1; // 私有映射
};
</code></pre>
<h3 id="region">结构：<code>region</code></h3>
<pre><code class="language-cpp">struct region {
    void* start;           // 起始地址
    std::size_t size;      // 区域大小（字节）
    region_type type;      // 区域分类
    region_flags flags;    // 权限标志
    void* load_addr;       // ELF 文件的加载地址
    std::string filename;  // 关联文件路径
    std::size_t id;        // 唯一标识符

    [[nodiscard]] bool is_readable() const noexcept;
    [[nodiscard]] bool is_writable() const noexcept;
    [[nodiscard]] bool is_executable() const noexcept;
    [[nodiscard]] bool is_shared() const noexcept;
    [[nodiscard]] bool is_private() const noexcept;
    [[nodiscard]] std::pair&lt;void*, std::size_t&gt; as_span() const noexcept;
    [[nodiscard]] bool contains(void* address) const noexcept;
};
</code></pre>
<h3 id="maps_readererror">结构：<code>maps_reader::error</code></h3>
<pre><code class="language-cpp">struct error {
    std::string message;   // 人类可读的错误描述
    std::error_code code;  // 系统错误代码
};
</code></pre>
<h3 id="maps_reader">类：<code>maps_reader</code></h3>
<h4 id="_2">静态方法</h4>
<pre><code class="language-cpp">[[nodiscard]] static std::expected&lt;std::vector&lt;region&gt;, error&gt; 
read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);
</code></pre>
<h3 id="_3">便利函数</h3>
<pre><code class="language-cpp">[[nodiscard]] std::expected&lt;std::vector&lt;region&gt;, maps_reader::error&gt; 
read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);
</code></pre>
<h4 id="_4">使用示例</h4>
<pre><code class="language-cpp">import maps;

// 基本用法
auto regions = maps::read_process_maps(1234);

// 过滤扫描
auto heap_regions = maps::read_process_maps(
    pid, 
    maps::region_scan_level::heap_stack_executable
);

// 错误处理
if (!regions) {
    std::cerr &lt;&lt; &quot;错误: &quot; &lt;&lt; regions.error().message &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<hr />
<h2 id="endianness">endianness</h2>
<h3 id="endianness_1">命名空间: <code>endianness</code></h3>
<h4 id="_5">函数</h4>
<pre><code class="language-cpp">// 字节序检测
constexpr bool is_big_endian() noexcept;
constexpr bool is_little_endian() noexcept;

// 字节交换
constexpr uint8_t swap_bytes(uint8_t value) noexcept;
constexpr uint16_t swap_bytes(uint16_t value) noexcept;
constexpr uint32_t swap_bytes(uint32_t value) noexcept;
constexpr uint64_t swap_bytes(uint64_t value) noexcept;

template&lt;typename T&gt;
constexpr T swap_bytes_integral(T value) noexcept;

void swap_bytes_inplace(void* data, size_t size);

// 字节序修正
void fix_endianness(Value&amp; value, bool reverse_endianness) noexcept;

// 网络字节序
template&lt;SwappableIntegral T&gt;
constexpr T host_to_network(T value) noexcept;

template&lt;SwappableIntegral T&gt;
constexpr T network_to_host(T value) noexcept;

// 小端序转换
template&lt;SwappableIntegral T&gt;
constexpr T host_to_little_endian(T value) noexcept;

template&lt;SwappableIntegral T&gt;
constexpr T little_endian_to_host(T value) noexcept;
</code></pre>
<h4 id="_6">概念</h4>
<pre><code class="language-cpp">template&lt;typename T&gt;
concept SwappableIntegral = std::integral&lt;T&gt; &amp;&amp; 
    (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8);
</code></pre>
<hr />
<h2 id="process_checker">process_checker</h2>
<h3 id="processstate">枚举: <code>ProcessState</code></h3>
<pre><code class="language-cpp">enum class ProcessState { RUNNING, ERROR, DEAD, ZOMBIE };
</code></pre>
<h3 id="processchecker">类: <code>ProcessChecker</code></h3>
<h4 id="processchecker_1">ProcessChecker 静态方法</h4>
<pre><code class="language-cpp">static ProcessState check_process(pid_t pid);
static bool is_process_dead(pid_t pid);
</code></pre>
<hr />
<h2 id="sets">sets</h2>
<h3 id="set">结构体: <code>Set</code></h3>
<pre><code class="language-cpp">struct Set {
    std::vector&lt;size_t&gt; buf;

    size_t size() const;
    void clear();
    static int cmp(const size_t&amp; i1, const size_t&amp; i2);
};
</code></pre>
<h4 id="set_1">Set 函数</h4>
<pre><code class="language-cpp">bool parse_uintset(std::string_view lptr, Set&amp; set, size_t maxSZ);
</code></pre>
<hr />
<h2 id="show_message">show_message</h2>
<h3 id="messagetype">枚举: <code>MessageType</code></h3>
<pre><code class="language-cpp">enum class MessageType : uint8_t {
    INFO,    // 信息消息
    WARN,    // 警告消息
    ERROR,   // 错误消息
    DEBUG,   // 调试消息
    USER     // 用户消息
};
</code></pre>
<h3 id="messagecontext">结构体: <code>MessageContext</code></h3>
<pre><code class="language-cpp">struct MessageContext {
    bool debugMode = false;    // 调试模式
    bool backendMode = false;  // 后端模式
};
</code></pre>
<h3 id="messageprinter">类: <code>MessagePrinter</code></h3>
<h4 id="_7">构造函数</h4>
<pre><code class="language-cpp">MessagePrinter(MessageContext ctx = {});
</code></pre>
<h4 id="_8">方法</h4>
<pre><code class="language-cpp">template&lt;typename... Args&gt;
void print(MessageType type, std::string_view fmt, Args&amp;&amp;... args) const;

template&lt;typename... Args&gt;
void info(std::string_view fmt, Args&amp;&amp;... args) const;

template&lt;typename... Args&gt;
void warn(std::string_view fmt, Args&amp;&amp;... args) const;

template&lt;typename... Args&gt;
void error(std::string_view fmt, Args&amp;&amp;... args) const;

template&lt;typename... Args&gt;
void debug(std::string_view fmt, Args&amp;&amp;... args) const;

template&lt;typename... Args&gt;
void user(std::string_view fmt, Args&amp;&amp;... args) const;
</code></pre>
<hr />
<h2 id="targetmem">targetmem</h2>
<h3 id="oldvalueandmatchinfo">结构体: <code>OldValueAndMatchInfo</code></h3>
<pre><code class="language-cpp">struct OldValueAndMatchInfo {
    uint8_t old_value;      // 原始字节值
    MatchFlags match_info;  // 匹配类型和状态标志
};
</code></pre>
<h3 id="matchesandoldvaluesswath">类: <code>MatchesAndOldValuesSwath</code></h3>
<h4 id="_9">成员变量</h4>
<pre><code class="language-cpp">void* firstByteInChild = nullptr;                    // 起始地址
std::vector&lt;OldValueAndMatchInfo&gt; data;              // 匹配数据
</code></pre>
<h4 id="matchesandoldvaluesswath_1">MatchesAndOldValuesSwath 方法</h4>
<pre><code class="language-cpp">void addElement(void* addr, uint8_t byte, MatchFlags matchFlags);
std::string toPrintableString(size_t idx, size_t len) const;
std::string toByteArrayText(size_t idx, size_t len) const;
</code></pre>
<h3 id="matchesandoldvaluesarray">类: <code>MatchesAndOldValuesArray</code></h3>
<h4 id="matchesandoldvaluesarray_1">MatchesAndOldValuesArray 成员变量</h4>
<pre><code class="language-cpp">std::vector&lt;MatchesAndOldValuesSwath&gt; swaths;        // 内存区域集合
</code></pre>
<h4 id="matchesandoldvaluesarray_2">MatchesAndOldValuesArray 方法</h4>
<pre><code class="language-cpp">std::optional&lt;size_t&gt; findSwathIndex(void* addr) const;
std::optional&lt;size_t&gt; findElementIndex(void* addr) const;
const OldValueAndMatchInfo* getElement(void* addr) const;
OldValueAndMatchInfo* getElement(void* addr);
void clear();
size_t size() const;
</code></pre>
<hr />
<h2 id="value">value</h2>
<h3 id="matchflags">枚举: <code>MatchFlags</code></h3>
<pre><code class="language-cpp">enum class [[gnu::packed]] MatchFlags : uint16_t {
    EMPTY = 0,

    // 基本数值类型
    U8B = 1 &lt;&lt; 0,   // 无符号 8 位
    S8B = 1 &lt;&lt; 1,   // 有符号 8 位
    U16B = 1 &lt;&lt; 2,  // 无符号 16 位
    S16B = 1 &lt;&lt; 3,  // 有符号 16 位
    U32B = 1 &lt;&lt; 4,  // 无符号 32 位
    S32B = 1 &lt;&lt; 5,  // 有符号 32 位
    U64B = 1 &lt;&lt; 6,  // 无符号 64 位
    S64B = 1 &lt;&lt; 7,  // 有符号 64 位

    // 浮点类型
    F32B = 1 &lt;&lt; 8,  // 32 位浮点
    F64B = 1 &lt;&lt; 9,  // 64 位浮点

    // 复合类型
    I8B = U8B | S8B,      // 任意 8 位整数
    I16B = U16B | S16B,   // 任意 16 位整数
    I32B = U32B | S32B,   // 任意 32 位整数
    I64B = U64B | S64B,   // 任意 64 位整数

    INTEGER = I8B | I16B | I32B | I64B,  // 所有整数类型
    FLOAT = F32B | F64B,                  // 所有浮点类型
    ALL = INTEGER | FLOAT,                // 所有支持的类型

    // 基于字节的分组
    B8 = I8B,           // 8 位块
    B16 = I16B,         // 16 位块
    B32 = I32B | F32B,  // 32 位块
    B64 = I64B | F64B,  // 64 位块

    MAX = 0xffffU  // 最大标志值
};
</code></pre>
<h3 id="value_1">结构体: <code>Value</code></h3>
<pre><code class="language-cpp">struct [[gnu::packed]] Value {
    std::vector&lt;uint8_t&gt; bytes;      // 历史值字节
    MatchFlags flags = MatchFlags::EMPTY; // 类型/宽度标志

    // 复位
    constexpr static void zero(Value&amp; val);

    // 视图与设置
    std::span&lt;const uint8_t&gt; view() const noexcept;
    void setBytes(const uint8_t* data, std::size_t len);
    void setBytes(const std::vector&lt;uint8_t&gt;&amp; val);
    void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f);
    void setBytesWithFlag(const std::vector&lt;uint8_t&gt;&amp; val, MatchFlags f);
    template &lt;typename T&gt; void setScalar(const T&amp; v);
    template &lt;typename T&gt; void setScalarWithFlag(const T&amp; v, MatchFlags f);
    template &lt;typename T&gt; void setScalarTyped(const T&amp; v);
};
</code></pre>
<p>数值严格：旧值解码时需要 <code>flags</code> 与类型匹配且字节数足够；字节串/字符串不受此限制。</p>
<h3 id="mem64">结构体: <code>Mem64</code></h3>
<pre><code class="language-cpp">struct [[gnu::packed]] Mem64 {
    std::vector&lt;uint8_t&gt; buffer;     // 当前值字节

    template &lt;typename T&gt; T get() const;              // 以 memcpy 解码
    std::span&lt;const uint8_t&gt; bytes() const noexcept;  // 只读字节视图
    void setBytes(const uint8_t* data, std::size_t len);
    void setBytes(const std::vector&lt;uint8_t&gt;&amp; data);
    void setString(const std::string&amp; s);
    template &lt;typename T&gt; void setScalar(const T&amp; v);
};
</code></pre>
<hr />
<h2 id="_10">详细函数说明</h2>
<h3 id="endianness_2">endianness 模块</h3>
<h4 id="is_big_endian"><code>is_big_endian()</code></h4>
<p>检测系统是否为大端序。</p>
<p><strong>返回值:</strong> <code>true</code> 如果系统为大端序，否则 <code>false</code></p>
<h4 id="is_little_endian"><code>is_little_endian()</code></h4>
<p>检测系统是否为小端序。</p>
<p><strong>返回值:</strong> <code>true</code> 如果系统为小端序，否则 <code>false</code></p>
<h4 id="swap_bytest-value"><code>swap_bytes(T value)</code></h4>
<p>交换指定类型值的字节序。</p>
<p><strong>模板参数:</strong> <code>T</code> - 整数类型 (uint8_t, uint16_t, uint32_t, uint64_t)</p>
<p><strong>参数:</strong> <code>value</code> - 要交换字节序的值</p>
<p><strong>返回值:</strong> 交换字节序后的值</p>
<h4 id="swap_bytes_inplacevoid-data-size_t-size"><code>swap_bytes_inplace(void* data, size_t size)</code></h4>
<p>原地交换内存中数据的字节序。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>data</code> - 指向数据的指针</li>
<li><code>size</code> - 数据大小（字节）</li>
</ul>
<h4 id="fix_endiannessvalue-value-bool-reverse_endianness"><code>fix_endianness(Value&amp; value, bool reverse_endianness)</code></h4>
<p>修正 Value 对象的字节序。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>value</code> - 要修正的 Value 对象</li>
<li><code>reverse_endianness</code> - 是否反转字节序</li>
</ul>
<h3 id="process_checker_1">process_checker 模块</h3>
<h4 id="processcheckercheck_processpid_t-pid"><code>ProcessChecker::check_process(pid_t pid)</code></h4>
<p>检查指定进程的状态。</p>
<p><strong>参数:</strong> <code>pid</code> - 进程 ID</p>
<p><strong>返回值:</strong> <code>ProcessState</code> 枚举值表示进程状态</p>
<h4 id="processcheckeris_process_deadpid_t-pid"><code>ProcessChecker::is_process_dead(pid_t pid)</code></h4>
<p>检查进程是否已死亡。</p>
<p><strong>参数:</strong> <code>pid</code> - 进程 ID</p>
<p><strong>返回值:</strong> <code>true</code> 如果进程已死亡或不存在，否则 <code>false</code></p>
<h3 id="sets_1">sets 模块</h3>
<h4 id="setsize"><code>Set::size()</code></h4>
<p>获取集合中的元素数量。</p>
<p><strong>返回值:</strong> 元素数量</p>
<h4 id="setclear"><code>Set::clear()</code></h4>
<p>清空集合中的所有元素。</p>
<h4 id="setcmpconst-size_t-i1-const-size_t-i2"><code>Set::cmp(const size_t&amp; i1, const size_t&amp; i2)</code></h4>
<p>比较两个 size_t 值。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>i1</code> - 第一个值</li>
<li><code>i2</code> - 第二个值</li>
</ul>
<p><strong>返回值:</strong> 比较结果（-1, 0, 1）</p>
<h4 id="parse_uintsetstdstring_view-lptr-set-set-size_t-maxsz"><code>parse_uintset(std::string_view lptr, Set&amp; set, size_t maxSZ)</code></h4>
<p>解析无符号整数集合表达式。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>lptr</code> - 要解析的字符串</li>
<li><code>set</code> - 用于存储结果的 Set 对象</li>
<li><code>maxSZ</code> - 最大允许值</li>
</ul>
<p><strong>返回值:</strong> <code>true</code> 如果解析成功，否则 <code>false</code></p>
<h3 id="show_message_1">show_message 模块</h3>
<h4 id="messageprinterprintmessagetype-type-stdstring_view-fmt-args-args"><code>MessagePrinter::print(MessageType type, std::string_view fmt, Args&amp;&amp;... args)</code></h4>
<p>打印格式化的消息。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>type</code> - 消息类型</li>
<li><code>fmt</code> - 格式字符串</li>
<li><code>args</code> - 格式化参数</li>
</ul>
<h4 id="messageprinterinfowarnerrordebuguserfmt-args"><code>MessagePrinter::info/warn/error/debug/user(fmt, args...)</code></h4>
<p>便捷方法，用于打印特定类型的消息。</p>
<h3 id="targetmem_1">targetmem 模块</h3>
<h4 id="matchesandoldvaluesswathaddelementvoid-addr-uint8_t-byte-matchflags-matchflags"><code>MatchesAndOldValuesSwath::addElement(void* addr, uint8_t byte, MatchFlags matchFlags)</code></h4>
<p>向 swath 添加新的内存匹配。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>addr</code> - 内存地址</li>
<li><code>byte</code> - 字节值</li>
<li><code>matchFlags</code> - 匹配标志</li>
</ul>
<h4 id="matchesandoldvaluesswathtoprintablestringsize_t-idx-size_t-len"><code>MatchesAndOldValuesSwath::toPrintableString(size_t idx, size_t len)</code></h4>
<p>将内存字节转换为可打印字符串。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>idx</code> - 起始索引</li>
<li><code>len</code> - 长度</li>
</ul>
<p><strong>返回值:</strong> 可打印字符串</p>
<h4 id="matchesandoldvaluesarrayfindswathindexvoid-addr"><code>MatchesAndOldValuesArray::findSwathIndex(void* addr)</code></h4>
<p>查找包含指定地址的 swath 索引。</p>
<p><strong>参数:</strong> <code>addr</code> - 内存地址</p>
<p><strong>返回值:</strong> 包含该地址的 swath 索引，如果未找到则返回 std::nullopt</p>
<h4 id="matchesandoldvaluesarraygetelementvoid-addr"><code>MatchesAndOldValuesArray::getElement(void* addr)</code></h4>
<p>获取指定地址的元素数据。</p>
<p><strong>参数:</strong> <code>addr</code> - 内存地址</p>
<p><strong>返回值:</strong> 指向 OldValueAndMatchInfo 的指针，如果未找到则返回 nullptr</p>
<h3 id="value_2">value 模块</h3>
<h4 id="valuezerovalue-val"><code>Value::zero(Value&amp; val)</code></h4>
<p>将 Value 对象清零。</p>
<p><strong>参数:</strong> <code>val</code> - 要清零的 Value 对象</p>
<hr />
<h2 id="api_1">API 使用示例</h2>
<h3 id="_11">基本用法</h3>
<pre><code class="language-cpp">import endianness;
import process_checker;
import sets;
import show_message;
import targetmem;
import value;

// 检查字节序
if (endianness::is_little_endian()) {
    std::cout &lt;&lt; &quot;系统为小端序&quot; &lt;&lt; std::endl;
}

// 检查进程状态
pid_t pid = 1234;
ProcessState state = ProcessChecker::check_process(pid);
if (state == ProcessState::RUNNING) {
    std::cout &lt;&lt; &quot;进程正在运行&quot; &lt;&lt; std::endl;
}

// 解析集合
Set mySet;
parse_uintset(&quot;1,2,3,4,5&quot;, mySet, 100);

// 创建消息打印机
MessageContext ctx;
ctx.debugMode = true;
MessagePrinter printer(ctx);
printer.info(&quot;开始处理&quot;);

// 创建内存匹配数组
MatchesAndOldValuesArray matches;

// 创建值对象
Value searchValue;
searchValue.value = static_cast&lt;int32_t&gt;(42);
searchValue.flags = MatchFlags::S32B;
</code></pre>
<h3 id="_12">高级用法</h3>
<pre><code class="language-cpp">// 字节序转换
uint32_t value = 0x12345678;
uint32_t swapped = endianness::swap_bytes(value);

// 进程监控循环
while (true) {
    if (ProcessChecker::is_process_dead(targetPid)) {
        std::cout &lt;&lt; &quot;目标进程已终止&quot; &lt;&lt; std::endl;
        break;
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
}

// 复杂集合解析
Set complexSet;
parse_uintset(&quot;1,5,10..15,0x20&quot;, complexSet, 1000);

// 格式化消息
printer.info(&quot;找到 {} 个匹配项&quot;, matchCount);
printer.warn(&quot;内存使用率: {:.2f}%&quot;, memoryUsage);
printer.error(&quot;在地址 0x{:08x} 处读取失败&quot;, address);

// 内存匹配操作
void* targetAddr = (void*)0x1000;
auto swathIndex = matches.findSwathIndex(targetAddr);
if (swathIndex) {
    const auto* element = matches.getElement(targetAddr);
    if (element) {
        std::cout &lt;&lt; &quot;旧值: 0x&quot; &lt;&lt; std::hex &lt;&lt; (int)element-&gt;old_value &lt;&lt; std::endl;
    }
}
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="页脚导航">
        <a href=".." class="btn btn-neutral float-left" title="首页"><span class="icon icon-circle-arrow-left"></span> 上一章</a>
        <a href="../endianness/" class="btn btn-neutral float-right" title="大端小端">下一章 <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  用<a href="https://www.mkdocs.org/">MkDocs</a>构建，使用<a href="https://readthedocs.org">Read the Docs</a>提供的<a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>。
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="版本">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/future-re/NewScanmem" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href=".." style="color: #fcfcfc">&laquo; 上一章</a></span>
    
    
      <span><a href="../endianness/" style="color: #fcfcfc">下一章 &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
