{"config":{"indexing":"full","lang":["en","zh"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u5f00\u59cb \u6b22\u8fce\u8bbf\u95ee NewScanmem \u6587\u6863\u7ad9\u70b9\uff01\u8fd9\u91cc\u63d0\u4f9b\u9879\u76ee\u6982\u89c8\u3001\u4f7f\u7528\u6307\u5357\u4ee5\u53ca API \u53c2\u8003\u3002 \u5173\u4e8e NewScanmem NewScanmem \u662f\u4e00\u4e2a\u4f7f\u7528 C++20/23 \u6784\u5efa\u7684\u5185\u5b58\u626b\u63cf\u4e0e\u8c03\u8bd5\u5de5\u5177\uff0c\u4e13\u6ce8\u4e8e Linux \u5e73\u53f0\u7684\u8fdb\u7a0b\u5185\u5b58\u626b\u63cf\u4e0e\u5206\u6790\uff0c\u652f\u6301\u591a\u79cd\u6570\u636e\u7c7b\u578b\u4e0e\u5b57\u8282\u5e8f\u5904\u7406\u3002","title":"\u9996\u9875"},{"location":"#_1","text":"\u6b22\u8fce\u8bbf\u95ee NewScanmem \u6587\u6863\u7ad9\u70b9\uff01\u8fd9\u91cc\u63d0\u4f9b\u9879\u76ee\u6982\u89c8\u3001\u4f7f\u7528\u6307\u5357\u4ee5\u53ca API \u53c2\u8003\u3002","title":"\u5f00\u59cb"},{"location":"#newscanmem","text":"NewScanmem \u662f\u4e00\u4e2a\u4f7f\u7528 C++20/23 \u6784\u5efa\u7684\u5185\u5b58\u626b\u63cf\u4e0e\u8c03\u8bd5\u5de5\u5177\uff0c\u4e13\u6ce8\u4e8e Linux \u5e73\u53f0\u7684\u8fdb\u7a0b\u5185\u5b58\u626b\u63cf\u4e0e\u5206\u6790\uff0c\u652f\u6301\u591a\u79cd\u6570\u636e\u7c7b\u578b\u4e0e\u5b57\u8282\u5e8f\u5904\u7406\u3002","title":"\u5173\u4e8e NewScanmem"},{"location":"API_REFERENCE/","text":"API \u53c2\u8003 \u6a21\u5757\u7d22\u5f15 endianness maps process_checker sets show_message targetmem value maps \u679a\u4e3e\uff1a region_type enum class region_type : uint8_t { misc, // \u6742\u9879\u5185\u5b58\u533a\u57df exe, // \u53ef\u6267\u884c\u6587\u4ef6\u4e8c\u8fdb\u5236\u533a\u57df code, // \u4ee3\u7801\u6bb5\uff08\u5171\u4eab\u5e93\u7b49\uff09 heap, // \u5806\u5185\u5b58\u533a\u57df stack // \u6808\u5185\u5b58\u533a\u57df }; constexpr std::array<std::string_view, 5> region_type_names; \u679a\u4e3e\uff1a region_scan_level enum class region_scan_level : uint8_t { all, // \u6240\u6709\u53ef\u8bfb\u533a\u57df all_rw, // \u6240\u6709\u53ef\u8bfb/\u53ef\u5199\u533a\u57df heap_stack_executable, // \u5806\u3001\u6808\u548c\u53ef\u6267\u884c\u533a\u57df heap_stack_executable_bss // \u4e0a\u8ff0\u52a0\u4e0a BSS \u6bb5 }; \u7ed3\u6784\uff1a region_flags struct region_flags { bool read : 1; // \u8bfb\u6743\u9650 bool write : 1; // \u5199\u6743\u9650 bool exec : 1; // \u6267\u884c\u6743\u9650 bool shared : 1; // \u5171\u4eab\u6620\u5c04 bool private_ : 1; // \u79c1\u6709\u6620\u5c04 }; \u7ed3\u6784\uff1a region struct region { void* start; // \u8d77\u59cb\u5730\u5740 std::size_t size; // \u533a\u57df\u5927\u5c0f\uff08\u5b57\u8282\uff09 region_type type; // \u533a\u57df\u5206\u7c7b region_flags flags; // \u6743\u9650\u6807\u5fd7 void* load_addr; // ELF \u6587\u4ef6\u7684\u52a0\u8f7d\u5730\u5740 std::string filename; // \u5173\u8054\u6587\u4ef6\u8def\u5f84 std::size_t id; // \u552f\u4e00\u6807\u8bc6\u7b26 [[nodiscard]] bool is_readable() const noexcept; [[nodiscard]] bool is_writable() const noexcept; [[nodiscard]] bool is_executable() const noexcept; [[nodiscard]] bool is_shared() const noexcept; [[nodiscard]] bool is_private() const noexcept; [[nodiscard]] std::pair<void*, std::size_t> as_span() const noexcept; [[nodiscard]] bool contains(void* address) const noexcept; }; \u7ed3\u6784\uff1a maps_reader::error struct error { std::string message; // \u4eba\u7c7b\u53ef\u8bfb\u7684\u9519\u8bef\u63cf\u8ff0 std::error_code code; // \u7cfb\u7edf\u9519\u8bef\u4ee3\u7801 }; \u7c7b\uff1a maps_reader \u9759\u6001\u65b9\u6cd5 [[nodiscard]] static std::expected<std::vector<region>, error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all); \u4fbf\u5229\u51fd\u6570 [[nodiscard]] std::expected<std::vector<region>, maps_reader::error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all); \u4f7f\u7528\u793a\u4f8b import maps; // \u57fa\u672c\u7528\u6cd5 auto regions = maps::read_process_maps(1234); // \u8fc7\u6ee4\u626b\u63cf auto heap_regions = maps::read_process_maps( pid, maps::region_scan_level::heap_stack_executable ); // \u9519\u8bef\u5904\u7406 if (!regions) { std::cerr << \"\u9519\u8bef: \" << regions.error().message << \"\\n\"; } endianness \u547d\u540d\u7a7a\u95f4: endianness \u51fd\u6570 // \u5b57\u8282\u5e8f\u68c0\u6d4b constexpr bool is_big_endian() noexcept; constexpr bool is_little_endian() noexcept; // \u5b57\u8282\u4ea4\u6362 constexpr uint8_t swap_bytes(uint8_t value) noexcept; constexpr uint16_t swap_bytes(uint16_t value) noexcept; constexpr uint32_t swap_bytes(uint32_t value) noexcept; constexpr uint64_t swap_bytes(uint64_t value) noexcept; template<typename T> constexpr T swap_bytes_integral(T value) noexcept; void swap_bytes_inplace(void* data, size_t size); // \u5b57\u8282\u5e8f\u4fee\u6b63 void fix_endianness(Value& value, bool reverse_endianness) noexcept; // \u7f51\u7edc\u5b57\u8282\u5e8f template<SwappableIntegral T> constexpr T host_to_network(T value) noexcept; template<SwappableIntegral T> constexpr T network_to_host(T value) noexcept; // \u5c0f\u7aef\u5e8f\u8f6c\u6362 template<SwappableIntegral T> constexpr T host_to_little_endian(T value) noexcept; template<SwappableIntegral T> constexpr T little_endian_to_host(T value) noexcept; \u6982\u5ff5 template<typename T> concept SwappableIntegral = std::integral<T> && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8); process_checker \u679a\u4e3e: ProcessState enum class ProcessState { RUNNING, ERROR, DEAD, ZOMBIE }; \u7c7b: ProcessChecker ProcessChecker \u9759\u6001\u65b9\u6cd5 static ProcessState check_process(pid_t pid); static bool is_process_dead(pid_t pid); sets \u7ed3\u6784\u4f53: Set struct Set { std::vector<size_t> buf; size_t size() const; void clear(); static int cmp(const size_t& i1, const size_t& i2); }; Set \u51fd\u6570 bool parse_uintset(std::string_view lptr, Set& set, size_t maxSZ); show_message \u679a\u4e3e: MessageType enum class MessageType : uint8_t { INFO, // \u4fe1\u606f\u6d88\u606f WARN, // \u8b66\u544a\u6d88\u606f ERROR, // \u9519\u8bef\u6d88\u606f DEBUG, // \u8c03\u8bd5\u6d88\u606f USER // \u7528\u6237\u6d88\u606f }; \u7ed3\u6784\u4f53: MessageContext struct MessageContext { bool debugMode = false; // \u8c03\u8bd5\u6a21\u5f0f bool backendMode = false; // \u540e\u7aef\u6a21\u5f0f }; \u7c7b: MessagePrinter \u6784\u9020\u51fd\u6570 MessagePrinter(MessageContext ctx = {}); \u65b9\u6cd5 template<typename... Args> void print(MessageType type, std::string_view fmt, Args&&... args) const; template<typename... Args> void info(std::string_view fmt, Args&&... args) const; template<typename... Args> void warn(std::string_view fmt, Args&&... args) const; template<typename... Args> void error(std::string_view fmt, Args&&... args) const; template<typename... Args> void debug(std::string_view fmt, Args&&... args) const; template<typename... Args> void user(std::string_view fmt, Args&&... args) const; targetmem \u7ed3\u6784\u4f53: OldValueAndMatchInfo struct OldValueAndMatchInfo { uint8_t old_value; // \u539f\u59cb\u5b57\u8282\u503c MatchFlags match_info; // \u5339\u914d\u7c7b\u578b\u548c\u72b6\u6001\u6807\u5fd7 }; \u7c7b: MatchesAndOldValuesSwath \u6210\u5458\u53d8\u91cf void* firstByteInChild = nullptr; // \u8d77\u59cb\u5730\u5740 std::vector<OldValueAndMatchInfo> data; // \u5339\u914d\u6570\u636e MatchesAndOldValuesSwath \u65b9\u6cd5 void addElement(void* addr, uint8_t byte, MatchFlags matchFlags); std::string toPrintableString(size_t idx, size_t len) const; std::string toByteArrayText(size_t idx, size_t len) const; \u7c7b: MatchesAndOldValuesArray MatchesAndOldValuesArray \u6210\u5458\u53d8\u91cf std::vector<MatchesAndOldValuesSwath> swaths; // \u5185\u5b58\u533a\u57df\u96c6\u5408 MatchesAndOldValuesArray \u65b9\u6cd5 std::optional<size_t> findSwathIndex(void* addr) const; std::optional<size_t> findElementIndex(void* addr) const; const OldValueAndMatchInfo* getElement(void* addr) const; OldValueAndMatchInfo* getElement(void* addr); void clear(); size_t size() const; value \u679a\u4e3e: MatchFlags enum class [[gnu::packed]] MatchFlags : uint16_t { EMPTY = 0, // \u57fa\u672c\u6570\u503c\u7c7b\u578b U8B = 1 << 0, // \u65e0\u7b26\u53f7 8 \u4f4d S8B = 1 << 1, // \u6709\u7b26\u53f7 8 \u4f4d U16B = 1 << 2, // \u65e0\u7b26\u53f7 16 \u4f4d S16B = 1 << 3, // \u6709\u7b26\u53f7 16 \u4f4d U32B = 1 << 4, // \u65e0\u7b26\u53f7 32 \u4f4d S32B = 1 << 5, // \u6709\u7b26\u53f7 32 \u4f4d U64B = 1 << 6, // \u65e0\u7b26\u53f7 64 \u4f4d S64B = 1 << 7, // \u6709\u7b26\u53f7 64 \u4f4d // \u6d6e\u70b9\u7c7b\u578b F32B = 1 << 8, // 32 \u4f4d\u6d6e\u70b9 F64B = 1 << 9, // 64 \u4f4d\u6d6e\u70b9 // \u590d\u5408\u7c7b\u578b I8B = U8B | S8B, // \u4efb\u610f 8 \u4f4d\u6574\u6570 I16B = U16B | S16B, // \u4efb\u610f 16 \u4f4d\u6574\u6570 I32B = U32B | S32B, // \u4efb\u610f 32 \u4f4d\u6574\u6570 I64B = U64B | S64B, // \u4efb\u610f 64 \u4f4d\u6574\u6570 INTEGER = I8B | I16B | I32B | I64B, // \u6240\u6709\u6574\u6570\u7c7b\u578b FLOAT = F32B | F64B, // \u6240\u6709\u6d6e\u70b9\u7c7b\u578b ALL = INTEGER | FLOAT, // \u6240\u6709\u652f\u6301\u7684\u7c7b\u578b // \u57fa\u4e8e\u5b57\u8282\u7684\u5206\u7ec4 B8 = I8B, // 8 \u4f4d\u5757 B16 = I16B, // 16 \u4f4d\u5757 B32 = I32B | F32B, // 32 \u4f4d\u5757 B64 = I64B | F64B, // 64 \u4f4d\u5757 MAX = 0xffffU // \u6700\u5927\u6807\u5fd7\u503c }; \u7ed3\u6784\u4f53: Value struct [[gnu::packed]] Value { std::vector<uint8_t> bytes; // \u5386\u53f2\u503c\u5b57\u8282 MatchFlags flags = MatchFlags::EMPTY; // \u7c7b\u578b/\u5bbd\u5ea6\u6807\u5fd7 // \u590d\u4f4d constexpr static void zero(Value& val); // \u89c6\u56fe\u4e0e\u8bbe\u7f6e std::span<const uint8_t> view() const noexcept; void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& val); void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f); void setBytesWithFlag(const std::vector<uint8_t>& val, MatchFlags f); template <typename T> void setScalar(const T& v); template <typename T> void setScalarWithFlag(const T& v, MatchFlags f); template <typename T> void setScalarTyped(const T& v); }; \u6570\u503c\u4e25\u683c\uff1a\u65e7\u503c\u89e3\u7801\u65f6\u9700\u8981 flags \u4e0e\u7c7b\u578b\u5339\u914d\u4e14\u5b57\u8282\u6570\u8db3\u591f\uff1b\u5b57\u8282\u4e32/\u5b57\u7b26\u4e32\u4e0d\u53d7\u6b64\u9650\u5236\u3002 \u7ed3\u6784\u4f53: Mem64 struct [[gnu::packed]] Mem64 { std::vector<uint8_t> buffer; // \u5f53\u524d\u503c\u5b57\u8282 template <typename T> T get() const; // \u4ee5 memcpy \u89e3\u7801 std::span<const uint8_t> bytes() const noexcept; // \u53ea\u8bfb\u5b57\u8282\u89c6\u56fe void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& data); void setString(const std::string& s); template <typename T> void setScalar(const T& v); }; \u8be6\u7ec6\u51fd\u6570\u8bf4\u660e endianness \u6a21\u5757 is_big_endian() \u68c0\u6d4b\u7cfb\u7edf\u662f\u5426\u4e3a\u5927\u7aef\u5e8f\u3002 \u8fd4\u56de\u503c: true \u5982\u679c\u7cfb\u7edf\u4e3a\u5927\u7aef\u5e8f\uff0c\u5426\u5219 false is_little_endian() \u68c0\u6d4b\u7cfb\u7edf\u662f\u5426\u4e3a\u5c0f\u7aef\u5e8f\u3002 \u8fd4\u56de\u503c: true \u5982\u679c\u7cfb\u7edf\u4e3a\u5c0f\u7aef\u5e8f\uff0c\u5426\u5219 false swap_bytes(T value) \u4ea4\u6362\u6307\u5b9a\u7c7b\u578b\u503c\u7684\u5b57\u8282\u5e8f\u3002 \u6a21\u677f\u53c2\u6570: T - \u6574\u6570\u7c7b\u578b (uint8_t, uint16_t, uint32_t, uint64_t) \u53c2\u6570: value - \u8981\u4ea4\u6362\u5b57\u8282\u5e8f\u7684\u503c \u8fd4\u56de\u503c: \u4ea4\u6362\u5b57\u8282\u5e8f\u540e\u7684\u503c swap_bytes_inplace(void* data, size_t size) \u539f\u5730\u4ea4\u6362\u5185\u5b58\u4e2d\u6570\u636e\u7684\u5b57\u8282\u5e8f\u3002 \u53c2\u6570: data - \u6307\u5411\u6570\u636e\u7684\u6307\u9488 size - \u6570\u636e\u5927\u5c0f\uff08\u5b57\u8282\uff09 fix_endianness(Value& value, bool reverse_endianness) \u4fee\u6b63 Value \u5bf9\u8c61\u7684\u5b57\u8282\u5e8f\u3002 \u53c2\u6570: value - \u8981\u4fee\u6b63\u7684 Value \u5bf9\u8c61 reverse_endianness - \u662f\u5426\u53cd\u8f6c\u5b57\u8282\u5e8f process_checker \u6a21\u5757 ProcessChecker::check_process(pid_t pid) \u68c0\u67e5\u6307\u5b9a\u8fdb\u7a0b\u7684\u72b6\u6001\u3002 \u53c2\u6570: pid - \u8fdb\u7a0b ID \u8fd4\u56de\u503c: ProcessState \u679a\u4e3e\u503c\u8868\u793a\u8fdb\u7a0b\u72b6\u6001 ProcessChecker::is_process_dead(pid_t pid) \u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u5df2\u6b7b\u4ea1\u3002 \u53c2\u6570: pid - \u8fdb\u7a0b ID \u8fd4\u56de\u503c: true \u5982\u679c\u8fdb\u7a0b\u5df2\u6b7b\u4ea1\u6216\u4e0d\u5b58\u5728\uff0c\u5426\u5219 false sets \u6a21\u5757 Set::size() \u83b7\u53d6\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6570\u91cf\u3002 \u8fd4\u56de\u503c: \u5143\u7d20\u6570\u91cf Set::clear() \u6e05\u7a7a\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20\u3002 Set::cmp(const size_t& i1, const size_t& i2) \u6bd4\u8f83\u4e24\u4e2a size_t \u503c\u3002 \u53c2\u6570: i1 - \u7b2c\u4e00\u4e2a\u503c i2 - \u7b2c\u4e8c\u4e2a\u503c \u8fd4\u56de\u503c: \u6bd4\u8f83\u7ed3\u679c\uff08-1, 0, 1\uff09 parse_uintset(std::string_view lptr, Set& set, size_t maxSZ) \u89e3\u6790\u65e0\u7b26\u53f7\u6574\u6570\u96c6\u5408\u8868\u8fbe\u5f0f\u3002 \u53c2\u6570: lptr - \u8981\u89e3\u6790\u7684\u5b57\u7b26\u4e32 set - \u7528\u4e8e\u5b58\u50a8\u7ed3\u679c\u7684 Set \u5bf9\u8c61 maxSZ - \u6700\u5927\u5141\u8bb8\u503c \u8fd4\u56de\u503c: true \u5982\u679c\u89e3\u6790\u6210\u529f\uff0c\u5426\u5219 false show_message \u6a21\u5757 MessagePrinter::print(MessageType type, std::string_view fmt, Args&&... args) \u6253\u5370\u683c\u5f0f\u5316\u7684\u6d88\u606f\u3002 \u53c2\u6570: type - \u6d88\u606f\u7c7b\u578b fmt - \u683c\u5f0f\u5b57\u7b26\u4e32 args - \u683c\u5f0f\u5316\u53c2\u6570 MessagePrinter::info/warn/error/debug/user(fmt, args...) \u4fbf\u6377\u65b9\u6cd5\uff0c\u7528\u4e8e\u6253\u5370\u7279\u5b9a\u7c7b\u578b\u7684\u6d88\u606f\u3002 targetmem \u6a21\u5757 MatchesAndOldValuesSwath::addElement(void* addr, uint8_t byte, MatchFlags matchFlags) \u5411 swath \u6dfb\u52a0\u65b0\u7684\u5185\u5b58\u5339\u914d\u3002 \u53c2\u6570: addr - \u5185\u5b58\u5730\u5740 byte - \u5b57\u8282\u503c matchFlags - \u5339\u914d\u6807\u5fd7 MatchesAndOldValuesSwath::toPrintableString(size_t idx, size_t len) \u5c06\u5185\u5b58\u5b57\u8282\u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u5b57\u7b26\u4e32\u3002 \u53c2\u6570: idx - \u8d77\u59cb\u7d22\u5f15 len - \u957f\u5ea6 \u8fd4\u56de\u503c: \u53ef\u6253\u5370\u5b57\u7b26\u4e32 MatchesAndOldValuesArray::findSwathIndex(void* addr) \u67e5\u627e\u5305\u542b\u6307\u5b9a\u5730\u5740\u7684 swath \u7d22\u5f15\u3002 \u53c2\u6570: addr - \u5185\u5b58\u5730\u5740 \u8fd4\u56de\u503c: \u5305\u542b\u8be5\u5730\u5740\u7684 swath \u7d22\u5f15\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de std::nullopt MatchesAndOldValuesArray::getElement(void* addr) \u83b7\u53d6\u6307\u5b9a\u5730\u5740\u7684\u5143\u7d20\u6570\u636e\u3002 \u53c2\u6570: addr - \u5185\u5b58\u5730\u5740 \u8fd4\u56de\u503c: \u6307\u5411 OldValueAndMatchInfo \u7684\u6307\u9488\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de nullptr value \u6a21\u5757 Value::zero(Value& val) \u5c06 Value \u5bf9\u8c61\u6e05\u96f6\u3002 \u53c2\u6570: val - \u8981\u6e05\u96f6\u7684 Value \u5bf9\u8c61 API \u4f7f\u7528\u793a\u4f8b \u57fa\u672c\u7528\u6cd5 import endianness; import process_checker; import sets; import show_message; import targetmem; import value; // \u68c0\u67e5\u5b57\u8282\u5e8f if (endianness::is_little_endian()) { std::cout << \"\u7cfb\u7edf\u4e3a\u5c0f\u7aef\u5e8f\" << std::endl; } // \u68c0\u67e5\u8fdb\u7a0b\u72b6\u6001 pid_t pid = 1234; ProcessState state = ProcessChecker::check_process(pid); if (state == ProcessState::RUNNING) { std::cout << \"\u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\" << std::endl; } // \u89e3\u6790\u96c6\u5408 Set mySet; parse_uintset(\"1,2,3,4,5\", mySet, 100); // \u521b\u5efa\u6d88\u606f\u6253\u5370\u673a MessageContext ctx; ctx.debugMode = true; MessagePrinter printer(ctx); printer.info(\"\u5f00\u59cb\u5904\u7406\"); // \u521b\u5efa\u5185\u5b58\u5339\u914d\u6570\u7ec4 MatchesAndOldValuesArray matches; // \u521b\u5efa\u503c\u5bf9\u8c61 Value searchValue; searchValue.value = static_cast<int32_t>(42); searchValue.flags = MatchFlags::S32B; \u9ad8\u7ea7\u7528\u6cd5 // \u5b57\u8282\u5e8f\u8f6c\u6362 uint32_t value = 0x12345678; uint32_t swapped = endianness::swap_bytes(value); // \u8fdb\u7a0b\u76d1\u63a7\u5faa\u73af while (true) { if (ProcessChecker::is_process_dead(targetPid)) { std::cout << \"\u76ee\u6807\u8fdb\u7a0b\u5df2\u7ec8\u6b62\" << std::endl; break; } std::this_thread::sleep_for(std::chrono::milliseconds(100)); } // \u590d\u6742\u96c6\u5408\u89e3\u6790 Set complexSet; parse_uintset(\"1,5,10..15,0x20\", complexSet, 1000); // \u683c\u5f0f\u5316\u6d88\u606f printer.info(\"\u627e\u5230 {} \u4e2a\u5339\u914d\u9879\", matchCount); printer.warn(\"\u5185\u5b58\u4f7f\u7528\u7387: {:.2f}%\", memoryUsage); printer.error(\"\u5728\u5730\u5740 0x{:08x} \u5904\u8bfb\u53d6\u5931\u8d25\", address); // \u5185\u5b58\u5339\u914d\u64cd\u4f5c void* targetAddr = (void*)0x1000; auto swathIndex = matches.findSwathIndex(targetAddr); if (swathIndex) { const auto* element = matches.getElement(targetAddr); if (element) { std::cout << \"\u65e7\u503c: 0x\" << std::hex << (int)element->old_value << std::endl; } }","title":"API \u53c2\u8003"},{"location":"API_REFERENCE/#api","text":"","title":"API \u53c2\u8003"},{"location":"API_REFERENCE/#_1","text":"endianness maps process_checker sets show_message targetmem value","title":"\u6a21\u5757\u7d22\u5f15"},{"location":"API_REFERENCE/#maps","text":"","title":"maps"},{"location":"API_REFERENCE/#region_type","text":"enum class region_type : uint8_t { misc, // \u6742\u9879\u5185\u5b58\u533a\u57df exe, // \u53ef\u6267\u884c\u6587\u4ef6\u4e8c\u8fdb\u5236\u533a\u57df code, // \u4ee3\u7801\u6bb5\uff08\u5171\u4eab\u5e93\u7b49\uff09 heap, // \u5806\u5185\u5b58\u533a\u57df stack // \u6808\u5185\u5b58\u533a\u57df }; constexpr std::array<std::string_view, 5> region_type_names;","title":"\u679a\u4e3e\uff1aregion_type"},{"location":"API_REFERENCE/#region_scan_level","text":"enum class region_scan_level : uint8_t { all, // \u6240\u6709\u53ef\u8bfb\u533a\u57df all_rw, // \u6240\u6709\u53ef\u8bfb/\u53ef\u5199\u533a\u57df heap_stack_executable, // \u5806\u3001\u6808\u548c\u53ef\u6267\u884c\u533a\u57df heap_stack_executable_bss // \u4e0a\u8ff0\u52a0\u4e0a BSS \u6bb5 };","title":"\u679a\u4e3e\uff1aregion_scan_level"},{"location":"API_REFERENCE/#region_flags","text":"struct region_flags { bool read : 1; // \u8bfb\u6743\u9650 bool write : 1; // \u5199\u6743\u9650 bool exec : 1; // \u6267\u884c\u6743\u9650 bool shared : 1; // \u5171\u4eab\u6620\u5c04 bool private_ : 1; // \u79c1\u6709\u6620\u5c04 };","title":"\u7ed3\u6784\uff1aregion_flags"},{"location":"API_REFERENCE/#region","text":"struct region { void* start; // \u8d77\u59cb\u5730\u5740 std::size_t size; // \u533a\u57df\u5927\u5c0f\uff08\u5b57\u8282\uff09 region_type type; // \u533a\u57df\u5206\u7c7b region_flags flags; // \u6743\u9650\u6807\u5fd7 void* load_addr; // ELF \u6587\u4ef6\u7684\u52a0\u8f7d\u5730\u5740 std::string filename; // \u5173\u8054\u6587\u4ef6\u8def\u5f84 std::size_t id; // \u552f\u4e00\u6807\u8bc6\u7b26 [[nodiscard]] bool is_readable() const noexcept; [[nodiscard]] bool is_writable() const noexcept; [[nodiscard]] bool is_executable() const noexcept; [[nodiscard]] bool is_shared() const noexcept; [[nodiscard]] bool is_private() const noexcept; [[nodiscard]] std::pair<void*, std::size_t> as_span() const noexcept; [[nodiscard]] bool contains(void* address) const noexcept; };","title":"\u7ed3\u6784\uff1aregion"},{"location":"API_REFERENCE/#maps_readererror","text":"struct error { std::string message; // \u4eba\u7c7b\u53ef\u8bfb\u7684\u9519\u8bef\u63cf\u8ff0 std::error_code code; // \u7cfb\u7edf\u9519\u8bef\u4ee3\u7801 };","title":"\u7ed3\u6784\uff1amaps_reader::error"},{"location":"API_REFERENCE/#maps_reader","text":"","title":"\u7c7b\uff1amaps_reader"},{"location":"API_REFERENCE/#_2","text":"[[nodiscard]] static std::expected<std::vector<region>, error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);","title":"\u9759\u6001\u65b9\u6cd5"},{"location":"API_REFERENCE/#_3","text":"[[nodiscard]] std::expected<std::vector<region>, maps_reader::error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);","title":"\u4fbf\u5229\u51fd\u6570"},{"location":"API_REFERENCE/#_4","text":"import maps; // \u57fa\u672c\u7528\u6cd5 auto regions = maps::read_process_maps(1234); // \u8fc7\u6ee4\u626b\u63cf auto heap_regions = maps::read_process_maps( pid, maps::region_scan_level::heap_stack_executable ); // \u9519\u8bef\u5904\u7406 if (!regions) { std::cerr << \"\u9519\u8bef: \" << regions.error().message << \"\\n\"; }","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"API_REFERENCE/#endianness","text":"","title":"endianness"},{"location":"API_REFERENCE/#endianness_1","text":"","title":"\u547d\u540d\u7a7a\u95f4: endianness"},{"location":"API_REFERENCE/#_5","text":"// \u5b57\u8282\u5e8f\u68c0\u6d4b constexpr bool is_big_endian() noexcept; constexpr bool is_little_endian() noexcept; // \u5b57\u8282\u4ea4\u6362 constexpr uint8_t swap_bytes(uint8_t value) noexcept; constexpr uint16_t swap_bytes(uint16_t value) noexcept; constexpr uint32_t swap_bytes(uint32_t value) noexcept; constexpr uint64_t swap_bytes(uint64_t value) noexcept; template<typename T> constexpr T swap_bytes_integral(T value) noexcept; void swap_bytes_inplace(void* data, size_t size); // \u5b57\u8282\u5e8f\u4fee\u6b63 void fix_endianness(Value& value, bool reverse_endianness) noexcept; // \u7f51\u7edc\u5b57\u8282\u5e8f template<SwappableIntegral T> constexpr T host_to_network(T value) noexcept; template<SwappableIntegral T> constexpr T network_to_host(T value) noexcept; // \u5c0f\u7aef\u5e8f\u8f6c\u6362 template<SwappableIntegral T> constexpr T host_to_little_endian(T value) noexcept; template<SwappableIntegral T> constexpr T little_endian_to_host(T value) noexcept;","title":"\u51fd\u6570"},{"location":"API_REFERENCE/#_6","text":"template<typename T> concept SwappableIntegral = std::integral<T> && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8);","title":"\u6982\u5ff5"},{"location":"API_REFERENCE/#process_checker","text":"","title":"process_checker"},{"location":"API_REFERENCE/#processstate","text":"enum class ProcessState { RUNNING, ERROR, DEAD, ZOMBIE };","title":"\u679a\u4e3e: ProcessState"},{"location":"API_REFERENCE/#processchecker","text":"","title":"\u7c7b: ProcessChecker"},{"location":"API_REFERENCE/#processchecker_1","text":"static ProcessState check_process(pid_t pid); static bool is_process_dead(pid_t pid);","title":"ProcessChecker \u9759\u6001\u65b9\u6cd5"},{"location":"API_REFERENCE/#sets","text":"","title":"sets"},{"location":"API_REFERENCE/#set","text":"struct Set { std::vector<size_t> buf; size_t size() const; void clear(); static int cmp(const size_t& i1, const size_t& i2); };","title":"\u7ed3\u6784\u4f53: Set"},{"location":"API_REFERENCE/#set_1","text":"bool parse_uintset(std::string_view lptr, Set& set, size_t maxSZ);","title":"Set \u51fd\u6570"},{"location":"API_REFERENCE/#show_message","text":"","title":"show_message"},{"location":"API_REFERENCE/#messagetype","text":"enum class MessageType : uint8_t { INFO, // \u4fe1\u606f\u6d88\u606f WARN, // \u8b66\u544a\u6d88\u606f ERROR, // \u9519\u8bef\u6d88\u606f DEBUG, // \u8c03\u8bd5\u6d88\u606f USER // \u7528\u6237\u6d88\u606f };","title":"\u679a\u4e3e: MessageType"},{"location":"API_REFERENCE/#messagecontext","text":"struct MessageContext { bool debugMode = false; // \u8c03\u8bd5\u6a21\u5f0f bool backendMode = false; // \u540e\u7aef\u6a21\u5f0f };","title":"\u7ed3\u6784\u4f53: MessageContext"},{"location":"API_REFERENCE/#messageprinter","text":"","title":"\u7c7b: MessagePrinter"},{"location":"API_REFERENCE/#_7","text":"MessagePrinter(MessageContext ctx = {});","title":"\u6784\u9020\u51fd\u6570"},{"location":"API_REFERENCE/#_8","text":"template<typename... Args> void print(MessageType type, std::string_view fmt, Args&&... args) const; template<typename... Args> void info(std::string_view fmt, Args&&... args) const; template<typename... Args> void warn(std::string_view fmt, Args&&... args) const; template<typename... Args> void error(std::string_view fmt, Args&&... args) const; template<typename... Args> void debug(std::string_view fmt, Args&&... args) const; template<typename... Args> void user(std::string_view fmt, Args&&... args) const;","title":"\u65b9\u6cd5"},{"location":"API_REFERENCE/#targetmem","text":"","title":"targetmem"},{"location":"API_REFERENCE/#oldvalueandmatchinfo","text":"struct OldValueAndMatchInfo { uint8_t old_value; // \u539f\u59cb\u5b57\u8282\u503c MatchFlags match_info; // \u5339\u914d\u7c7b\u578b\u548c\u72b6\u6001\u6807\u5fd7 };","title":"\u7ed3\u6784\u4f53: OldValueAndMatchInfo"},{"location":"API_REFERENCE/#matchesandoldvaluesswath","text":"","title":"\u7c7b: MatchesAndOldValuesSwath"},{"location":"API_REFERENCE/#_9","text":"void* firstByteInChild = nullptr; // \u8d77\u59cb\u5730\u5740 std::vector<OldValueAndMatchInfo> data; // \u5339\u914d\u6570\u636e","title":"\u6210\u5458\u53d8\u91cf"},{"location":"API_REFERENCE/#matchesandoldvaluesswath_1","text":"void addElement(void* addr, uint8_t byte, MatchFlags matchFlags); std::string toPrintableString(size_t idx, size_t len) const; std::string toByteArrayText(size_t idx, size_t len) const;","title":"MatchesAndOldValuesSwath \u65b9\u6cd5"},{"location":"API_REFERENCE/#matchesandoldvaluesarray","text":"","title":"\u7c7b: MatchesAndOldValuesArray"},{"location":"API_REFERENCE/#matchesandoldvaluesarray_1","text":"std::vector<MatchesAndOldValuesSwath> swaths; // \u5185\u5b58\u533a\u57df\u96c6\u5408","title":"MatchesAndOldValuesArray \u6210\u5458\u53d8\u91cf"},{"location":"API_REFERENCE/#matchesandoldvaluesarray_2","text":"std::optional<size_t> findSwathIndex(void* addr) const; std::optional<size_t> findElementIndex(void* addr) const; const OldValueAndMatchInfo* getElement(void* addr) const; OldValueAndMatchInfo* getElement(void* addr); void clear(); size_t size() const;","title":"MatchesAndOldValuesArray \u65b9\u6cd5"},{"location":"API_REFERENCE/#value","text":"","title":"value"},{"location":"API_REFERENCE/#matchflags","text":"enum class [[gnu::packed]] MatchFlags : uint16_t { EMPTY = 0, // \u57fa\u672c\u6570\u503c\u7c7b\u578b U8B = 1 << 0, // \u65e0\u7b26\u53f7 8 \u4f4d S8B = 1 << 1, // \u6709\u7b26\u53f7 8 \u4f4d U16B = 1 << 2, // \u65e0\u7b26\u53f7 16 \u4f4d S16B = 1 << 3, // \u6709\u7b26\u53f7 16 \u4f4d U32B = 1 << 4, // \u65e0\u7b26\u53f7 32 \u4f4d S32B = 1 << 5, // \u6709\u7b26\u53f7 32 \u4f4d U64B = 1 << 6, // \u65e0\u7b26\u53f7 64 \u4f4d S64B = 1 << 7, // \u6709\u7b26\u53f7 64 \u4f4d // \u6d6e\u70b9\u7c7b\u578b F32B = 1 << 8, // 32 \u4f4d\u6d6e\u70b9 F64B = 1 << 9, // 64 \u4f4d\u6d6e\u70b9 // \u590d\u5408\u7c7b\u578b I8B = U8B | S8B, // \u4efb\u610f 8 \u4f4d\u6574\u6570 I16B = U16B | S16B, // \u4efb\u610f 16 \u4f4d\u6574\u6570 I32B = U32B | S32B, // \u4efb\u610f 32 \u4f4d\u6574\u6570 I64B = U64B | S64B, // \u4efb\u610f 64 \u4f4d\u6574\u6570 INTEGER = I8B | I16B | I32B | I64B, // \u6240\u6709\u6574\u6570\u7c7b\u578b FLOAT = F32B | F64B, // \u6240\u6709\u6d6e\u70b9\u7c7b\u578b ALL = INTEGER | FLOAT, // \u6240\u6709\u652f\u6301\u7684\u7c7b\u578b // \u57fa\u4e8e\u5b57\u8282\u7684\u5206\u7ec4 B8 = I8B, // 8 \u4f4d\u5757 B16 = I16B, // 16 \u4f4d\u5757 B32 = I32B | F32B, // 32 \u4f4d\u5757 B64 = I64B | F64B, // 64 \u4f4d\u5757 MAX = 0xffffU // \u6700\u5927\u6807\u5fd7\u503c };","title":"\u679a\u4e3e: MatchFlags"},{"location":"API_REFERENCE/#value_1","text":"struct [[gnu::packed]] Value { std::vector<uint8_t> bytes; // \u5386\u53f2\u503c\u5b57\u8282 MatchFlags flags = MatchFlags::EMPTY; // \u7c7b\u578b/\u5bbd\u5ea6\u6807\u5fd7 // \u590d\u4f4d constexpr static void zero(Value& val); // \u89c6\u56fe\u4e0e\u8bbe\u7f6e std::span<const uint8_t> view() const noexcept; void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& val); void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f); void setBytesWithFlag(const std::vector<uint8_t>& val, MatchFlags f); template <typename T> void setScalar(const T& v); template <typename T> void setScalarWithFlag(const T& v, MatchFlags f); template <typename T> void setScalarTyped(const T& v); }; \u6570\u503c\u4e25\u683c\uff1a\u65e7\u503c\u89e3\u7801\u65f6\u9700\u8981 flags \u4e0e\u7c7b\u578b\u5339\u914d\u4e14\u5b57\u8282\u6570\u8db3\u591f\uff1b\u5b57\u8282\u4e32/\u5b57\u7b26\u4e32\u4e0d\u53d7\u6b64\u9650\u5236\u3002","title":"\u7ed3\u6784\u4f53: Value"},{"location":"API_REFERENCE/#mem64","text":"struct [[gnu::packed]] Mem64 { std::vector<uint8_t> buffer; // \u5f53\u524d\u503c\u5b57\u8282 template <typename T> T get() const; // \u4ee5 memcpy \u89e3\u7801 std::span<const uint8_t> bytes() const noexcept; // \u53ea\u8bfb\u5b57\u8282\u89c6\u56fe void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& data); void setString(const std::string& s); template <typename T> void setScalar(const T& v); };","title":"\u7ed3\u6784\u4f53: Mem64"},{"location":"API_REFERENCE/#_10","text":"","title":"\u8be6\u7ec6\u51fd\u6570\u8bf4\u660e"},{"location":"API_REFERENCE/#endianness_2","text":"","title":"endianness \u6a21\u5757"},{"location":"API_REFERENCE/#is_big_endian","text":"\u68c0\u6d4b\u7cfb\u7edf\u662f\u5426\u4e3a\u5927\u7aef\u5e8f\u3002 \u8fd4\u56de\u503c: true \u5982\u679c\u7cfb\u7edf\u4e3a\u5927\u7aef\u5e8f\uff0c\u5426\u5219 false","title":"is_big_endian()"},{"location":"API_REFERENCE/#is_little_endian","text":"\u68c0\u6d4b\u7cfb\u7edf\u662f\u5426\u4e3a\u5c0f\u7aef\u5e8f\u3002 \u8fd4\u56de\u503c: true \u5982\u679c\u7cfb\u7edf\u4e3a\u5c0f\u7aef\u5e8f\uff0c\u5426\u5219 false","title":"is_little_endian()"},{"location":"API_REFERENCE/#swap_bytest-value","text":"\u4ea4\u6362\u6307\u5b9a\u7c7b\u578b\u503c\u7684\u5b57\u8282\u5e8f\u3002 \u6a21\u677f\u53c2\u6570: T - \u6574\u6570\u7c7b\u578b (uint8_t, uint16_t, uint32_t, uint64_t) \u53c2\u6570: value - \u8981\u4ea4\u6362\u5b57\u8282\u5e8f\u7684\u503c \u8fd4\u56de\u503c: \u4ea4\u6362\u5b57\u8282\u5e8f\u540e\u7684\u503c","title":"swap_bytes(T value)"},{"location":"API_REFERENCE/#swap_bytes_inplacevoid-data-size_t-size","text":"\u539f\u5730\u4ea4\u6362\u5185\u5b58\u4e2d\u6570\u636e\u7684\u5b57\u8282\u5e8f\u3002 \u53c2\u6570: data - \u6307\u5411\u6570\u636e\u7684\u6307\u9488 size - \u6570\u636e\u5927\u5c0f\uff08\u5b57\u8282\uff09","title":"swap_bytes_inplace(void* data, size_t size)"},{"location":"API_REFERENCE/#fix_endiannessvalue-value-bool-reverse_endianness","text":"\u4fee\u6b63 Value \u5bf9\u8c61\u7684\u5b57\u8282\u5e8f\u3002 \u53c2\u6570: value - \u8981\u4fee\u6b63\u7684 Value \u5bf9\u8c61 reverse_endianness - \u662f\u5426\u53cd\u8f6c\u5b57\u8282\u5e8f","title":"fix_endianness(Value&amp; value, bool reverse_endianness)"},{"location":"API_REFERENCE/#process_checker_1","text":"","title":"process_checker \u6a21\u5757"},{"location":"API_REFERENCE/#processcheckercheck_processpid_t-pid","text":"\u68c0\u67e5\u6307\u5b9a\u8fdb\u7a0b\u7684\u72b6\u6001\u3002 \u53c2\u6570: pid - \u8fdb\u7a0b ID \u8fd4\u56de\u503c: ProcessState \u679a\u4e3e\u503c\u8868\u793a\u8fdb\u7a0b\u72b6\u6001","title":"ProcessChecker::check_process(pid_t pid)"},{"location":"API_REFERENCE/#processcheckeris_process_deadpid_t-pid","text":"\u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u5df2\u6b7b\u4ea1\u3002 \u53c2\u6570: pid - \u8fdb\u7a0b ID \u8fd4\u56de\u503c: true \u5982\u679c\u8fdb\u7a0b\u5df2\u6b7b\u4ea1\u6216\u4e0d\u5b58\u5728\uff0c\u5426\u5219 false","title":"ProcessChecker::is_process_dead(pid_t pid)"},{"location":"API_REFERENCE/#sets_1","text":"","title":"sets \u6a21\u5757"},{"location":"API_REFERENCE/#setsize","text":"\u83b7\u53d6\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6570\u91cf\u3002 \u8fd4\u56de\u503c: \u5143\u7d20\u6570\u91cf","title":"Set::size()"},{"location":"API_REFERENCE/#setclear","text":"\u6e05\u7a7a\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20\u3002","title":"Set::clear()"},{"location":"API_REFERENCE/#setcmpconst-size_t-i1-const-size_t-i2","text":"\u6bd4\u8f83\u4e24\u4e2a size_t \u503c\u3002 \u53c2\u6570: i1 - \u7b2c\u4e00\u4e2a\u503c i2 - \u7b2c\u4e8c\u4e2a\u503c \u8fd4\u56de\u503c: \u6bd4\u8f83\u7ed3\u679c\uff08-1, 0, 1\uff09","title":"Set::cmp(const size_t&amp; i1, const size_t&amp; i2)"},{"location":"API_REFERENCE/#parse_uintsetstdstring_view-lptr-set-set-size_t-maxsz","text":"\u89e3\u6790\u65e0\u7b26\u53f7\u6574\u6570\u96c6\u5408\u8868\u8fbe\u5f0f\u3002 \u53c2\u6570: lptr - \u8981\u89e3\u6790\u7684\u5b57\u7b26\u4e32 set - \u7528\u4e8e\u5b58\u50a8\u7ed3\u679c\u7684 Set \u5bf9\u8c61 maxSZ - \u6700\u5927\u5141\u8bb8\u503c \u8fd4\u56de\u503c: true \u5982\u679c\u89e3\u6790\u6210\u529f\uff0c\u5426\u5219 false","title":"parse_uintset(std::string_view lptr, Set&amp; set, size_t maxSZ)"},{"location":"API_REFERENCE/#show_message_1","text":"","title":"show_message \u6a21\u5757"},{"location":"API_REFERENCE/#messageprinterprintmessagetype-type-stdstring_view-fmt-args-args","text":"\u6253\u5370\u683c\u5f0f\u5316\u7684\u6d88\u606f\u3002 \u53c2\u6570: type - \u6d88\u606f\u7c7b\u578b fmt - \u683c\u5f0f\u5b57\u7b26\u4e32 args - \u683c\u5f0f\u5316\u53c2\u6570","title":"MessagePrinter::print(MessageType type, std::string_view fmt, Args&amp;&amp;... args)"},{"location":"API_REFERENCE/#messageprinterinfowarnerrordebuguserfmt-args","text":"\u4fbf\u6377\u65b9\u6cd5\uff0c\u7528\u4e8e\u6253\u5370\u7279\u5b9a\u7c7b\u578b\u7684\u6d88\u606f\u3002","title":"MessagePrinter::info/warn/error/debug/user(fmt, args...)"},{"location":"API_REFERENCE/#targetmem_1","text":"","title":"targetmem \u6a21\u5757"},{"location":"API_REFERENCE/#matchesandoldvaluesswathaddelementvoid-addr-uint8_t-byte-matchflags-matchflags","text":"\u5411 swath \u6dfb\u52a0\u65b0\u7684\u5185\u5b58\u5339\u914d\u3002 \u53c2\u6570: addr - \u5185\u5b58\u5730\u5740 byte - \u5b57\u8282\u503c matchFlags - \u5339\u914d\u6807\u5fd7","title":"MatchesAndOldValuesSwath::addElement(void* addr, uint8_t byte, MatchFlags matchFlags)"},{"location":"API_REFERENCE/#matchesandoldvaluesswathtoprintablestringsize_t-idx-size_t-len","text":"\u5c06\u5185\u5b58\u5b57\u8282\u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u5b57\u7b26\u4e32\u3002 \u53c2\u6570: idx - \u8d77\u59cb\u7d22\u5f15 len - \u957f\u5ea6 \u8fd4\u56de\u503c: \u53ef\u6253\u5370\u5b57\u7b26\u4e32","title":"MatchesAndOldValuesSwath::toPrintableString(size_t idx, size_t len)"},{"location":"API_REFERENCE/#matchesandoldvaluesarrayfindswathindexvoid-addr","text":"\u67e5\u627e\u5305\u542b\u6307\u5b9a\u5730\u5740\u7684 swath \u7d22\u5f15\u3002 \u53c2\u6570: addr - \u5185\u5b58\u5730\u5740 \u8fd4\u56de\u503c: \u5305\u542b\u8be5\u5730\u5740\u7684 swath \u7d22\u5f15\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de std::nullopt","title":"MatchesAndOldValuesArray::findSwathIndex(void* addr)"},{"location":"API_REFERENCE/#matchesandoldvaluesarraygetelementvoid-addr","text":"\u83b7\u53d6\u6307\u5b9a\u5730\u5740\u7684\u5143\u7d20\u6570\u636e\u3002 \u53c2\u6570: addr - \u5185\u5b58\u5730\u5740 \u8fd4\u56de\u503c: \u6307\u5411 OldValueAndMatchInfo \u7684\u6307\u9488\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de nullptr","title":"MatchesAndOldValuesArray::getElement(void* addr)"},{"location":"API_REFERENCE/#value_2","text":"","title":"value \u6a21\u5757"},{"location":"API_REFERENCE/#valuezerovalue-val","text":"\u5c06 Value \u5bf9\u8c61\u6e05\u96f6\u3002 \u53c2\u6570: val - \u8981\u6e05\u96f6\u7684 Value \u5bf9\u8c61","title":"Value::zero(Value&amp; val)"},{"location":"API_REFERENCE/#api_1","text":"","title":"API \u4f7f\u7528\u793a\u4f8b"},{"location":"API_REFERENCE/#_11","text":"import endianness; import process_checker; import sets; import show_message; import targetmem; import value; // \u68c0\u67e5\u5b57\u8282\u5e8f if (endianness::is_little_endian()) { std::cout << \"\u7cfb\u7edf\u4e3a\u5c0f\u7aef\u5e8f\" << std::endl; } // \u68c0\u67e5\u8fdb\u7a0b\u72b6\u6001 pid_t pid = 1234; ProcessState state = ProcessChecker::check_process(pid); if (state == ProcessState::RUNNING) { std::cout << \"\u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\" << std::endl; } // \u89e3\u6790\u96c6\u5408 Set mySet; parse_uintset(\"1,2,3,4,5\", mySet, 100); // \u521b\u5efa\u6d88\u606f\u6253\u5370\u673a MessageContext ctx; ctx.debugMode = true; MessagePrinter printer(ctx); printer.info(\"\u5f00\u59cb\u5904\u7406\"); // \u521b\u5efa\u5185\u5b58\u5339\u914d\u6570\u7ec4 MatchesAndOldValuesArray matches; // \u521b\u5efa\u503c\u5bf9\u8c61 Value searchValue; searchValue.value = static_cast<int32_t>(42); searchValue.flags = MatchFlags::S32B;","title":"\u57fa\u672c\u7528\u6cd5"},{"location":"API_REFERENCE/#_12","text":"// \u5b57\u8282\u5e8f\u8f6c\u6362 uint32_t value = 0x12345678; uint32_t swapped = endianness::swap_bytes(value); // \u8fdb\u7a0b\u76d1\u63a7\u5faa\u73af while (true) { if (ProcessChecker::is_process_dead(targetPid)) { std::cout << \"\u76ee\u6807\u8fdb\u7a0b\u5df2\u7ec8\u6b62\" << std::endl; break; } std::this_thread::sleep_for(std::chrono::milliseconds(100)); } // \u590d\u6742\u96c6\u5408\u89e3\u6790 Set complexSet; parse_uintset(\"1,5,10..15,0x20\", complexSet, 1000); // \u683c\u5f0f\u5316\u6d88\u606f printer.info(\"\u627e\u5230 {} \u4e2a\u5339\u914d\u9879\", matchCount); printer.warn(\"\u5185\u5b58\u4f7f\u7528\u7387: {:.2f}%\", memoryUsage); printer.error(\"\u5728\u5730\u5740 0x{:08x} \u5904\u8bfb\u53d6\u5931\u8d25\", address); // \u5185\u5b58\u5339\u914d\u64cd\u4f5c void* targetAddr = (void*)0x1000; auto swathIndex = matches.findSwathIndex(targetAddr); if (swathIndex) { const auto* element = matches.getElement(targetAddr); if (element) { std::cout << \"\u65e7\u503c: 0x\" << std::hex << (int)element->old_value << std::endl; } }","title":"\u9ad8\u7ea7\u7528\u6cd5"},{"location":"NamingConvention/","text":"C++ \u547d\u540d\u89c4\u8303 1. \u7c7b\u548c\u7ed3\u6784\u4f53 \u7c7b\u540d \uff1a\u4f7f\u7528 CamelCase \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClassName {}; \u7ed3\u6784\u4f53\u540d \uff1a\u4f7f\u7528 CamelCase \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp struct MyStructName {}; 2. \u679a\u4e3e \u679a\u4e3e\u7c7b\u578b\u540d \uff1a\u4f7f\u7528 CamelCase \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp enum MyEnumType {}; \u679a\u4e3e\u5e38\u91cf\u540d \uff1a\u4f7f\u7528 UPPER_CASE \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp enum MyEnumType { ENUM_CONSTANT_ONE, ENUM_CONSTANT_TWO }; 3. \u51fd\u6570 \u51fd\u6570\u540d \uff1a\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp void myFunctionName(); 4. \u53d8\u91cf \u666e\u901a\u53d8\u91cf\u540d \uff1a\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp int myVariableName; \u5168\u5c40\u53d8\u91cf\u540d \uff1a\u4f7f\u7528 UPPER_CASE \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp int GLOBAL_VARIABLE_NAME; \u5e38\u91cf\u540d \uff1a\u4f7f\u7528 UPPER_CASE \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp const int MAX_BUFFER_SIZE = 1024; 5. \u53c2\u6570 \u51fd\u6570\u53c2\u6570\u540d \uff1a\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp void myFunction(int parameterName); 6. \u547d\u540d\u7a7a\u95f4 \u547d\u540d\u7a7a\u95f4\u540d \uff1a\u4f7f\u7528 lower_case \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp namespace my_namespace { void myFunction(); } 7. \u5b8f \u5b8f\u5b9a\u4e49\u540d \uff1a\u4f7f\u7528 UPPER_CASE \u98ce\u683c\u3002 \u793a\u4f8b\uff1a ```cpp define MAX_BUFFER_SIZE 1024 ``` 8. \u6210\u5458\u53d8\u91cf \u79c1\u6709\u6210\u5458\u53d8\u91cf \uff1a\u4ee5 m_ \u4e3a\u524d\u7f00\uff0c\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClass { private: int m_privateMember; }; \u53d7\u4fdd\u62a4\u6210\u5458\u53d8\u91cf \uff1a\u4ee5 m_ \u4e3a\u524d\u7f00\uff0c\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClass { protected: int m_protectedMember; }; \u9759\u6001\u6210\u5458\u53d8\u91cf \uff1a\u4ee5 s_ \u4e3a\u524d\u7f00\uff0c\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClass { private: static int s_staticMember; }; \u516c\u5171\u6210\u5458\u53d8\u91cf \uff1a\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClass { public: int publicMemberVariable; }; 9. \u7279\u6b8a\u89c4\u5219 \u7981\u7528\u7684\u89c4\u5219 \uff1a \u7981\u7528 modernize-use-trailing-return-type \u3002 \u7981\u7528 modernize-avoid-c-arrays \u3002","title":"\u547d\u540d\u89c4\u5219"},{"location":"NamingConvention/#c","text":"","title":"C++ \u547d\u540d\u89c4\u8303"},{"location":"NamingConvention/#1","text":"\u7c7b\u540d \uff1a\u4f7f\u7528 CamelCase \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClassName {}; \u7ed3\u6784\u4f53\u540d \uff1a\u4f7f\u7528 CamelCase \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp struct MyStructName {};","title":"1. \u7c7b\u548c\u7ed3\u6784\u4f53"},{"location":"NamingConvention/#2","text":"\u679a\u4e3e\u7c7b\u578b\u540d \uff1a\u4f7f\u7528 CamelCase \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp enum MyEnumType {}; \u679a\u4e3e\u5e38\u91cf\u540d \uff1a\u4f7f\u7528 UPPER_CASE \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp enum MyEnumType { ENUM_CONSTANT_ONE, ENUM_CONSTANT_TWO };","title":"2. \u679a\u4e3e"},{"location":"NamingConvention/#3","text":"\u51fd\u6570\u540d \uff1a\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp void myFunctionName();","title":"3. \u51fd\u6570"},{"location":"NamingConvention/#4","text":"\u666e\u901a\u53d8\u91cf\u540d \uff1a\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp int myVariableName; \u5168\u5c40\u53d8\u91cf\u540d \uff1a\u4f7f\u7528 UPPER_CASE \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp int GLOBAL_VARIABLE_NAME; \u5e38\u91cf\u540d \uff1a\u4f7f\u7528 UPPER_CASE \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp const int MAX_BUFFER_SIZE = 1024;","title":"4. \u53d8\u91cf"},{"location":"NamingConvention/#5","text":"\u51fd\u6570\u53c2\u6570\u540d \uff1a\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp void myFunction(int parameterName);","title":"5. \u53c2\u6570"},{"location":"NamingConvention/#6","text":"\u547d\u540d\u7a7a\u95f4\u540d \uff1a\u4f7f\u7528 lower_case \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp namespace my_namespace { void myFunction(); }","title":"6. \u547d\u540d\u7a7a\u95f4"},{"location":"NamingConvention/#7","text":"\u5b8f\u5b9a\u4e49\u540d \uff1a\u4f7f\u7528 UPPER_CASE \u98ce\u683c\u3002 \u793a\u4f8b\uff1a ```cpp","title":"7. \u5b8f"},{"location":"NamingConvention/#define-max_buffer_size-1024","text":"```","title":"define MAX_BUFFER_SIZE 1024"},{"location":"NamingConvention/#8","text":"\u79c1\u6709\u6210\u5458\u53d8\u91cf \uff1a\u4ee5 m_ \u4e3a\u524d\u7f00\uff0c\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClass { private: int m_privateMember; }; \u53d7\u4fdd\u62a4\u6210\u5458\u53d8\u91cf \uff1a\u4ee5 m_ \u4e3a\u524d\u7f00\uff0c\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClass { protected: int m_protectedMember; }; \u9759\u6001\u6210\u5458\u53d8\u91cf \uff1a\u4ee5 s_ \u4e3a\u524d\u7f00\uff0c\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClass { private: static int s_staticMember; }; \u516c\u5171\u6210\u5458\u53d8\u91cf \uff1a\u4f7f\u7528 camelBack \u98ce\u683c\u3002 \u793a\u4f8b\uff1a cpp class MyClass { public: int publicMemberVariable; };","title":"8. \u6210\u5458\u53d8\u91cf"},{"location":"NamingConvention/#9","text":"\u7981\u7528\u7684\u89c4\u5219 \uff1a \u7981\u7528 modernize-use-trailing-return-type \u3002 \u7981\u7528 modernize-avoid-c-arrays \u3002","title":"9. \u7279\u6b8a\u89c4\u5219"},{"location":"endianness/","text":"\u5b57\u8282\u5e8f\u6a21\u5757\u6587\u6863 \u6982\u8ff0 endianness \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5168\u9762\u7684\u5b57\u8282\u5e8f\u5904\u7406\u5de5\u5177\u3002\u5b83\u652f\u6301\u7f16\u8bd1\u65f6\u548c\u8fd0\u884c\u65f6\u5b57\u8282\u5e8f\u68c0\u6d4b\u3001\u5b57\u8282\u4ea4\u6362\u64cd\u4f5c\uff0c\u4ee5\u53ca\u5404\u79cd\u6570\u636e\u7c7b\u578b\u7684\u81ea\u52a8\u5b57\u8282\u5e8f\u6821\u6b63\u3002 \u6a21\u5757\u7ed3\u6784 export module endianness; \u4f9d\u8d56\u9879 <cstdint> - \u5b9a\u5bbd\u6574\u6570\u7c7b\u578b <cstring> - C\u5b57\u7b26\u4e32\u64cd\u4f5c <bit> - \u4f4d\u64cd\u4f5c\u548c\u5b57\u8282\u5e8f\u68c0\u6d4b <type_traits> - \u6a21\u677f\u5143\u7f16\u7a0b\u7684\u7c7b\u578b\u7279\u5f81 <concepts> - C++20\u6982\u5ff5 value \u6a21\u5757 - \u503c\u7c7b\u578b\u5b9a\u4e49 \u6838\u5fc3\u529f\u80fd 1. \u5b57\u8282\u5e8f\u68c0\u6d4b \u7f16\u8bd1\u65f6\u68c0\u6d4b constexpr bool isBigEndian() noexcept; constexpr bool isLittleEndian() noexcept; \u4f7f\u7528 std::endian::native \u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\u4e3b\u673a\u5b57\u8282\u5e8f\u3002 2. \u5b57\u8282\u4ea4\u6362\u51fd\u6570 \u57fa\u672c\u5b57\u8282\u4ea4\u6362\u51fd\u6570 constexpr uint8_t swapBytes(uint8_t value) noexcept; constexpr uint16_t swapBytes(uint16_t value) noexcept; constexpr uint32_t swapBytes(uint32_t value) noexcept; constexpr uint64_t swapBytes(uint64_t value) noexcept; \u901a\u7528\u5b57\u8282\u4ea4\u6362\u51fd\u6570 template<typename T> constexpr T swapBytesIntegral(T value) noexcept; \u652f\u6301\u5927\u5c0f\u4e3a1\u30012\u30014\u548c8\u5b57\u8282\u7684\u6574\u6570\u7c7b\u578b\u3002 3. \u503c\u7c7b\u578b\u5b57\u8282\u5e8f\u6821\u6b63\u51fd\u6570 void fixEndianness(Value& value, bool reverseEndianness) noexcept; \u5bf9 Value \u7684 bytes \u8fdb\u884c\u5c31\u5730\u5b57\u8282\u5e8f\u6821\u6b63\uff08\u6839\u636e flags \u63a8\u65ad\u5bbd\u5ea6 2/4/8\uff09\u3002 4. \u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u6362\u51fd\u6570 template<SwappableIntegral T> constexpr T hostToNetwork(T value) noexcept; template<SwappableIntegral T> constexpr T networkToHost(T value) noexcept; \u5728\u4e3b\u673a\u548c\u7f51\u7edc\u5b57\u8282\u5e8f\uff08\u5927\u7aef\uff09\u4e4b\u95f4\u8f6c\u6362\u3002 5. \u5c0f\u7aef\u8f6c\u6362\u51fd\u6570 template<SwappableIntegral T> constexpr T hostToLittleEndian(T value) noexcept; template<SwappableIntegral T> constexpr T littleEndianToHost(T value) noexcept; \u4f7f\u7528\u793a\u4f8b \u57fa\u672c\u5b57\u8282\u4ea4\u6362 import endianness; uint32_t value = 0x12345678; uint32_t swapped = endianness::swapBytes(value); // \u5728\u5c0f\u7aef\u7cfb\u7edf\u4e0a swapped = 0x78563412 \u5b57\u8282\u5e8f\u6821\u6b63 import endianness; import value; Value val = uint32_t{0x12345678}; endianness::fixEndianness(val, true); // \u53cd\u8f6c\u5b57\u8282\u5e8f \u7f51\u7edc\u901a\u4fe1 uint16_t port = 8080; uint16_t networkPort = endianness::hostToNetwork(port); \u6982\u5ff5\u548c\u7ea6\u675f SwappableIntegral \u6982\u5ff5 template<typename T> concept SwappableIntegral = std::integral<T> && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8); \u5c06\u5b57\u8282\u4ea4\u6362\u64cd\u4f5c\u9650\u5236\u4e3a\u7279\u5b9a\u5927\u5c0f\u7684\u6574\u6570\u7c7b\u578b\u3002 \u5b9e\u73b0\u7ec6\u8282 \u5b57\u8282\u4ea4\u6362\u7b97\u6cd5 16\u4f4d \uff1a\u4f7f\u7528\u4f4d\u65cb\u8f6c\uff1a (value << 8) | (value >> 8) 32\u4f4d \uff1a\u4f7f\u7528\u4f4d\u63a9\u7801\u548c\u79fb\u4f4d\u4ee5\u83b7\u5f97\u6700\u4f73\u6027\u80fd 64\u4f4d \uff1a\u8de88\u5b57\u8282\u4f7f\u7528\u4f4d\u63a9\u7801\u548c\u79fb\u4f4d \u7f16\u8bd1\u65f6\u4f18\u5316 \u6240\u6709\u5b57\u8282\u4ea4\u6362\u64cd\u4f5c\u90fd\u6807\u8bb0\u4e3a constexpr \uff0c\u4ee5\u4fbf\u5728\u53ef\u80fd\u7684\u60c5\u51b5\u4e0b\u8fdb\u884c\u7f16\u8bd1\u65f6\u6c42\u503c\u3002 \u7c7b\u578b\u5b89\u5168 \u4f7f\u7528C++20\u6982\u5ff5\u786e\u4fdd\u7c7b\u578b\u5b89\u5168\uff0c\u5e76\u4e3a\u4e0d\u652f\u6301\u7684\u7c7b\u578b\u63d0\u4f9b\u6e05\u6670\u7684\u9519\u8bef\u6d88\u606f\u3002 \u9519\u8bef\u5904\u7406 swapBytesIntegral \u4f7f\u7528 static_assert \u8fdb\u884c\u7f16\u8bd1\u65f6\u7c7b\u578b\u68c0\u67e5 swapBytesInPlace \u9759\u9ed8\u5ffd\u7565\u4e0d\u652f\u6301\u7684\u5c3a\u5bf8 fixEndianness \u6309 flags \u63a8\u65ad\u5bbd\u5ea6\uff08B16/B32/B64\uff09\u5bf9 Value.bytes \u539f\u5730\u4ea4\u6362 \u6027\u80fd\u8003\u8651 \u6240\u6709\u64cd\u4f5c\u90fd\u662f constexpr \u7528\u4e8e\u7f16\u8bd1\u65f6\u4f18\u5316 \u5b57\u8282\u4ea4\u6362\u4f7f\u7528\u9ad8\u6548\u7684\u4f4d\u64cd\u4f5c \u65e0\u52a8\u6001\u5185\u5b58\u5206\u914d \u5bf9\u652f\u6301\u7c7b\u578b\u7684\u6700\u5c0f\u8fd0\u884c\u65f6\u5f00\u9500 \u53c2\u89c1 \u503c\u7c7b\u578b\u6a21\u5757 - \u503c\u7c7b\u578b\u5b9a\u4e49 \u76ee\u6807\u5185\u5b58\u6a21\u5757 - \u5185\u5b58\u5206\u6790\u64cd\u4f5c \u4e0e CLI \u7684\u96c6\u6210 endianness \u6a21\u5757\u5728 CLI \u4e2d\u7528\u4e8e\u5185\u5b58\u626b\u63cf\u64cd\u4f5c\u671f\u95f4\u7684\u81ea\u52a8\u5b57\u8282\u5e8f\u5904\u7406\u3002\u4f8b\u5982\uff0c scan \u547d\u4ee4\u5229\u7528\u6b64\u6a21\u5757\u786e\u4fdd\u76ee\u6807\u503c\u7684\u5b57\u8282\u5e8f\u6b63\u786e\u3002","title":"\u5927\u7aef\u5c0f\u7aef"},{"location":"endianness/#_1","text":"","title":"\u5b57\u8282\u5e8f\u6a21\u5757\u6587\u6863"},{"location":"endianness/#_2","text":"endianness \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5168\u9762\u7684\u5b57\u8282\u5e8f\u5904\u7406\u5de5\u5177\u3002\u5b83\u652f\u6301\u7f16\u8bd1\u65f6\u548c\u8fd0\u884c\u65f6\u5b57\u8282\u5e8f\u68c0\u6d4b\u3001\u5b57\u8282\u4ea4\u6362\u64cd\u4f5c\uff0c\u4ee5\u53ca\u5404\u79cd\u6570\u636e\u7c7b\u578b\u7684\u81ea\u52a8\u5b57\u8282\u5e8f\u6821\u6b63\u3002","title":"\u6982\u8ff0"},{"location":"endianness/#_3","text":"export module endianness;","title":"\u6a21\u5757\u7ed3\u6784"},{"location":"endianness/#_4","text":"<cstdint> - \u5b9a\u5bbd\u6574\u6570\u7c7b\u578b <cstring> - C\u5b57\u7b26\u4e32\u64cd\u4f5c <bit> - \u4f4d\u64cd\u4f5c\u548c\u5b57\u8282\u5e8f\u68c0\u6d4b <type_traits> - \u6a21\u677f\u5143\u7f16\u7a0b\u7684\u7c7b\u578b\u7279\u5f81 <concepts> - C++20\u6982\u5ff5 value \u6a21\u5757 - \u503c\u7c7b\u578b\u5b9a\u4e49","title":"\u4f9d\u8d56\u9879"},{"location":"endianness/#_5","text":"","title":"\u6838\u5fc3\u529f\u80fd"},{"location":"endianness/#1","text":"","title":"1. \u5b57\u8282\u5e8f\u68c0\u6d4b"},{"location":"endianness/#_6","text":"constexpr bool isBigEndian() noexcept; constexpr bool isLittleEndian() noexcept; \u4f7f\u7528 std::endian::native \u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\u4e3b\u673a\u5b57\u8282\u5e8f\u3002","title":"\u7f16\u8bd1\u65f6\u68c0\u6d4b"},{"location":"endianness/#2","text":"","title":"2. \u5b57\u8282\u4ea4\u6362\u51fd\u6570"},{"location":"endianness/#_7","text":"constexpr uint8_t swapBytes(uint8_t value) noexcept; constexpr uint16_t swapBytes(uint16_t value) noexcept; constexpr uint32_t swapBytes(uint32_t value) noexcept; constexpr uint64_t swapBytes(uint64_t value) noexcept;","title":"\u57fa\u672c\u5b57\u8282\u4ea4\u6362\u51fd\u6570"},{"location":"endianness/#_8","text":"template<typename T> constexpr T swapBytesIntegral(T value) noexcept; \u652f\u6301\u5927\u5c0f\u4e3a1\u30012\u30014\u548c8\u5b57\u8282\u7684\u6574\u6570\u7c7b\u578b\u3002","title":"\u901a\u7528\u5b57\u8282\u4ea4\u6362\u51fd\u6570"},{"location":"endianness/#3","text":"void fixEndianness(Value& value, bool reverseEndianness) noexcept; \u5bf9 Value \u7684 bytes \u8fdb\u884c\u5c31\u5730\u5b57\u8282\u5e8f\u6821\u6b63\uff08\u6839\u636e flags \u63a8\u65ad\u5bbd\u5ea6 2/4/8\uff09\u3002","title":"3. \u503c\u7c7b\u578b\u5b57\u8282\u5e8f\u6821\u6b63\u51fd\u6570"},{"location":"endianness/#4","text":"template<SwappableIntegral T> constexpr T hostToNetwork(T value) noexcept; template<SwappableIntegral T> constexpr T networkToHost(T value) noexcept; \u5728\u4e3b\u673a\u548c\u7f51\u7edc\u5b57\u8282\u5e8f\uff08\u5927\u7aef\uff09\u4e4b\u95f4\u8f6c\u6362\u3002","title":"4. \u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u6362\u51fd\u6570"},{"location":"endianness/#5","text":"template<SwappableIntegral T> constexpr T hostToLittleEndian(T value) noexcept; template<SwappableIntegral T> constexpr T littleEndianToHost(T value) noexcept;","title":"5. \u5c0f\u7aef\u8f6c\u6362\u51fd\u6570"},{"location":"endianness/#_9","text":"","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"endianness/#_10","text":"import endianness; uint32_t value = 0x12345678; uint32_t swapped = endianness::swapBytes(value); // \u5728\u5c0f\u7aef\u7cfb\u7edf\u4e0a swapped = 0x78563412","title":"\u57fa\u672c\u5b57\u8282\u4ea4\u6362"},{"location":"endianness/#_11","text":"import endianness; import value; Value val = uint32_t{0x12345678}; endianness::fixEndianness(val, true); // \u53cd\u8f6c\u5b57\u8282\u5e8f","title":"\u5b57\u8282\u5e8f\u6821\u6b63"},{"location":"endianness/#_12","text":"uint16_t port = 8080; uint16_t networkPort = endianness::hostToNetwork(port);","title":"\u7f51\u7edc\u901a\u4fe1"},{"location":"endianness/#_13","text":"","title":"\u6982\u5ff5\u548c\u7ea6\u675f"},{"location":"endianness/#swappableintegral","text":"template<typename T> concept SwappableIntegral = std::integral<T> && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8); \u5c06\u5b57\u8282\u4ea4\u6362\u64cd\u4f5c\u9650\u5236\u4e3a\u7279\u5b9a\u5927\u5c0f\u7684\u6574\u6570\u7c7b\u578b\u3002","title":"SwappableIntegral \u6982\u5ff5"},{"location":"endianness/#_14","text":"","title":"\u5b9e\u73b0\u7ec6\u8282"},{"location":"endianness/#_15","text":"16\u4f4d \uff1a\u4f7f\u7528\u4f4d\u65cb\u8f6c\uff1a (value << 8) | (value >> 8) 32\u4f4d \uff1a\u4f7f\u7528\u4f4d\u63a9\u7801\u548c\u79fb\u4f4d\u4ee5\u83b7\u5f97\u6700\u4f73\u6027\u80fd 64\u4f4d \uff1a\u8de88\u5b57\u8282\u4f7f\u7528\u4f4d\u63a9\u7801\u548c\u79fb\u4f4d","title":"\u5b57\u8282\u4ea4\u6362\u7b97\u6cd5"},{"location":"endianness/#_16","text":"\u6240\u6709\u5b57\u8282\u4ea4\u6362\u64cd\u4f5c\u90fd\u6807\u8bb0\u4e3a constexpr \uff0c\u4ee5\u4fbf\u5728\u53ef\u80fd\u7684\u60c5\u51b5\u4e0b\u8fdb\u884c\u7f16\u8bd1\u65f6\u6c42\u503c\u3002","title":"\u7f16\u8bd1\u65f6\u4f18\u5316"},{"location":"endianness/#_17","text":"\u4f7f\u7528C++20\u6982\u5ff5\u786e\u4fdd\u7c7b\u578b\u5b89\u5168\uff0c\u5e76\u4e3a\u4e0d\u652f\u6301\u7684\u7c7b\u578b\u63d0\u4f9b\u6e05\u6670\u7684\u9519\u8bef\u6d88\u606f\u3002","title":"\u7c7b\u578b\u5b89\u5168"},{"location":"endianness/#_18","text":"swapBytesIntegral \u4f7f\u7528 static_assert \u8fdb\u884c\u7f16\u8bd1\u65f6\u7c7b\u578b\u68c0\u67e5 swapBytesInPlace \u9759\u9ed8\u5ffd\u7565\u4e0d\u652f\u6301\u7684\u5c3a\u5bf8 fixEndianness \u6309 flags \u63a8\u65ad\u5bbd\u5ea6\uff08B16/B32/B64\uff09\u5bf9 Value.bytes \u539f\u5730\u4ea4\u6362","title":"\u9519\u8bef\u5904\u7406"},{"location":"endianness/#_19","text":"\u6240\u6709\u64cd\u4f5c\u90fd\u662f constexpr \u7528\u4e8e\u7f16\u8bd1\u65f6\u4f18\u5316 \u5b57\u8282\u4ea4\u6362\u4f7f\u7528\u9ad8\u6548\u7684\u4f4d\u64cd\u4f5c \u65e0\u52a8\u6001\u5185\u5b58\u5206\u914d \u5bf9\u652f\u6301\u7c7b\u578b\u7684\u6700\u5c0f\u8fd0\u884c\u65f6\u5f00\u9500","title":"\u6027\u80fd\u8003\u8651"},{"location":"endianness/#_20","text":"\u503c\u7c7b\u578b\u6a21\u5757 - \u503c\u7c7b\u578b\u5b9a\u4e49 \u76ee\u6807\u5185\u5b58\u6a21\u5757 - \u5185\u5b58\u5206\u6790\u64cd\u4f5c","title":"\u53c2\u89c1"},{"location":"endianness/#cli","text":"endianness \u6a21\u5757\u5728 CLI \u4e2d\u7528\u4e8e\u5185\u5b58\u626b\u63cf\u64cd\u4f5c\u671f\u95f4\u7684\u81ea\u52a8\u5b57\u8282\u5e8f\u5904\u7406\u3002\u4f8b\u5982\uff0c scan \u547d\u4ee4\u5229\u7528\u6b64\u6a21\u5757\u786e\u4fdd\u76ee\u6807\u503c\u7684\u5b57\u8282\u5e8f\u6b63\u786e\u3002","title":"\u4e0e CLI \u7684\u96c6\u6210"},{"location":"main/","text":"\u4e3b\u5e94\u7528\u6587\u6863 \u6982\u8ff0 main.cpp \u6587\u4ef6\u4f5c\u4e3a NewScanmem \u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\u5b83\u6f14\u793a\u4e86\u57fa\u672c\u7684\u6a21\u5757\u96c6\u6210\uff0c\u5e76\u4e3a\u5185\u5b58\u626b\u63cf\u5de5\u5177\u63d0\u4f9b\u4e86\u57fa\u7840\u6846\u67b6\u3002 \u6587\u4ef6\u7ed3\u6784 import sets; int main() { Set val; return 0; } \u5f53\u524d\u5b9e\u73b0 \u5f53\u524d\u7684\u4e3b\u51fd\u6570\u662f\u6700\u5c0f\u5316\u7684\uff0c\u4f5c\u4e3a\u4ee5\u4e0b\u529f\u80fd\u7684\u5360\u4f4d\u7b26\uff1a \u6a21\u5757\u96c6\u6210\u6d4b\u8bd5 : \u6f14\u793a sets \u6a21\u5757\u53ef\u4ee5\u6210\u529f\u5bfc\u5165\u548c\u4f7f\u7528 \u57fa\u672c\u6846\u67b6 : \u4e3a\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u63d0\u4f9b\u8d77\u70b9 \u7f16\u8bd1\u9a8c\u8bc1 : \u786e\u4fdd\u6240\u6709\u6a21\u5757\u80fd\u591f\u6b63\u786e\u7f16\u8bd1\u5728\u4e00\u8d77 \u8ba1\u5212\u529f\u80fd \u547d\u4ee4\u884c\u754c\u9762 // \u672a\u6765\u5b9e\u73b0 int main(int argc, char* argv[]) { // \u89e3\u6790\u547d\u4ee4\u884c\u53c2\u6570 // \u521d\u59cb\u5316\u6a21\u5757 // \u5f00\u59cb\u5185\u5b58\u626b\u63cf // \u663e\u793a\u7ed3\u679c } \u96c6\u6210\u70b9 \u4e3b\u5e94\u7528\u7a0b\u5e8f\u5c06\u96c6\u6210\u6240\u6709\u6a21\u5757\uff1a \u8fdb\u7a0b\u7ba1\u7406 (process_checker) \u76ee\u6807\u8fdb\u7a0b\u9009\u62e9 \u8fdb\u7a0b\u72b6\u6001\u76d1\u63a7 \u6743\u9650\u68c0\u67e5 \u5185\u5b58\u5206\u6790 (targetmem) \u5185\u5b58\u533a\u57df\u626b\u63cf \u503c\u5339\u914d \u6a21\u5f0f\u68c0\u6d4b \u6570\u636e\u7c7b\u578b (value) \u591a\u7c7b\u578b\u503c\u652f\u6301 \u5b57\u8282\u5e8f\u5904\u7406 \u5b57\u8282\u6570\u7ec4\u64cd\u4f5c \u5b9e\u7528\u5de5\u5177 (sets, endianness, show_message) \u7ed3\u679c\u96c6\u5408\u64cd\u4f5c \u5b57\u8282\u5e8f\u8f6c\u6362 \u7528\u6237\u6d88\u606f\u548c\u65e5\u5fd7 \u4f7f\u7528\u793a\u4f8b \u57fa\u672c\u6267\u884c # \u5f53\u524d\u7528\u6cd5 ./newscanmem # \u672a\u6765\u7528\u6cd5\u793a\u4f8b ./newscanmem --pid 1234 --type int32 --value 42 ./newscanmem --pid 1234 --range 0x1000-0x2000 --string \"hello\" ./newscanmem --pid 1234 --float --tolerance 0.001 \u5f00\u53d1\u8def\u7ebf\u56fe \u7b2c\u4e00\u9636\u6bb5\uff1a\u57fa\u672c\u6846\u67b6 [ ] \u547d\u4ee4\u884c\u53c2\u6570\u89e3\u6790 [ ] \u8fdb\u7a0b\u9009\u62e9\u548c\u9a8c\u8bc1 [ ] \u57fa\u672c\u5185\u5b58\u626b\u63cf [ ] \u7ed3\u679c\u663e\u793a \u7b2c\u4e8c\u9636\u6bb5\uff1a\u9ad8\u7ea7\u529f\u80fd [ ] \u591a\u503c\u7c7b\u578b\u652f\u6301 [ ] \u5185\u5b58\u533a\u57df\u8fc7\u6ee4 [ ] \u6a21\u5f0f\u5339\u914d [ ] \u4ea4\u4e92\u6a21\u5f0f \u7b2c\u4e09\u9636\u6bb5\uff1a\u4f18\u5316 [ ] \u6027\u80fd\u8c03\u4f18 [ ] \u5185\u5b58\u4f7f\u7528\u4f18\u5316 [ ] \u5e76\u884c\u5904\u7406 [ ] \u7ed3\u679c\u7f13\u5b58 \u7b2c\u56db\u9636\u6bb5\uff1a\u7528\u6237\u754c\u9762/\u7528\u6237\u4f53\u9a8c [ ] \u8fdb\u5ea6\u6307\u793a\u5668 [ ] \u5f69\u8272\u8f93\u51fa [ ] \u4ea4\u4e92\u5f0f\u754c\u9762 [ ] \u914d\u7f6e\u6587\u4ef6\u652f\u6301 \u6a21\u5757\u96c6\u6210 \u8fdb\u7a0b\u68c0\u67e5\u5668\u96c6\u6210 import process_checker; // \u68c0\u67e5\u76ee\u6807\u8fdb\u7a0b\u72b6\u6001 pid_t targetPid = 1234; ProcessState state = ProcessChecker::check_process(targetPid); if (state == ProcessState::RUNNING) { std::cout << \"\u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\" << std::endl; } else { std::cout << \"\u8fdb\u7a0b\u672a\u8fd0\u884c\u6216\u65e0\u6cd5\u8bbf\u95ee\" << std::endl; return 1; } \u5185\u5b58\u626b\u63cf\u96c6\u6210 import targetmem; // \u521b\u5efa\u5185\u5b58\u5339\u914d\u6570\u7ec4 MatchesAndOldValuesArray matches; // \u6267\u884c\u5185\u5b58\u626b\u63cf // ... \u626b\u63cf\u903b\u8f91 ... // \u663e\u793a\u7ed3\u679c for (const auto& swath : matches.swaths) { std::cout << \"\u627e\u5230\u5339\u914d\u7684\u5185\u5b58\u533a\u57df\" << std::endl; } \u503c\u7c7b\u578b\u5904\u7406 import value; // \u521b\u5efa\u641c\u7d22\u503c Value searchValue; searchValue.setScalarTyped<int32_t>(42); searchValue.flags = MatchFlags::S32B; // \u6267\u884c\u503c\u5339\u914d // ... \u5339\u914d\u903b\u8f91 ... \u6d88\u606f\u7cfb\u7edf\u96c6\u6210 import show_message; // \u521b\u5efa\u6d88\u606f\u6253\u5370\u673a MessageContext ctx; ctx.debugMode = true; MessagePrinter printer(ctx); printer.info(\"\u5f00\u59cb\u5185\u5b58\u626b\u63cf\"); printer.debug(\"\u8c03\u8bd5\u4fe1\u606f: \u626b\u63cf\u53c2\u6570\"); printer.warn(\"\u8b66\u544a: \u5185\u5b58\u4f7f\u7528\u7387\u8f83\u9ad8\"); \u547d\u4ee4\u884c\u53c2\u6570\u8bbe\u8ba1 \u57fa\u672c\u53c2\u6570 struct CommandLineArgs { pid_t targetPid = 0; // \u76ee\u6807\u8fdb\u7a0b ID std::string valueType = \"int32\"; // \u503c\u7c7b\u578b std::string searchValue; // \u641c\u7d22\u503c std::string memoryRange; // \u5185\u5b58\u8303\u56f4 bool debugMode = false; // \u8c03\u8bd5\u6a21\u5f0f bool verbose = false; // \u8be6\u7ec6\u8f93\u51fa }; \u53c2\u6570\u89e3\u6790 // \u89e3\u6790\u547d\u4ee4\u884c\u53c2\u6570 CommandLineArgs parseArgs(int argc, char* argv[]) { CommandLineArgs args; for (int i = 1; i < argc; ++i) { std::string arg = argv[i]; if (arg == \"--pid\" && i + 1 < argc) { args.targetPid = std::stoi(argv[++i]); } else if (arg == \"--type\" && i + 1 < argc) { args.valueType = argv[++i]; } else if (arg == \"--value\" && i + 1 < argc) { args.searchValue = argv[++i]; } else if (arg == \"--range\" && i + 1 < argc) { args.memoryRange = argv[++i]; } else if (arg == \"--debug\") { args.debugMode = true; } else if (arg == \"--verbose\") { args.verbose = true; } } return args; } \u9519\u8bef\u5904\u7406 \u53c2\u6570\u9a8c\u8bc1 bool validateArgs(const CommandLineArgs& args) { if (args.targetPid <= 0) { std::cerr << \"\u9519\u8bef: \u65e0\u6548\u7684\u8fdb\u7a0b ID\" << std::endl; return false; } if (args.searchValue.empty()) { std::cerr << \"\u9519\u8bef: \u672a\u6307\u5b9a\u641c\u7d22\u503c\" << std::endl; return false; } return true; } \u8fdb\u7a0b\u9a8c\u8bc1 bool validateProcess(pid_t pid) { ProcessState state = ProcessChecker::check_process(pid); if (state == ProcessState::DEAD) { std::cerr << \"\u9519\u8bef: \u8fdb\u7a0b\u4e0d\u5b58\u5728\" << std::endl; return false; } if (state == ProcessState::ERROR) { std::cerr << \"\u9519\u8bef: \u65e0\u6cd5\u8bbf\u95ee\u8fdb\u7a0b\" << std::endl; return false; } return true; } \u6027\u80fd\u8003\u8651 \u5185\u5b58\u4f7f\u7528 \u6d41\u5f0f\u5904\u7406 : \u907f\u514d\u4e00\u6b21\u6027\u52a0\u8f7d\u5927\u91cf\u6570\u636e \u5185\u5b58\u6620\u5c04 : \u4f7f\u7528\u5185\u5b58\u6620\u5c04\u6587\u4ef6\u5904\u7406\u5927\u6587\u4ef6 \u7f13\u5b58\u7b56\u7565 : \u5b9e\u73b0\u667a\u80fd\u7f13\u5b58\u51cf\u5c11\u91cd\u590d\u8ba1\u7b97 \u5e76\u884c\u5904\u7406 // \u5e76\u884c\u626b\u63cf\u591a\u4e2a\u5185\u5b58\u533a\u57df void parallelScan(const std::vector<MemoryRegion>& regions) { std::vector<std::thread> threads; for (const auto& region : regions) { threads.emplace_back([region]() { scanRegion(region); }); } for (auto& thread : threads) { thread.join(); } } \u8fdb\u5ea6\u62a5\u544a class ProgressReporter { private: size_t m_total; size_t m_current; std::chrono::steady_clock::time_point m_start; public: ProgressReporter(size_t total) : m_total(total), m_current(0) { m_start = std::chrono::steady_clock::now(); } void update(size_t increment = 1) { m_current += increment; auto now = std::chrono::steady_clock::now(); auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - m_start); float progress = static_cast<float>(m_current) / m_total * 100.0f; std::cout << \"\\r\u8fdb\u5ea6: \" << std::fixed << std::setprecision(1) << progress << \"% (\" << m_current << \"/\" << m_total << \")\" << std::flush; } }; \u914d\u7f6e\u7ba1\u7406 \u914d\u7f6e\u6587\u4ef6\u652f\u6301 struct Config { bool debugMode = false; bool verbose = false; size_t maxResults = 1000; std::string logFile; std::map<std::string, std::string> customSettings; }; Config loadConfig(const std::string& configFile) { Config config; // \u4ece\u6587\u4ef6\u52a0\u8f7d\u914d\u7f6e return config; } \u73af\u5883\u53d8\u91cf void loadEnvironmentConfig() { if (const char* debug = std::getenv(\"NEWSCANMEM_DEBUG\")) { if (std::string(debug) == \"1\") { // \u542f\u7528\u8c03\u8bd5\u6a21\u5f0f } } } \u6d4b\u8bd5\u548c\u8c03\u8bd5 \u5355\u5143\u6d4b\u8bd5 // \u6d4b\u8bd5\u6a21\u5757\u96c6\u6210 void testModuleIntegration() { // \u6d4b\u8bd5 sets \u6a21\u5757 Set testSet; assert(testSet.size() == 0); // \u6d4b\u8bd5 value \u6a21\u5757 Value testValue; testValue.value = static_cast<int32_t>(42); assert(std::holds_alternative<int32_t>(testValue.value)); } \u8c03\u8bd5\u5de5\u5177 class DebugHelper { public: static void dumpMemory(const void* addr, size_t size) { const uint8_t* bytes = static_cast<const uint8_t*>(addr); for (size_t i = 0; i < size; ++i) { if (i % 16 == 0) { std::cout << std::endl << std::hex << std::setw(8) << std::setfill('0') << i << \": \"; } std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]) << \" \"; } std::cout << std::endl; } }; \u672a\u6765\u6269\u5c55 \u63d2\u4ef6\u7cfb\u7edf // \u63d2\u4ef6\u63a5\u53e3 class ScanPlugin { public: virtual bool initialize() = 0; virtual bool scan(const MemoryRegion& region) = 0; virtual void cleanup() = 0; virtual std::string getName() const = 0; }; // \u63d2\u4ef6\u7ba1\u7406\u5668 class PluginManager { private: std::vector<std::unique_ptr<ScanPlugin>> m_plugins; public: void registerPlugin(std::unique_ptr<ScanPlugin> plugin); void runPlugins(const MemoryRegion& region); }; \u7f51\u7edc\u652f\u6301 // \u8fdc\u7a0b\u626b\u63cf\u652f\u6301 class RemoteScanner { public: bool connect(const std::string& host, int port); bool scanRemoteProcess(pid_t pid); std::vector<MemoryMatch> getResults(); }; GUI \u754c\u9762 // \u56fe\u5f62\u7528\u6237\u754c\u9762\uff08\u672a\u6765\u8ba1\u5212\uff09 class MainWindow { public: void showProcessList(); void showScanResults(); void showMemoryMap(); }; CLI \u548c REPL \u96c6\u6210 \u4e3b\u5e94\u7528\u7a0b\u5e8f\u73b0\u5df2\u96c6\u6210\u547d\u4ee4\u884c\u754c\u9762 (CLI) \u548c REPL \u5faa\u73af\u3002\u8fd9\u5141\u8bb8\u7528\u6237\u4ea4\u4e92\u5f0f\u5730\u6267\u884c\u5185\u5b58\u626b\u63cf\u548c\u5206\u6790\u547d\u4ee4\u3002 main.cpp \u6587\u4ef6\u521d\u59cb\u5316 REPL \u5e76\u6ce8\u518c\u4e86 help \u3001 quit \u548c pid \u7b49\u547d\u4ee4\u3002","title":"\u4e3b\u7a0b\u5e8f"},{"location":"main/#_1","text":"","title":"\u4e3b\u5e94\u7528\u6587\u6863"},{"location":"main/#_2","text":"main.cpp \u6587\u4ef6\u4f5c\u4e3a NewScanmem \u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\u5b83\u6f14\u793a\u4e86\u57fa\u672c\u7684\u6a21\u5757\u96c6\u6210\uff0c\u5e76\u4e3a\u5185\u5b58\u626b\u63cf\u5de5\u5177\u63d0\u4f9b\u4e86\u57fa\u7840\u6846\u67b6\u3002","title":"\u6982\u8ff0"},{"location":"main/#_3","text":"import sets; int main() { Set val; return 0; }","title":"\u6587\u4ef6\u7ed3\u6784"},{"location":"main/#_4","text":"\u5f53\u524d\u7684\u4e3b\u51fd\u6570\u662f\u6700\u5c0f\u5316\u7684\uff0c\u4f5c\u4e3a\u4ee5\u4e0b\u529f\u80fd\u7684\u5360\u4f4d\u7b26\uff1a \u6a21\u5757\u96c6\u6210\u6d4b\u8bd5 : \u6f14\u793a sets \u6a21\u5757\u53ef\u4ee5\u6210\u529f\u5bfc\u5165\u548c\u4f7f\u7528 \u57fa\u672c\u6846\u67b6 : \u4e3a\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u63d0\u4f9b\u8d77\u70b9 \u7f16\u8bd1\u9a8c\u8bc1 : \u786e\u4fdd\u6240\u6709\u6a21\u5757\u80fd\u591f\u6b63\u786e\u7f16\u8bd1\u5728\u4e00\u8d77","title":"\u5f53\u524d\u5b9e\u73b0"},{"location":"main/#_5","text":"","title":"\u8ba1\u5212\u529f\u80fd"},{"location":"main/#_6","text":"// \u672a\u6765\u5b9e\u73b0 int main(int argc, char* argv[]) { // \u89e3\u6790\u547d\u4ee4\u884c\u53c2\u6570 // \u521d\u59cb\u5316\u6a21\u5757 // \u5f00\u59cb\u5185\u5b58\u626b\u63cf // \u663e\u793a\u7ed3\u679c }","title":"\u547d\u4ee4\u884c\u754c\u9762"},{"location":"main/#_7","text":"\u4e3b\u5e94\u7528\u7a0b\u5e8f\u5c06\u96c6\u6210\u6240\u6709\u6a21\u5757\uff1a \u8fdb\u7a0b\u7ba1\u7406 (process_checker) \u76ee\u6807\u8fdb\u7a0b\u9009\u62e9 \u8fdb\u7a0b\u72b6\u6001\u76d1\u63a7 \u6743\u9650\u68c0\u67e5 \u5185\u5b58\u5206\u6790 (targetmem) \u5185\u5b58\u533a\u57df\u626b\u63cf \u503c\u5339\u914d \u6a21\u5f0f\u68c0\u6d4b \u6570\u636e\u7c7b\u578b (value) \u591a\u7c7b\u578b\u503c\u652f\u6301 \u5b57\u8282\u5e8f\u5904\u7406 \u5b57\u8282\u6570\u7ec4\u64cd\u4f5c \u5b9e\u7528\u5de5\u5177 (sets, endianness, show_message) \u7ed3\u679c\u96c6\u5408\u64cd\u4f5c \u5b57\u8282\u5e8f\u8f6c\u6362 \u7528\u6237\u6d88\u606f\u548c\u65e5\u5fd7","title":"\u96c6\u6210\u70b9"},{"location":"main/#_8","text":"","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"main/#_9","text":"# \u5f53\u524d\u7528\u6cd5 ./newscanmem # \u672a\u6765\u7528\u6cd5\u793a\u4f8b ./newscanmem --pid 1234 --type int32 --value 42 ./newscanmem --pid 1234 --range 0x1000-0x2000 --string \"hello\" ./newscanmem --pid 1234 --float --tolerance 0.001","title":"\u57fa\u672c\u6267\u884c"},{"location":"main/#_10","text":"","title":"\u5f00\u53d1\u8def\u7ebf\u56fe"},{"location":"main/#_11","text":"[ ] \u547d\u4ee4\u884c\u53c2\u6570\u89e3\u6790 [ ] \u8fdb\u7a0b\u9009\u62e9\u548c\u9a8c\u8bc1 [ ] \u57fa\u672c\u5185\u5b58\u626b\u63cf [ ] \u7ed3\u679c\u663e\u793a","title":"\u7b2c\u4e00\u9636\u6bb5\uff1a\u57fa\u672c\u6846\u67b6"},{"location":"main/#_12","text":"[ ] \u591a\u503c\u7c7b\u578b\u652f\u6301 [ ] \u5185\u5b58\u533a\u57df\u8fc7\u6ee4 [ ] \u6a21\u5f0f\u5339\u914d [ ] \u4ea4\u4e92\u6a21\u5f0f","title":"\u7b2c\u4e8c\u9636\u6bb5\uff1a\u9ad8\u7ea7\u529f\u80fd"},{"location":"main/#_13","text":"[ ] \u6027\u80fd\u8c03\u4f18 [ ] \u5185\u5b58\u4f7f\u7528\u4f18\u5316 [ ] \u5e76\u884c\u5904\u7406 [ ] \u7ed3\u679c\u7f13\u5b58","title":"\u7b2c\u4e09\u9636\u6bb5\uff1a\u4f18\u5316"},{"location":"main/#_14","text":"[ ] \u8fdb\u5ea6\u6307\u793a\u5668 [ ] \u5f69\u8272\u8f93\u51fa [ ] \u4ea4\u4e92\u5f0f\u754c\u9762 [ ] \u914d\u7f6e\u6587\u4ef6\u652f\u6301","title":"\u7b2c\u56db\u9636\u6bb5\uff1a\u7528\u6237\u754c\u9762/\u7528\u6237\u4f53\u9a8c"},{"location":"main/#_15","text":"","title":"\u6a21\u5757\u96c6\u6210"},{"location":"main/#_16","text":"import process_checker; // \u68c0\u67e5\u76ee\u6807\u8fdb\u7a0b\u72b6\u6001 pid_t targetPid = 1234; ProcessState state = ProcessChecker::check_process(targetPid); if (state == ProcessState::RUNNING) { std::cout << \"\u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\" << std::endl; } else { std::cout << \"\u8fdb\u7a0b\u672a\u8fd0\u884c\u6216\u65e0\u6cd5\u8bbf\u95ee\" << std::endl; return 1; }","title":"\u8fdb\u7a0b\u68c0\u67e5\u5668\u96c6\u6210"},{"location":"main/#_17","text":"import targetmem; // \u521b\u5efa\u5185\u5b58\u5339\u914d\u6570\u7ec4 MatchesAndOldValuesArray matches; // \u6267\u884c\u5185\u5b58\u626b\u63cf // ... \u626b\u63cf\u903b\u8f91 ... // \u663e\u793a\u7ed3\u679c for (const auto& swath : matches.swaths) { std::cout << \"\u627e\u5230\u5339\u914d\u7684\u5185\u5b58\u533a\u57df\" << std::endl; }","title":"\u5185\u5b58\u626b\u63cf\u96c6\u6210"},{"location":"main/#_18","text":"import value; // \u521b\u5efa\u641c\u7d22\u503c Value searchValue; searchValue.setScalarTyped<int32_t>(42); searchValue.flags = MatchFlags::S32B; // \u6267\u884c\u503c\u5339\u914d // ... \u5339\u914d\u903b\u8f91 ...","title":"\u503c\u7c7b\u578b\u5904\u7406"},{"location":"main/#_19","text":"import show_message; // \u521b\u5efa\u6d88\u606f\u6253\u5370\u673a MessageContext ctx; ctx.debugMode = true; MessagePrinter printer(ctx); printer.info(\"\u5f00\u59cb\u5185\u5b58\u626b\u63cf\"); printer.debug(\"\u8c03\u8bd5\u4fe1\u606f: \u626b\u63cf\u53c2\u6570\"); printer.warn(\"\u8b66\u544a: \u5185\u5b58\u4f7f\u7528\u7387\u8f83\u9ad8\");","title":"\u6d88\u606f\u7cfb\u7edf\u96c6\u6210"},{"location":"main/#_20","text":"","title":"\u547d\u4ee4\u884c\u53c2\u6570\u8bbe\u8ba1"},{"location":"main/#_21","text":"struct CommandLineArgs { pid_t targetPid = 0; // \u76ee\u6807\u8fdb\u7a0b ID std::string valueType = \"int32\"; // \u503c\u7c7b\u578b std::string searchValue; // \u641c\u7d22\u503c std::string memoryRange; // \u5185\u5b58\u8303\u56f4 bool debugMode = false; // \u8c03\u8bd5\u6a21\u5f0f bool verbose = false; // \u8be6\u7ec6\u8f93\u51fa };","title":"\u57fa\u672c\u53c2\u6570"},{"location":"main/#_22","text":"// \u89e3\u6790\u547d\u4ee4\u884c\u53c2\u6570 CommandLineArgs parseArgs(int argc, char* argv[]) { CommandLineArgs args; for (int i = 1; i < argc; ++i) { std::string arg = argv[i]; if (arg == \"--pid\" && i + 1 < argc) { args.targetPid = std::stoi(argv[++i]); } else if (arg == \"--type\" && i + 1 < argc) { args.valueType = argv[++i]; } else if (arg == \"--value\" && i + 1 < argc) { args.searchValue = argv[++i]; } else if (arg == \"--range\" && i + 1 < argc) { args.memoryRange = argv[++i]; } else if (arg == \"--debug\") { args.debugMode = true; } else if (arg == \"--verbose\") { args.verbose = true; } } return args; }","title":"\u53c2\u6570\u89e3\u6790"},{"location":"main/#_23","text":"","title":"\u9519\u8bef\u5904\u7406"},{"location":"main/#_24","text":"bool validateArgs(const CommandLineArgs& args) { if (args.targetPid <= 0) { std::cerr << \"\u9519\u8bef: \u65e0\u6548\u7684\u8fdb\u7a0b ID\" << std::endl; return false; } if (args.searchValue.empty()) { std::cerr << \"\u9519\u8bef: \u672a\u6307\u5b9a\u641c\u7d22\u503c\" << std::endl; return false; } return true; }","title":"\u53c2\u6570\u9a8c\u8bc1"},{"location":"main/#_25","text":"bool validateProcess(pid_t pid) { ProcessState state = ProcessChecker::check_process(pid); if (state == ProcessState::DEAD) { std::cerr << \"\u9519\u8bef: \u8fdb\u7a0b\u4e0d\u5b58\u5728\" << std::endl; return false; } if (state == ProcessState::ERROR) { std::cerr << \"\u9519\u8bef: \u65e0\u6cd5\u8bbf\u95ee\u8fdb\u7a0b\" << std::endl; return false; } return true; }","title":"\u8fdb\u7a0b\u9a8c\u8bc1"},{"location":"main/#_26","text":"","title":"\u6027\u80fd\u8003\u8651"},{"location":"main/#_27","text":"\u6d41\u5f0f\u5904\u7406 : \u907f\u514d\u4e00\u6b21\u6027\u52a0\u8f7d\u5927\u91cf\u6570\u636e \u5185\u5b58\u6620\u5c04 : \u4f7f\u7528\u5185\u5b58\u6620\u5c04\u6587\u4ef6\u5904\u7406\u5927\u6587\u4ef6 \u7f13\u5b58\u7b56\u7565 : \u5b9e\u73b0\u667a\u80fd\u7f13\u5b58\u51cf\u5c11\u91cd\u590d\u8ba1\u7b97","title":"\u5185\u5b58\u4f7f\u7528"},{"location":"main/#_28","text":"// \u5e76\u884c\u626b\u63cf\u591a\u4e2a\u5185\u5b58\u533a\u57df void parallelScan(const std::vector<MemoryRegion>& regions) { std::vector<std::thread> threads; for (const auto& region : regions) { threads.emplace_back([region]() { scanRegion(region); }); } for (auto& thread : threads) { thread.join(); } }","title":"\u5e76\u884c\u5904\u7406"},{"location":"main/#_29","text":"class ProgressReporter { private: size_t m_total; size_t m_current; std::chrono::steady_clock::time_point m_start; public: ProgressReporter(size_t total) : m_total(total), m_current(0) { m_start = std::chrono::steady_clock::now(); } void update(size_t increment = 1) { m_current += increment; auto now = std::chrono::steady_clock::now(); auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - m_start); float progress = static_cast<float>(m_current) / m_total * 100.0f; std::cout << \"\\r\u8fdb\u5ea6: \" << std::fixed << std::setprecision(1) << progress << \"% (\" << m_current << \"/\" << m_total << \")\" << std::flush; } };","title":"\u8fdb\u5ea6\u62a5\u544a"},{"location":"main/#_30","text":"","title":"\u914d\u7f6e\u7ba1\u7406"},{"location":"main/#_31","text":"struct Config { bool debugMode = false; bool verbose = false; size_t maxResults = 1000; std::string logFile; std::map<std::string, std::string> customSettings; }; Config loadConfig(const std::string& configFile) { Config config; // \u4ece\u6587\u4ef6\u52a0\u8f7d\u914d\u7f6e return config; }","title":"\u914d\u7f6e\u6587\u4ef6\u652f\u6301"},{"location":"main/#_32","text":"void loadEnvironmentConfig() { if (const char* debug = std::getenv(\"NEWSCANMEM_DEBUG\")) { if (std::string(debug) == \"1\") { // \u542f\u7528\u8c03\u8bd5\u6a21\u5f0f } } }","title":"\u73af\u5883\u53d8\u91cf"},{"location":"main/#_33","text":"","title":"\u6d4b\u8bd5\u548c\u8c03\u8bd5"},{"location":"main/#_34","text":"// \u6d4b\u8bd5\u6a21\u5757\u96c6\u6210 void testModuleIntegration() { // \u6d4b\u8bd5 sets \u6a21\u5757 Set testSet; assert(testSet.size() == 0); // \u6d4b\u8bd5 value \u6a21\u5757 Value testValue; testValue.value = static_cast<int32_t>(42); assert(std::holds_alternative<int32_t>(testValue.value)); }","title":"\u5355\u5143\u6d4b\u8bd5"},{"location":"main/#_35","text":"class DebugHelper { public: static void dumpMemory(const void* addr, size_t size) { const uint8_t* bytes = static_cast<const uint8_t*>(addr); for (size_t i = 0; i < size; ++i) { if (i % 16 == 0) { std::cout << std::endl << std::hex << std::setw(8) << std::setfill('0') << i << \": \"; } std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]) << \" \"; } std::cout << std::endl; } };","title":"\u8c03\u8bd5\u5de5\u5177"},{"location":"main/#_36","text":"","title":"\u672a\u6765\u6269\u5c55"},{"location":"main/#_37","text":"// \u63d2\u4ef6\u63a5\u53e3 class ScanPlugin { public: virtual bool initialize() = 0; virtual bool scan(const MemoryRegion& region) = 0; virtual void cleanup() = 0; virtual std::string getName() const = 0; }; // \u63d2\u4ef6\u7ba1\u7406\u5668 class PluginManager { private: std::vector<std::unique_ptr<ScanPlugin>> m_plugins; public: void registerPlugin(std::unique_ptr<ScanPlugin> plugin); void runPlugins(const MemoryRegion& region); };","title":"\u63d2\u4ef6\u7cfb\u7edf"},{"location":"main/#_38","text":"// \u8fdc\u7a0b\u626b\u63cf\u652f\u6301 class RemoteScanner { public: bool connect(const std::string& host, int port); bool scanRemoteProcess(pid_t pid); std::vector<MemoryMatch> getResults(); };","title":"\u7f51\u7edc\u652f\u6301"},{"location":"main/#gui","text":"// \u56fe\u5f62\u7528\u6237\u754c\u9762\uff08\u672a\u6765\u8ba1\u5212\uff09 class MainWindow { public: void showProcessList(); void showScanResults(); void showMemoryMap(); };","title":"GUI \u754c\u9762"},{"location":"main/#cli-repl","text":"\u4e3b\u5e94\u7528\u7a0b\u5e8f\u73b0\u5df2\u96c6\u6210\u547d\u4ee4\u884c\u754c\u9762 (CLI) \u548c REPL \u5faa\u73af\u3002\u8fd9\u5141\u8bb8\u7528\u6237\u4ea4\u4e92\u5f0f\u5730\u6267\u884c\u5185\u5b58\u626b\u63cf\u548c\u5206\u6790\u547d\u4ee4\u3002 main.cpp \u6587\u4ef6\u521d\u59cb\u5316 REPL \u5e76\u6ce8\u518c\u4e86 help \u3001 quit \u548c pid \u7b49\u547d\u4ee4\u3002","title":"CLI \u548c REPL \u96c6\u6210"},{"location":"maps/","text":"Maps \u6a21\u5757\u6587\u6863 \u6982\u8ff0 Maps \u6a21\u5757\u63d0\u4f9b\u8bfb\u53d6\u548c\u89e3\u6790 Linux /proc/[pid]/maps \u6587\u4ef6\u7684\u529f\u80fd\uff0c\u7528\u4e8e\u63d0\u53d6\u8fdb\u7a0b\u5185\u5b58\u533a\u57df\u4fe1\u606f\u3002\u8fd9\u662f\u4e00\u4e2a\u73b0\u4ee3\u5316\u7684 C++20 \u5b9e\u73b0\uff0c\u7528\u7c7b\u578b\u5b89\u5168\u3001\u7b26\u5408 RAII \u7684\u63a5\u53e3\u66ff\u4ee3\u4e86\u4f20\u7edf\u7684 C \u4ee3\u7801\u3002 \u6a21\u5757\u7ed3\u6784 import maps; \u6838\u5fc3\u7ec4\u4ef6 1. \u533a\u57df\u7c7b\u578b region_type \u679a\u4e3e \u8868\u793a\u5185\u5b58\u533a\u57df\u7684\u5206\u7c7b\uff1a enum class RegionType : uint8_t { MISC, // \u6742\u9879\u5185\u5b58\u533a\u57df EXE, // \u53ef\u6267\u884c\u6587\u4ef6\u4e8c\u8fdb\u5236\u533a\u57df CODE, // \u4ee3\u7801\u6bb5\uff08\u5171\u4eab\u5e93\u7b49\uff09 HEAP, // \u5806\u5185\u5b58\u533a\u57df STACK // \u6808\u5185\u5b58\u533a\u57df }; constexpr std::array<std::string_view, 5> REGION_TYPE_NAMES = { \"misc\", \"exe\", \"code\", \"heap\", \"stack\" }; 2. \u626b\u63cf\u7ea7\u522b RegionScanLevel \u679a\u4e3e \u63a7\u5236\u5305\u542b\u54ea\u4e9b\u5185\u5b58\u533a\u57df\u7684\u626b\u63cf\uff1a enum class RegionScanLevel : uint8_t { ALL, // \u6240\u6709\u53ef\u8bfb\u533a\u57df ALL_RW, // \u6240\u6709\u53ef\u8bfb/\u53ef\u5199\u533a\u57df HEAP_STACK_EXECUTABLE, // \u5806\u3001\u6808\u548c\u53ef\u6267\u884c\u533a\u57df HEAP_STACK_EXECUTABLE_BSS // \u4e0a\u8ff0\u52a0\u4e0a BSS \u6bb5 }; 3. \u533a\u57df\u5143\u6570\u636e RegionFlags \u7ed3\u6784 \u5305\u542b\u5185\u5b58\u533a\u57df\u7684\u6743\u9650\u548c\u72b6\u6001\u6807\u5fd7\uff1a struct RegionFlags { bool read : 1; // \u8bfb\u6743\u9650 bool write : 1; // \u5199\u6743\u9650 bool exec : 1; // \u6267\u884c\u6743\u9650 bool shared : 1; // \u5171\u4eab\u6620\u5c04 bool private_ : 1; // \u79c1\u6709\u6620\u5c04 }; Region \u7ed3\u6784 \u5173\u4e8e\u5185\u5b58\u533a\u57df\u7684\u5b8c\u6574\u4fe1\u606f\uff1a struct Region { void* start; // \u8d77\u59cb\u5730\u5740 std::size_t size; // \u533a\u57df\u5927\u5c0f\uff08\u5b57\u8282\uff09 RegionType type; // \u533a\u57df\u5206\u7c7b RegionFlags flags; // \u6743\u9650\u6807\u5fd7 void* loadAddr; // ELF \u6587\u4ef6\u7684\u52a0\u8f7d\u5730\u5740 std::string filename; // \u5173\u8054\u6587\u4ef6\u8def\u5f84 std::size_t id; // \u552f\u4e00\u6807\u8bc6\u7b26 // \u8f85\u52a9\u65b9\u6cd5 [[nodiscard]] bool isReadable() const noexcept; [[nodiscard]] bool isWritable() const noexcept; [[nodiscard]] bool isExecutable() const noexcept; [[nodiscard]] bool isShared() const noexcept; [[nodiscard]] bool isPrivate() const noexcept; [[nodiscard]] std::pair<void*, std::size_t> asSpan() const noexcept; [[nodiscard]] bool contains(void* address) const noexcept; }; \u4f7f\u7528\u793a\u4f8b \u57fa\u672c\u7528\u6cd5 import maps; // \u8bfb\u53d6\u8fdb\u7a0b\u7684\u6240\u6709\u5185\u5b58\u533a\u57df auto result = maps::readProcessMaps(1234); if (result) { for (const auto& region : *result) { std::cout << std::format(\"\u533a\u57df: {}-{} ({})\\n\", region.start, static_cast<char*>(region.start) + region.size, REGION_TYPE_NAMES[static_cast<size_t>(region.type)]); } } \u8fc7\u6ee4\u626b\u63cf // \u53ea\u626b\u63cf\u5806\u548c\u6808\u533a\u57df auto regions = maps::readProcessMaps( pid, maps::RegionScanLevel::HEAP_STACK_EXECUTABLE ); if (regions) { for (const auto& region : *regions) { if (region.type == maps::region_type::heap) { std::cout << \"\u627e\u5230\u5806\u533a\u57df: \" << region.filename << \"\\n\"; } } } \u9519\u8bef\u5904\u7406 auto result = maps::read_process_maps(pid); if (!result) { std::cerr << \"\u9519\u8bef: \" << result.error().message << \"\\n\"; return; } \u7c7b\uff1a maps_reader \u9759\u6001\u65b9\u6cd5 read_process_maps \u4ece\u8fdb\u7a0b\u8bfb\u53d6\u5185\u5b58\u533a\u57df\uff1a [[nodiscard]] static std::expected<std::vector<region>, error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all); \u53c2\u6570\uff1a pid : \u76ee\u6807\u8fdb\u7a0b ID level : \u626b\u63cf\u7ea7\u522b\u8fc7\u6ee4\u5668\uff08\u9ed8\u8ba4\uff1a all \uff09 \u8fd4\u56de\u503c\uff1a std::expected \u5305\u542b\u533a\u57df\u5411\u91cf\u6216\u9519\u8bef\u4fe1\u606f \u9519\u8bef\u5904\u7406\uff1a \u8fd4\u56de std::error_code \u548c\u9002\u5f53\u7684\u9519\u8bef\u6d88\u606f \u5e38\u89c1\u9519\u8bef\uff1a\u6587\u4ef6\u672a\u627e\u5230\u3001\u6743\u9650\u88ab\u62d2\u7edd\u3001\u683c\u5f0f\u65e0\u6548 \u9519\u8bef\u5904\u7406\u6a21\u5757 maps_reader::error \u7ed3\u6784 struct error { std::string message; // \u4eba\u7c7b\u53ef\u8bfb\u7684\u9519\u8bef\u63cf\u8ff0 std::error_code code; // \u7cfb\u7edf\u9519\u8bef\u4ee3\u7801 }; \u5e38\u89c1\u9519\u8bef\u573a\u666f \u8fdb\u7a0b\u4e0d\u5b58\u5728 \uff1a no_such_file_or_directory \u6743\u9650\u88ab\u62d2\u7edd \uff1a permission_denied \u683c\u5f0f\u65e0\u6548 \uff1a invalid_argument \u9ad8\u7ea7\u529f\u80fd \u533a\u57df\u5206\u6790 // \u68c0\u67e5\u5730\u5740\u662f\u5426\u5728\u4efb\u610f\u533a\u57df\u5185 auto regions = maps::read_process_maps(pid); void* address = /* \u67d0\u4e2a\u5730\u5740 */; for (const auto& region : *regions) { if (region.contains(address)) { std::cout << \"\u5730\u5740\u5728: \" << region.filename << \"\u4e2d\u627e\u5230\\n\"; break; } } \u6743\u9650\u68c0\u67e5 // \u67e5\u627e\u53ef\u5199\u53ef\u6267\u884c\u533a\u57df\uff08\u6f5c\u5728\u7684 shellcode \u76ee\u6807\uff09 for (const auto& region : *regions) { if (region.isWritable() && region.isExecutable()) { std::cout << \"WX \u533a\u57df: \" << region.filename << \"\\n\"; } } \u6027\u80fd\u8bf4\u660e \u5185\u5b58\u9ad8\u6548 \uff1a\u5bf9\u5c0f\u6587\u4ef6\u540d\u4f7f\u7528\u5e26\u6709 SSO \u7684 std::string \u96f6\u62f7\u8d1d \uff1a\u76f4\u63a5\u4ece\u6620\u5c04\u884c\u63d0\u53d6\u5b57\u7b26\u4e32 \u63d0\u524d\u8fc7\u6ee4 \uff1a\u6839\u636e\u626b\u63cf\u7ea7\u522b\u5728\u89e3\u6790\u671f\u95f4\u8fc7\u6ee4\u533a\u57df RAII \uff1a\u901a\u8fc7 std::ifstream \u81ea\u52a8\u6e05\u7406\u8d44\u6e90 \u7ebf\u7a0b\u5b89\u5168 \u7ebf\u7a0b\u5b89\u5168 \uff1a\u6240\u6709\u65b9\u6cd5\u5bf9\u5e76\u53d1\u8bbf\u95ee\u90fd\u662f\u7ebf\u7a0b\u5b89\u5168\u7684 \u65e0\u5171\u4eab\u72b6\u6001 \uff1a\u6bcf\u6b21\u8c03\u7528\u521b\u5efa\u72ec\u7acb\u72b6\u6001 \u4e0d\u53ef\u53d8\u7ed3\u679c \uff1a\u8fd4\u56de\u7684\u5411\u91cf\u5305\u542b\u4e0d\u53ef\u53d8\u6570\u636e \u5e73\u53f0\u517c\u5bb9\u6027 \u4ec5 Linux \uff1a\u9700\u8981 /proc/[pid]/maps \u6587\u4ef6\u7cfb\u7edf \u9700\u8981 C++23 \uff1a\u4f7f\u7528 std::expected \u548c\u5176\u4ed6 C++23 \u7279\u6027 \u652f\u6301 64 \u4f4d \uff1a\u5904\u7406 32 \u4f4d\u548c 64 \u4f4d\u5730\u5740\u7a7a\u95f4 \u4ece\u4f20\u7edf C \u4ee3\u7801\u8fc1\u79fb \u4f20\u7edf C \u2192 \u73b0\u4ee3 C++ \u4f20\u7edf C \u73b0\u4ee3 C++ region_t* maps::region list_t std::vector<region> bool return std::expected char* \u6587\u4ef6\u540d std::string \u624b\u52a8\u5185\u5b58\u7ba1\u7406 RAII \u9519\u8bef\u4ee3\u7801 \u5f02\u5e38\u5b89\u5168\u7684\u9519\u8bef\u5904\u7406 \u793a\u4f8b \u5b8c\u6574\u5de5\u4f5c\u793a\u4f8b #include <iostream> import maps; int main() { pid_t target_pid = 1234; // \u66ff\u6362\u4e3a\u5b9e\u9645 PID auto regions = maps::readProcessMaps(target_pid); if (!regions) { std::cerr << \"\u8bfb\u53d6\u6620\u5c04\u5931\u8d25: \" << regions.error().message << \"\\n\"; return 1; } std::cout << \"\u627e\u5230 \" << regions->size() << \" \u4e2a\u5185\u5b58\u533a\u57df:\\n\"; for (const auto& region : *regions) { std::cout << std::format( \"0x{:x}-0x{:x} {} {} {}\\n\", reinterpret_cast<uintptr_t>(region.start), reinterpret_cast<uintptr_t>(region.start) + region.size, region.isReadable() ? 'r' : '-', region.isWritable() ? 'w' : '-', region.isExecutable() ? 'x' : '-', region.filename.empty() ? \"[\u533f\u540d]\" : region.filename ); } return 0; } \u4e0e CLI \u7684\u96c6\u6210 maps \u6a21\u5757\u5728 CLI \u4e2d\u7528\u4e8e\u68c0\u7d22\u548c\u663e\u793a\u76ee\u6807\u8fdb\u7a0b\u7684\u5185\u5b58\u533a\u57df\u4fe1\u606f\u3002\u4f8b\u5982\uff0c list \u547d\u4ee4\u5229\u7528\u6b64\u6a21\u5757\u89e3\u6790\u5e76\u8f93\u51fa /proc/[pid]/maps \u6570\u636e\u3002","title":"\u5185\u5b58\u6620\u5c04"},{"location":"maps/#maps","text":"","title":"Maps \u6a21\u5757\u6587\u6863"},{"location":"maps/#_1","text":"Maps \u6a21\u5757\u63d0\u4f9b\u8bfb\u53d6\u548c\u89e3\u6790 Linux /proc/[pid]/maps \u6587\u4ef6\u7684\u529f\u80fd\uff0c\u7528\u4e8e\u63d0\u53d6\u8fdb\u7a0b\u5185\u5b58\u533a\u57df\u4fe1\u606f\u3002\u8fd9\u662f\u4e00\u4e2a\u73b0\u4ee3\u5316\u7684 C++20 \u5b9e\u73b0\uff0c\u7528\u7c7b\u578b\u5b89\u5168\u3001\u7b26\u5408 RAII \u7684\u63a5\u53e3\u66ff\u4ee3\u4e86\u4f20\u7edf\u7684 C \u4ee3\u7801\u3002","title":"\u6982\u8ff0"},{"location":"maps/#_2","text":"import maps;","title":"\u6a21\u5757\u7ed3\u6784"},{"location":"maps/#_3","text":"","title":"\u6838\u5fc3\u7ec4\u4ef6"},{"location":"maps/#1","text":"","title":"1. \u533a\u57df\u7c7b\u578b"},{"location":"maps/#region_type","text":"\u8868\u793a\u5185\u5b58\u533a\u57df\u7684\u5206\u7c7b\uff1a enum class RegionType : uint8_t { MISC, // \u6742\u9879\u5185\u5b58\u533a\u57df EXE, // \u53ef\u6267\u884c\u6587\u4ef6\u4e8c\u8fdb\u5236\u533a\u57df CODE, // \u4ee3\u7801\u6bb5\uff08\u5171\u4eab\u5e93\u7b49\uff09 HEAP, // \u5806\u5185\u5b58\u533a\u57df STACK // \u6808\u5185\u5b58\u533a\u57df }; constexpr std::array<std::string_view, 5> REGION_TYPE_NAMES = { \"misc\", \"exe\", \"code\", \"heap\", \"stack\" };","title":"region_type \u679a\u4e3e"},{"location":"maps/#2","text":"","title":"2. \u626b\u63cf\u7ea7\u522b"},{"location":"maps/#regionscanlevel","text":"\u63a7\u5236\u5305\u542b\u54ea\u4e9b\u5185\u5b58\u533a\u57df\u7684\u626b\u63cf\uff1a enum class RegionScanLevel : uint8_t { ALL, // \u6240\u6709\u53ef\u8bfb\u533a\u57df ALL_RW, // \u6240\u6709\u53ef\u8bfb/\u53ef\u5199\u533a\u57df HEAP_STACK_EXECUTABLE, // \u5806\u3001\u6808\u548c\u53ef\u6267\u884c\u533a\u57df HEAP_STACK_EXECUTABLE_BSS // \u4e0a\u8ff0\u52a0\u4e0a BSS \u6bb5 };","title":"RegionScanLevel \u679a\u4e3e"},{"location":"maps/#3","text":"","title":"3. \u533a\u57df\u5143\u6570\u636e"},{"location":"maps/#regionflags","text":"\u5305\u542b\u5185\u5b58\u533a\u57df\u7684\u6743\u9650\u548c\u72b6\u6001\u6807\u5fd7\uff1a struct RegionFlags { bool read : 1; // \u8bfb\u6743\u9650 bool write : 1; // \u5199\u6743\u9650 bool exec : 1; // \u6267\u884c\u6743\u9650 bool shared : 1; // \u5171\u4eab\u6620\u5c04 bool private_ : 1; // \u79c1\u6709\u6620\u5c04 };","title":"RegionFlags \u7ed3\u6784"},{"location":"maps/#region","text":"\u5173\u4e8e\u5185\u5b58\u533a\u57df\u7684\u5b8c\u6574\u4fe1\u606f\uff1a struct Region { void* start; // \u8d77\u59cb\u5730\u5740 std::size_t size; // \u533a\u57df\u5927\u5c0f\uff08\u5b57\u8282\uff09 RegionType type; // \u533a\u57df\u5206\u7c7b RegionFlags flags; // \u6743\u9650\u6807\u5fd7 void* loadAddr; // ELF \u6587\u4ef6\u7684\u52a0\u8f7d\u5730\u5740 std::string filename; // \u5173\u8054\u6587\u4ef6\u8def\u5f84 std::size_t id; // \u552f\u4e00\u6807\u8bc6\u7b26 // \u8f85\u52a9\u65b9\u6cd5 [[nodiscard]] bool isReadable() const noexcept; [[nodiscard]] bool isWritable() const noexcept; [[nodiscard]] bool isExecutable() const noexcept; [[nodiscard]] bool isShared() const noexcept; [[nodiscard]] bool isPrivate() const noexcept; [[nodiscard]] std::pair<void*, std::size_t> asSpan() const noexcept; [[nodiscard]] bool contains(void* address) const noexcept; };","title":"Region \u7ed3\u6784"},{"location":"maps/#_4","text":"","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"maps/#_5","text":"import maps; // \u8bfb\u53d6\u8fdb\u7a0b\u7684\u6240\u6709\u5185\u5b58\u533a\u57df auto result = maps::readProcessMaps(1234); if (result) { for (const auto& region : *result) { std::cout << std::format(\"\u533a\u57df: {}-{} ({})\\n\", region.start, static_cast<char*>(region.start) + region.size, REGION_TYPE_NAMES[static_cast<size_t>(region.type)]); } }","title":"\u57fa\u672c\u7528\u6cd5"},{"location":"maps/#_6","text":"// \u53ea\u626b\u63cf\u5806\u548c\u6808\u533a\u57df auto regions = maps::readProcessMaps( pid, maps::RegionScanLevel::HEAP_STACK_EXECUTABLE ); if (regions) { for (const auto& region : *regions) { if (region.type == maps::region_type::heap) { std::cout << \"\u627e\u5230\u5806\u533a\u57df: \" << region.filename << \"\\n\"; } } }","title":"\u8fc7\u6ee4\u626b\u63cf"},{"location":"maps/#_7","text":"auto result = maps::read_process_maps(pid); if (!result) { std::cerr << \"\u9519\u8bef: \" << result.error().message << \"\\n\"; return; }","title":"\u9519\u8bef\u5904\u7406"},{"location":"maps/#maps_reader","text":"","title":"\u7c7b\uff1amaps_reader"},{"location":"maps/#_8","text":"","title":"\u9759\u6001\u65b9\u6cd5"},{"location":"maps/#read_process_maps","text":"\u4ece\u8fdb\u7a0b\u8bfb\u53d6\u5185\u5b58\u533a\u57df\uff1a [[nodiscard]] static std::expected<std::vector<region>, error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all); \u53c2\u6570\uff1a pid : \u76ee\u6807\u8fdb\u7a0b ID level : \u626b\u63cf\u7ea7\u522b\u8fc7\u6ee4\u5668\uff08\u9ed8\u8ba4\uff1a all \uff09 \u8fd4\u56de\u503c\uff1a std::expected \u5305\u542b\u533a\u57df\u5411\u91cf\u6216\u9519\u8bef\u4fe1\u606f \u9519\u8bef\u5904\u7406\uff1a \u8fd4\u56de std::error_code \u548c\u9002\u5f53\u7684\u9519\u8bef\u6d88\u606f \u5e38\u89c1\u9519\u8bef\uff1a\u6587\u4ef6\u672a\u627e\u5230\u3001\u6743\u9650\u88ab\u62d2\u7edd\u3001\u683c\u5f0f\u65e0\u6548","title":"read_process_maps"},{"location":"maps/#_9","text":"","title":"\u9519\u8bef\u5904\u7406\u6a21\u5757"},{"location":"maps/#maps_readererror","text":"struct error { std::string message; // \u4eba\u7c7b\u53ef\u8bfb\u7684\u9519\u8bef\u63cf\u8ff0 std::error_code code; // \u7cfb\u7edf\u9519\u8bef\u4ee3\u7801 };","title":"maps_reader::error \u7ed3\u6784"},{"location":"maps/#_10","text":"\u8fdb\u7a0b\u4e0d\u5b58\u5728 \uff1a no_such_file_or_directory \u6743\u9650\u88ab\u62d2\u7edd \uff1a permission_denied \u683c\u5f0f\u65e0\u6548 \uff1a invalid_argument","title":"\u5e38\u89c1\u9519\u8bef\u573a\u666f"},{"location":"maps/#_11","text":"","title":"\u9ad8\u7ea7\u529f\u80fd"},{"location":"maps/#_12","text":"// \u68c0\u67e5\u5730\u5740\u662f\u5426\u5728\u4efb\u610f\u533a\u57df\u5185 auto regions = maps::read_process_maps(pid); void* address = /* \u67d0\u4e2a\u5730\u5740 */; for (const auto& region : *regions) { if (region.contains(address)) { std::cout << \"\u5730\u5740\u5728: \" << region.filename << \"\u4e2d\u627e\u5230\\n\"; break; } }","title":"\u533a\u57df\u5206\u6790"},{"location":"maps/#_13","text":"// \u67e5\u627e\u53ef\u5199\u53ef\u6267\u884c\u533a\u57df\uff08\u6f5c\u5728\u7684 shellcode \u76ee\u6807\uff09 for (const auto& region : *regions) { if (region.isWritable() && region.isExecutable()) { std::cout << \"WX \u533a\u57df: \" << region.filename << \"\\n\"; } }","title":"\u6743\u9650\u68c0\u67e5"},{"location":"maps/#_14","text":"\u5185\u5b58\u9ad8\u6548 \uff1a\u5bf9\u5c0f\u6587\u4ef6\u540d\u4f7f\u7528\u5e26\u6709 SSO \u7684 std::string \u96f6\u62f7\u8d1d \uff1a\u76f4\u63a5\u4ece\u6620\u5c04\u884c\u63d0\u53d6\u5b57\u7b26\u4e32 \u63d0\u524d\u8fc7\u6ee4 \uff1a\u6839\u636e\u626b\u63cf\u7ea7\u522b\u5728\u89e3\u6790\u671f\u95f4\u8fc7\u6ee4\u533a\u57df RAII \uff1a\u901a\u8fc7 std::ifstream \u81ea\u52a8\u6e05\u7406\u8d44\u6e90","title":"\u6027\u80fd\u8bf4\u660e"},{"location":"maps/#_15","text":"\u7ebf\u7a0b\u5b89\u5168 \uff1a\u6240\u6709\u65b9\u6cd5\u5bf9\u5e76\u53d1\u8bbf\u95ee\u90fd\u662f\u7ebf\u7a0b\u5b89\u5168\u7684 \u65e0\u5171\u4eab\u72b6\u6001 \uff1a\u6bcf\u6b21\u8c03\u7528\u521b\u5efa\u72ec\u7acb\u72b6\u6001 \u4e0d\u53ef\u53d8\u7ed3\u679c \uff1a\u8fd4\u56de\u7684\u5411\u91cf\u5305\u542b\u4e0d\u53ef\u53d8\u6570\u636e","title":"\u7ebf\u7a0b\u5b89\u5168"},{"location":"maps/#_16","text":"\u4ec5 Linux \uff1a\u9700\u8981 /proc/[pid]/maps \u6587\u4ef6\u7cfb\u7edf \u9700\u8981 C++23 \uff1a\u4f7f\u7528 std::expected \u548c\u5176\u4ed6 C++23 \u7279\u6027 \u652f\u6301 64 \u4f4d \uff1a\u5904\u7406 32 \u4f4d\u548c 64 \u4f4d\u5730\u5740\u7a7a\u95f4","title":"\u5e73\u53f0\u517c\u5bb9\u6027"},{"location":"maps/#c","text":"","title":"\u4ece\u4f20\u7edf C \u4ee3\u7801\u8fc1\u79fb"},{"location":"maps/#c-c","text":"\u4f20\u7edf C \u73b0\u4ee3 C++ region_t* maps::region list_t std::vector<region> bool return std::expected char* \u6587\u4ef6\u540d std::string \u624b\u52a8\u5185\u5b58\u7ba1\u7406 RAII \u9519\u8bef\u4ee3\u7801 \u5f02\u5e38\u5b89\u5168\u7684\u9519\u8bef\u5904\u7406","title":"\u4f20\u7edf C \u2192 \u73b0\u4ee3 C++"},{"location":"maps/#_17","text":"","title":"\u793a\u4f8b"},{"location":"maps/#_18","text":"#include <iostream> import maps; int main() { pid_t target_pid = 1234; // \u66ff\u6362\u4e3a\u5b9e\u9645 PID auto regions = maps::readProcessMaps(target_pid); if (!regions) { std::cerr << \"\u8bfb\u53d6\u6620\u5c04\u5931\u8d25: \" << regions.error().message << \"\\n\"; return 1; } std::cout << \"\u627e\u5230 \" << regions->size() << \" \u4e2a\u5185\u5b58\u533a\u57df:\\n\"; for (const auto& region : *regions) { std::cout << std::format( \"0x{:x}-0x{:x} {} {} {}\\n\", reinterpret_cast<uintptr_t>(region.start), reinterpret_cast<uintptr_t>(region.start) + region.size, region.isReadable() ? 'r' : '-', region.isWritable() ? 'w' : '-', region.isExecutable() ? 'x' : '-', region.filename.empty() ? \"[\u533f\u540d]\" : region.filename ); } return 0; }","title":"\u5b8c\u6574\u5de5\u4f5c\u793a\u4f8b"},{"location":"maps/#cli","text":"maps \u6a21\u5757\u5728 CLI \u4e2d\u7528\u4e8e\u68c0\u7d22\u548c\u663e\u793a\u76ee\u6807\u8fdb\u7a0b\u7684\u5185\u5b58\u533a\u57df\u4fe1\u606f\u3002\u4f8b\u5982\uff0c list \u547d\u4ee4\u5229\u7528\u6b64\u6a21\u5757\u89e3\u6790\u5e76\u8f93\u51fa /proc/[pid]/maps \u6570\u636e\u3002","title":"\u4e0e CLI \u7684\u96c6\u6210"},{"location":"process_checker/","text":"\u8fdb\u7a0b\u68c0\u67e5\u6a21\u5757\u6587\u6863 \u6982\u8ff0 process_checker \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u8fdb\u7a0b\u72b6\u6001\u76d1\u63a7\u548c\u68c0\u67e5\u529f\u80fd\u3002\u5b83\u901a\u8fc7\u68c0\u67e5 Linux /proc \u6587\u4ef6\u7cfb\u7edf\u6765\u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u6b63\u5728\u8fd0\u884c\u3001\u5df2\u6b7b\u4ea1\u6216\u5904\u4e8e\u50f5\u5c38\u72b6\u6001\u3002 \u6a21\u5757\u7ed3\u6784 export module process_checker; \u4f9d\u8d56\u9879 <unistd.h> - POSIX \u64cd\u4f5c\u7cfb\u7edf API <filesystem> - C++17 \u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c <fstream> - \u6587\u4ef6\u6d41\u64cd\u4f5c <string> - \u5b57\u7b26\u4e32\u64cd\u4f5c \u6838\u5fc3\u529f\u80fd 1. \u8fdb\u7a0b\u72b6\u6001\u679a\u4e3e enum class ProcessState { RUNNING, // \u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c ERROR, // \u68c0\u67e5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef DEAD, // \u8fdb\u7a0b\u4e0d\u5b58\u5728 ZOMBIE // \u8fdb\u7a0b\u5904\u4e8e\u50f5\u5c38\u72b6\u6001 }; 2. ProcessChecker \u7c7b \u516c\u5171\u63a5\u53e3 class ProcessChecker { public: static ProcessState checkProcess(pid_t pid); static bool isProcessDead(pid_t pid); }; \u65b9\u6cd5 checkProcess(pid_t pid) \u68c0\u67e5\u6307\u5b9a PID \u7684\u8fdb\u7a0b\u72b6\u6001\u3002 \u53c2\u6570\uff1a pid : \u8981\u68c0\u67e5\u7684\u8fdb\u7a0b ID \u8fd4\u56de\u503c\uff1a ProcessState::RUNNING : \u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\uff08\u5305\u62ec\u7761\u7720\u3001\u7b49\u5f85\u3001\u505c\u6b62\u72b6\u6001\uff09 ProcessState::ERROR : \u68c0\u67e5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef\uff08\u65e0\u6548 PID\u3001\u6587\u4ef6\u8bbf\u95ee\u95ee\u9898\uff09 ProcessState::DEAD : \u8fdb\u7a0b\u4e0d\u5b58\u5728\uff08/proc/[pid] \u76ee\u5f55\u7f3a\u5931\uff09 ProcessState::ZOMBIE : \u8fdb\u7a0b\u5904\u4e8e\u50f5\u5c38\u6216\u6b7b\u4ea1\u72b6\u6001 isProcessDead(pid_t pid) \u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u672a\u8fd0\u884c\u7684\u4fbf\u6377\u65b9\u6cd5\u3002 \u53c2\u6570\uff1a pid : \u8981\u68c0\u67e5\u7684\u8fdb\u7a0b ID \u8fd4\u56de\u503c\uff1a true : \u8fdb\u7a0b\u5df2\u6b7b\u4ea1\u3001\u50f5\u5c38\u72b6\u6001\u6216\u53d1\u751f\u9519\u8bef false : \u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c \u5b9e\u73b0\u7ec6\u8282 \u8fdb\u7a0b\u72b6\u6001\u68c0\u6d4b \u6a21\u5757\u8bfb\u53d6 /proc/[pid]/status \u5e76\u68c0\u67e5 \"State:\" \u5b57\u6bb5\uff1a \u8fd0\u884c\u72b6\u6001 : 'R' (\u8fd0\u884c\u4e2d), 'S' (\u7761\u7720), 'D' (\u7b49\u5f85), 'T' (\u505c\u6b62) \u50f5\u5c38\u72b6\u6001 : 'Z' (\u50f5\u5c38), 'X' (\u6b7b\u4ea1) \u9519\u8bef\u5904\u7406 : \u65e0\u6548\u72b6\u6001\u5b57\u7b26\u3001\u6587\u4ef6\u8bbf\u95ee\u9519\u8bef \u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c \u9a8c\u8bc1 : \u68c0\u67e5 PID \u662f\u5426\u4e3a\u6b63\u6570 \u5b58\u5728\u6027 : \u9a8c\u8bc1 /proc/[pid] \u76ee\u5f55\u662f\u5426\u5b58\u5728 \u8bbf\u95ee : \u6253\u5f00 /proc/[pid]/status \u6587\u4ef6 \u89e3\u6790 : \u4ece\u6587\u4ef6\u5185\u5bb9\u4e2d\u8bfb\u53d6\u72b6\u6001\u4fe1\u606f \u4f7f\u7528\u793a\u4f8b \u57fa\u672c\u8fdb\u7a0b\u68c0\u67e5 import process_checker; pid_t pid = 1234; ProcessState state = ProcessChecker::checkProcess(pid); \u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u6b7b\u4ea1 import process_checker; pid_t pid = 1234; if (ProcessChecker::isProcessDead(pid)) { std::cout << \"\u8fdb\u7a0b \" << pid << \" \u5df2\u6b7b\u4ea1\u6216\u4e0d\u5b58\u5728\" << std::endl; } \u8be6\u7ec6\u72b6\u6001\u68c0\u67e5 import process_checker; pid_t pid = 1234; ProcessState state = ProcessChecker::checkProcess(pid); switch (state) { case ProcessState::RUNNING: std::cout << \"\u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\" << std::endl; break; case ProcessState::DEAD: std::cout << \"\u8fdb\u7a0b\u4e0d\u5b58\u5728\" << std::endl; break; case ProcessState::ZOMBIE: std::cout << \"\u8fdb\u7a0b\u5904\u4e8e\u50f5\u5c38\u72b6\u6001\" << std::endl; break; case ProcessState::ERROR: std::cout << \"\u68c0\u67e5\u8fdb\u7a0b\u65f6\u53d1\u751f\u9519\u8bef\" << std::endl; break; } \u9519\u8bef\u5904\u7406 \u5e38\u89c1\u9519\u8bef\u60c5\u51b5 \u65e0\u6548 PID : \u8d1f\u6570\u6216\u96f6\u503c PID \u6743\u9650\u4e0d\u8db3 : \u65e0\u6cd5\u8bbf\u95ee /proc/[pid] \u76ee\u5f55 \u6587\u4ef6\u7cfb\u7edf\u9519\u8bef : /proc \u6587\u4ef6\u7cfb\u7edf\u4e0d\u53ef\u7528 \u8fdb\u7a0b\u4e0d\u5b58\u5728 : \u6307\u5b9a\u7684 PID \u5bf9\u5e94\u7684\u8fdb\u7a0b\u4e0d\u5b58\u5728 \u9519\u8bef\u5904\u7406\u7b56\u7565 \u8fd4\u56de ProcessState::ERROR \u800c\u4e0d\u662f\u629b\u51fa\u5f02\u5e38 \u8bb0\u5f55\u8be6\u7ec6\u7684\u9519\u8bef\u4fe1\u606f\u7528\u4e8e\u8c03\u8bd5 \u63d0\u4f9b\u4fbf\u6377\u65b9\u6cd5 is_process_dead() \u8fdb\u884c\u7b80\u5355\u68c0\u67e5 \u6027\u80fd\u8003\u8651 \u4f18\u5316\u7b56\u7565 \u6700\u5c0f\u5316\u6587\u4ef6 I/O : \u53ea\u8bfb\u53d6\u5fc5\u8981\u7684\u72b6\u6001\u4fe1\u606f \u7f13\u5b58\u673a\u5236 : \u907f\u514d\u91cd\u590d\u68c0\u67e5\u540c\u4e00\u8fdb\u7a0b \u6279\u91cf\u68c0\u67e5 : \u652f\u6301\u540c\u65f6\u68c0\u67e5\u591a\u4e2a\u8fdb\u7a0b \u8d44\u6e90\u4f7f\u7528 \u5185\u5b58\u4f7f\u7528 : \u6700\u5c0f\u5316\u5185\u5b58\u5206\u914d \u6587\u4ef6\u63cf\u8ff0\u7b26 : \u53ca\u65f6\u5173\u95ed\u6587\u4ef6\u53e5\u67c4 CPU \u4f7f\u7528 : \u9ad8\u6548\u7684\u5b57\u7b26\u4e32\u89e3\u6790 \u7ebf\u7a0b\u5b89\u5168 \u5e76\u53d1\u8bbf\u95ee \u6240\u6709\u65b9\u6cd5\u90fd\u662f\u9759\u6001\u7684\uff0c\u4e0d\u7ef4\u62a4\u72b6\u6001 \u652f\u6301\u591a\u7ebf\u7a0b\u5e76\u53d1\u8c03\u7528 \u65e0\u5171\u4eab\u72b6\u6001\uff0c\u65e0\u9700\u540c\u6b65\u673a\u5236 \u6ce8\u610f\u4e8b\u9879 \u8fdb\u7a0b\u72b6\u6001\u53ef\u80fd\u5728\u68c0\u67e5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u53d8\u5316 \u5efa\u8bae\u5728\u5173\u952e\u64cd\u4f5c\u524d\u91cd\u65b0\u68c0\u67e5\u72b6\u6001 \u8003\u8651\u4f7f\u7528\u9002\u5f53\u7684\u91cd\u8bd5\u673a\u5236 \u6269\u5c55\u6027 \u672a\u6765\u589e\u5f3a \u66f4\u591a\u72b6\u6001\u7c7b\u578b : \u652f\u6301\u66f4\u8be6\u7ec6\u7684\u8fdb\u7a0b\u72b6\u6001 \u6027\u80fd\u76d1\u63a7 : \u6dfb\u52a0\u8fdb\u7a0b\u8d44\u6e90\u4f7f\u7528\u7edf\u8ba1 \u4e8b\u4ef6\u901a\u77e5 : \u652f\u6301\u8fdb\u7a0b\u72b6\u6001\u53d8\u5316\u901a\u77e5 \u6279\u91cf\u64cd\u4f5c : \u4f18\u5316\u591a\u8fdb\u7a0b\u68c0\u67e5\u6027\u80fd \u4e0e CLI \u7684\u96c6\u6210 process_checker \u6a21\u5757\u76f4\u63a5\u7528\u4e8e CLI \u4e2d\u7684 pid \u7b49\u547d\u4ee4\uff0c\u8fd9\u4e9b\u547d\u4ee4\u68c0\u67e5\u5e76\u663e\u793a\u76ee\u6807\u8fdb\u7a0b\u7684\u72b6\u6001\u3002\u8fd9\u786e\u4fdd\u7528\u6237\u53ef\u4ee5\u4ea4\u4e92\u5f0f\u5730\u9a8c\u8bc1\u8fdb\u7a0b\u72b6\u6001\u3002","title":"\u8fdb\u7a0b\u68c0\u67e5\u5668"},{"location":"process_checker/#_1","text":"","title":"\u8fdb\u7a0b\u68c0\u67e5\u6a21\u5757\u6587\u6863"},{"location":"process_checker/#_2","text":"process_checker \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u8fdb\u7a0b\u72b6\u6001\u76d1\u63a7\u548c\u68c0\u67e5\u529f\u80fd\u3002\u5b83\u901a\u8fc7\u68c0\u67e5 Linux /proc \u6587\u4ef6\u7cfb\u7edf\u6765\u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u6b63\u5728\u8fd0\u884c\u3001\u5df2\u6b7b\u4ea1\u6216\u5904\u4e8e\u50f5\u5c38\u72b6\u6001\u3002","title":"\u6982\u8ff0"},{"location":"process_checker/#_3","text":"export module process_checker;","title":"\u6a21\u5757\u7ed3\u6784"},{"location":"process_checker/#_4","text":"<unistd.h> - POSIX \u64cd\u4f5c\u7cfb\u7edf API <filesystem> - C++17 \u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c <fstream> - \u6587\u4ef6\u6d41\u64cd\u4f5c <string> - \u5b57\u7b26\u4e32\u64cd\u4f5c","title":"\u4f9d\u8d56\u9879"},{"location":"process_checker/#_5","text":"","title":"\u6838\u5fc3\u529f\u80fd"},{"location":"process_checker/#1","text":"enum class ProcessState { RUNNING, // \u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c ERROR, // \u68c0\u67e5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef DEAD, // \u8fdb\u7a0b\u4e0d\u5b58\u5728 ZOMBIE // \u8fdb\u7a0b\u5904\u4e8e\u50f5\u5c38\u72b6\u6001 };","title":"1. \u8fdb\u7a0b\u72b6\u6001\u679a\u4e3e"},{"location":"process_checker/#2-processchecker","text":"","title":"2. ProcessChecker \u7c7b"},{"location":"process_checker/#_6","text":"class ProcessChecker { public: static ProcessState checkProcess(pid_t pid); static bool isProcessDead(pid_t pid); };","title":"\u516c\u5171\u63a5\u53e3"},{"location":"process_checker/#_7","text":"","title":"\u65b9\u6cd5"},{"location":"process_checker/#checkprocesspid_t-pid","text":"\u68c0\u67e5\u6307\u5b9a PID \u7684\u8fdb\u7a0b\u72b6\u6001\u3002 \u53c2\u6570\uff1a pid : \u8981\u68c0\u67e5\u7684\u8fdb\u7a0b ID \u8fd4\u56de\u503c\uff1a ProcessState::RUNNING : \u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\uff08\u5305\u62ec\u7761\u7720\u3001\u7b49\u5f85\u3001\u505c\u6b62\u72b6\u6001\uff09 ProcessState::ERROR : \u68c0\u67e5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef\uff08\u65e0\u6548 PID\u3001\u6587\u4ef6\u8bbf\u95ee\u95ee\u9898\uff09 ProcessState::DEAD : \u8fdb\u7a0b\u4e0d\u5b58\u5728\uff08/proc/[pid] \u76ee\u5f55\u7f3a\u5931\uff09 ProcessState::ZOMBIE : \u8fdb\u7a0b\u5904\u4e8e\u50f5\u5c38\u6216\u6b7b\u4ea1\u72b6\u6001","title":"checkProcess(pid_t pid)"},{"location":"process_checker/#isprocessdeadpid_t-pid","text":"\u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u672a\u8fd0\u884c\u7684\u4fbf\u6377\u65b9\u6cd5\u3002 \u53c2\u6570\uff1a pid : \u8981\u68c0\u67e5\u7684\u8fdb\u7a0b ID \u8fd4\u56de\u503c\uff1a true : \u8fdb\u7a0b\u5df2\u6b7b\u4ea1\u3001\u50f5\u5c38\u72b6\u6001\u6216\u53d1\u751f\u9519\u8bef false : \u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c","title":"isProcessDead(pid_t pid)"},{"location":"process_checker/#_8","text":"","title":"\u5b9e\u73b0\u7ec6\u8282"},{"location":"process_checker/#_9","text":"\u6a21\u5757\u8bfb\u53d6 /proc/[pid]/status \u5e76\u68c0\u67e5 \"State:\" \u5b57\u6bb5\uff1a \u8fd0\u884c\u72b6\u6001 : 'R' (\u8fd0\u884c\u4e2d), 'S' (\u7761\u7720), 'D' (\u7b49\u5f85), 'T' (\u505c\u6b62) \u50f5\u5c38\u72b6\u6001 : 'Z' (\u50f5\u5c38), 'X' (\u6b7b\u4ea1) \u9519\u8bef\u5904\u7406 : \u65e0\u6548\u72b6\u6001\u5b57\u7b26\u3001\u6587\u4ef6\u8bbf\u95ee\u9519\u8bef","title":"\u8fdb\u7a0b\u72b6\u6001\u68c0\u6d4b"},{"location":"process_checker/#_10","text":"\u9a8c\u8bc1 : \u68c0\u67e5 PID \u662f\u5426\u4e3a\u6b63\u6570 \u5b58\u5728\u6027 : \u9a8c\u8bc1 /proc/[pid] \u76ee\u5f55\u662f\u5426\u5b58\u5728 \u8bbf\u95ee : \u6253\u5f00 /proc/[pid]/status \u6587\u4ef6 \u89e3\u6790 : \u4ece\u6587\u4ef6\u5185\u5bb9\u4e2d\u8bfb\u53d6\u72b6\u6001\u4fe1\u606f","title":"\u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c"},{"location":"process_checker/#_11","text":"","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"process_checker/#_12","text":"import process_checker; pid_t pid = 1234; ProcessState state = ProcessChecker::checkProcess(pid);","title":"\u57fa\u672c\u8fdb\u7a0b\u68c0\u67e5"},{"location":"process_checker/#_13","text":"import process_checker; pid_t pid = 1234; if (ProcessChecker::isProcessDead(pid)) { std::cout << \"\u8fdb\u7a0b \" << pid << \" \u5df2\u6b7b\u4ea1\u6216\u4e0d\u5b58\u5728\" << std::endl; }","title":"\u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u6b7b\u4ea1"},{"location":"process_checker/#_14","text":"import process_checker; pid_t pid = 1234; ProcessState state = ProcessChecker::checkProcess(pid); switch (state) { case ProcessState::RUNNING: std::cout << \"\u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\" << std::endl; break; case ProcessState::DEAD: std::cout << \"\u8fdb\u7a0b\u4e0d\u5b58\u5728\" << std::endl; break; case ProcessState::ZOMBIE: std::cout << \"\u8fdb\u7a0b\u5904\u4e8e\u50f5\u5c38\u72b6\u6001\" << std::endl; break; case ProcessState::ERROR: std::cout << \"\u68c0\u67e5\u8fdb\u7a0b\u65f6\u53d1\u751f\u9519\u8bef\" << std::endl; break; }","title":"\u8be6\u7ec6\u72b6\u6001\u68c0\u67e5"},{"location":"process_checker/#_15","text":"","title":"\u9519\u8bef\u5904\u7406"},{"location":"process_checker/#_16","text":"\u65e0\u6548 PID : \u8d1f\u6570\u6216\u96f6\u503c PID \u6743\u9650\u4e0d\u8db3 : \u65e0\u6cd5\u8bbf\u95ee /proc/[pid] \u76ee\u5f55 \u6587\u4ef6\u7cfb\u7edf\u9519\u8bef : /proc \u6587\u4ef6\u7cfb\u7edf\u4e0d\u53ef\u7528 \u8fdb\u7a0b\u4e0d\u5b58\u5728 : \u6307\u5b9a\u7684 PID \u5bf9\u5e94\u7684\u8fdb\u7a0b\u4e0d\u5b58\u5728","title":"\u5e38\u89c1\u9519\u8bef\u60c5\u51b5"},{"location":"process_checker/#_17","text":"\u8fd4\u56de ProcessState::ERROR \u800c\u4e0d\u662f\u629b\u51fa\u5f02\u5e38 \u8bb0\u5f55\u8be6\u7ec6\u7684\u9519\u8bef\u4fe1\u606f\u7528\u4e8e\u8c03\u8bd5 \u63d0\u4f9b\u4fbf\u6377\u65b9\u6cd5 is_process_dead() \u8fdb\u884c\u7b80\u5355\u68c0\u67e5","title":"\u9519\u8bef\u5904\u7406\u7b56\u7565"},{"location":"process_checker/#_18","text":"","title":"\u6027\u80fd\u8003\u8651"},{"location":"process_checker/#_19","text":"\u6700\u5c0f\u5316\u6587\u4ef6 I/O : \u53ea\u8bfb\u53d6\u5fc5\u8981\u7684\u72b6\u6001\u4fe1\u606f \u7f13\u5b58\u673a\u5236 : \u907f\u514d\u91cd\u590d\u68c0\u67e5\u540c\u4e00\u8fdb\u7a0b \u6279\u91cf\u68c0\u67e5 : \u652f\u6301\u540c\u65f6\u68c0\u67e5\u591a\u4e2a\u8fdb\u7a0b","title":"\u4f18\u5316\u7b56\u7565"},{"location":"process_checker/#_20","text":"\u5185\u5b58\u4f7f\u7528 : \u6700\u5c0f\u5316\u5185\u5b58\u5206\u914d \u6587\u4ef6\u63cf\u8ff0\u7b26 : \u53ca\u65f6\u5173\u95ed\u6587\u4ef6\u53e5\u67c4 CPU \u4f7f\u7528 : \u9ad8\u6548\u7684\u5b57\u7b26\u4e32\u89e3\u6790","title":"\u8d44\u6e90\u4f7f\u7528"},{"location":"process_checker/#_21","text":"","title":"\u7ebf\u7a0b\u5b89\u5168"},{"location":"process_checker/#_22","text":"\u6240\u6709\u65b9\u6cd5\u90fd\u662f\u9759\u6001\u7684\uff0c\u4e0d\u7ef4\u62a4\u72b6\u6001 \u652f\u6301\u591a\u7ebf\u7a0b\u5e76\u53d1\u8c03\u7528 \u65e0\u5171\u4eab\u72b6\u6001\uff0c\u65e0\u9700\u540c\u6b65\u673a\u5236","title":"\u5e76\u53d1\u8bbf\u95ee"},{"location":"process_checker/#_23","text":"\u8fdb\u7a0b\u72b6\u6001\u53ef\u80fd\u5728\u68c0\u67e5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u53d8\u5316 \u5efa\u8bae\u5728\u5173\u952e\u64cd\u4f5c\u524d\u91cd\u65b0\u68c0\u67e5\u72b6\u6001 \u8003\u8651\u4f7f\u7528\u9002\u5f53\u7684\u91cd\u8bd5\u673a\u5236","title":"\u6ce8\u610f\u4e8b\u9879"},{"location":"process_checker/#_24","text":"","title":"\u6269\u5c55\u6027"},{"location":"process_checker/#_25","text":"\u66f4\u591a\u72b6\u6001\u7c7b\u578b : \u652f\u6301\u66f4\u8be6\u7ec6\u7684\u8fdb\u7a0b\u72b6\u6001 \u6027\u80fd\u76d1\u63a7 : \u6dfb\u52a0\u8fdb\u7a0b\u8d44\u6e90\u4f7f\u7528\u7edf\u8ba1 \u4e8b\u4ef6\u901a\u77e5 : \u652f\u6301\u8fdb\u7a0b\u72b6\u6001\u53d8\u5316\u901a\u77e5 \u6279\u91cf\u64cd\u4f5c : \u4f18\u5316\u591a\u8fdb\u7a0b\u68c0\u67e5\u6027\u80fd","title":"\u672a\u6765\u589e\u5f3a"},{"location":"process_checker/#cli","text":"process_checker \u6a21\u5757\u76f4\u63a5\u7528\u4e8e CLI \u4e2d\u7684 pid \u7b49\u547d\u4ee4\uff0c\u8fd9\u4e9b\u547d\u4ee4\u68c0\u67e5\u5e76\u663e\u793a\u76ee\u6807\u8fdb\u7a0b\u7684\u72b6\u6001\u3002\u8fd9\u786e\u4fdd\u7528\u6237\u53ef\u4ee5\u4ea4\u4e92\u5f0f\u5730\u9a8c\u8bc1\u8fdb\u7a0b\u72b6\u6001\u3002","title":"\u4e0e CLI \u7684\u96c6\u6210"},{"location":"sets/","text":"\u96c6\u5408\u6a21\u5757\u6587\u6863 \u6982\u8ff0 sets \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u96c6\u5408\u64cd\u4f5c\u548c\u89e3\u6790\u5de5\u5177\u3002\u5b83\u5305\u62ec\u4e00\u4e2a\u7528\u4e8e\u7ba1\u7406\u6574\u6570\u96c6\u5408\u7684 Set \u7c7b\uff0c\u4ee5\u53ca\u4e00\u4e2a\u5f3a\u5927\u7684\u96c6\u5408\u8868\u8fbe\u5f0f\u89e3\u6790\u5668\uff0c\u652f\u6301\u8303\u56f4\u3001\u5341\u516d\u8fdb\u5236/\u5341\u8fdb\u5236\u6570\u5b57\u548c\u53d6\u53cd\u64cd\u4f5c\u3002 \u6a21\u5757\u7ed3\u6784 export module sets; \u4f9d\u8d56\u9879 <algorithm> - \u6807\u51c6\u7b97\u6cd5 <boost/regex.hpp> - \u6b63\u5219\u8868\u8fbe\u5f0f\u652f\u6301 <boost/spirit/include/phoenix.hpp> - Boost Spirit Phoenix \u8bed\u4e49\u52a8\u4f5c <boost/spirit/include/qi.hpp> - Boost Spirit Qi \u89e3\u6790 <cctype> - \u5b57\u7b26\u5206\u7c7b <compare> - \u4e09\u8def\u6bd4\u8f83 <cstdlib> - C \u6807\u51c6\u5e93 <stdexcept> - \u6807\u51c6\u5f02\u5e38 <string> - \u5b57\u7b26\u4e32\u64cd\u4f5c <vector> - \u52a8\u6001\u6570\u7ec4\u5bb9\u5668 \u6838\u5fc3\u529f\u80fd 1. Set \u7ed3\u6784 export struct Set { std::vector<size_t> buf; size_t size() const; void clear(); static int cmp(const size_t& i1, const size_t& i2); }; \u65b9\u6cd5 size() : \u8fd4\u56de\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6570\u91cf clear() : \u79fb\u9664\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20 cmp() : \u4f7f\u7528\u4e09\u8def\u6bd4\u8f83\u5bf9\u4e24\u4e2a size_t \u503c\u8fdb\u884c\u9759\u6001\u6bd4\u8f83\u51fd\u6570 2. \u96c6\u5408\u8868\u8fbe\u5f0f\u89e3\u6790\u5668 export bool parse_uintset(std::string_view lptr, Set& set, size_t maxSZ); \u652f\u6301\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f \u5355\u4e2a\u6570\u5b57 : 42 , 0x2A \u8303\u56f4 : 10..20 , 0x10..0xFF \u591a\u4e2a\u503c : 1,2,3,4,5 \u6df7\u5408\u683c\u5f0f : 1,5,10..15,0x20 \u53d6\u53cd : !1,2,3 (\u9664\u4e86 1,2,3 \u4e4b\u5916\u7684\u6240\u6709\u6570\u5b57) \u5341\u516d\u8fdb\u5236 : 0x10 , 0xFF , 0xdeadbeef \u53c2\u6570 lptr : \u8981\u89e3\u6790\u7684\u96c6\u5408\u8868\u8fbe\u5f0f\u5b57\u7b26\u4e32 set : \u7528\u4e8e\u5b58\u50a8\u7ed3\u679c\u7684 Set \u5bf9\u8c61 maxSZ : \u6700\u5927\u5141\u8bb8\u503c\uff08\u72ec\u5360\u4e0a\u754c\uff09 \u8fd4\u56de\u503c true : \u89e3\u6790\u6210\u529f false : \u89e3\u6790\u5931\u8d25\uff08\u8bed\u6cd5\u65e0\u6548\u3001\u8d85\u51fa\u8303\u56f4\u7b49\uff09 3. \u5df2\u5f03\u7528\u7684\u5185\u5b58\u7ba1\u7406 [[deprecated(\"This interface is deprecated...\")]] constexpr auto inc_arr_sz = [](size_t** valarr, size_t* arr_maxsz, size_t maxsz) -> bool; \u4e00\u4e2a\u5df2\u5f03\u7528\u7684 C \u98ce\u683c\u5185\u5b58\u7ba1\u7406\u5de5\u5177\uff0c\u7528\u4e8e\u52a8\u6001\u6570\u7ec4\u5927\u5c0f\u8c03\u6574\u3002 \u4f7f\u7528\u793a\u4f8b \u57fa\u672c\u96c6\u5408\u89e3\u6790 import sets; Set mySet; bool success = parse_uintset(\"1,2,3,4,5\", mySet, 100); if (success) { std::cout << \"\u96c6\u5408\u5305\u542b \" << mySet.size() << \" \u4e2a\u5143\u7d20\\n\"; } \u8303\u56f4\u89e3\u6790 Set rangeSet; parse_uintset(\"10..20\", rangeSet, 100); // \u7ed3\u679c: {10, 11, 12, ..., 20} \u5341\u516d\u8fdb\u5236\u89e3\u6790 Set hexSet; parse_uintset(\"0x10..0x20\", hexSet, 100); // \u7ed3\u679c: {16, 17, 18, ..., 32} \u6df7\u5408\u683c\u5f0f\u89e3\u6790 Set mixedSet; parse_uintset(\"1,5,10..15,0x20\", mixedSet, 100); // \u7ed3\u679c: {1, 5, 10, 11, 12, 13, 14, 15, 32} \u53d6\u53cd\u64cd\u4f5c\u793a\u4f8b Set invertedSet; parse_uintset(\"!1,2,3\", invertedSet, 10); // \u7ed3\u679c: {0, 4, 5, 6, 7, 8, 9} (\u9664\u4e86 1,2,3 \u4e4b\u5916\u7684\u6240\u6709\u6570\u5b57) \u8868\u8fbe\u5f0f\u8bed\u6cd5 \u6570\u5b57\u683c\u5f0f \u5341\u8fdb\u5236 : 123 , 456 , 789 \u5341\u516d\u8fdb\u5236 : 0x7B , 0x1C8 , 0x315 \u6df7\u5408 : \u5728\u540c\u4e00\u8868\u8fbe\u5f0f\u4e2d\u53ef\u4ee5\u6df7\u5408\u4f7f\u7528 \u8303\u56f4\u8bed\u6cd5 \u57fa\u672c\u8303\u56f4 : start..end \u5341\u516d\u8fdb\u5236\u8303\u56f4 : 0xstart..0xend \u5305\u542b\u8fb9\u754c : \u8303\u56f4\u5305\u542b\u8d77\u59cb\u503c\u548c\u7ed3\u675f\u503c \u5206\u9694\u7b26 \u9017\u53f7\u5206\u9694 : 1,2,3,4,5 \u7a7a\u683c\u5206\u9694 : 1 2 3 4 5 (\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b) \u6df7\u5408\u5206\u9694 : 1, 2, 3, 4, 5 \u53d6\u53cd\u64cd\u4f5c \u8bed\u6cd5 : !expression \u6548\u679c : \u5305\u542b\u6307\u5b9a\u8303\u56f4\u5185\u9664\u4e86\u8868\u8fbe\u5f0f\u6307\u5b9a\u503c\u4e4b\u5916\u7684\u6240\u6709\u6570\u5b57 \u793a\u4f8b : !1,2,3 \u5728\u8303\u56f4 0..10 \u4e2d\u8868\u793a {0,4,5,6,7,8,9,10} \u9519\u8bef\u5904\u7406 \u5e38\u89c1\u9519\u8bef \u8bed\u6cd5\u9519\u8bef : \u65e0\u6548\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f \u8d85\u51fa\u8303\u56f4 : \u6570\u5b57\u8d85\u51fa\u6307\u5b9a\u7684\u6700\u5927\u503c \u7a7a\u8868\u8fbe\u5f0f : \u7a7a\u5b57\u7b26\u4e32\u6216\u65e0\u6548\u8f93\u5165 \u89e3\u6790\u5931\u8d25 : Boost Spirit \u89e3\u6790\u5668\u9519\u8bef \u9519\u8bef\u5904\u7406\u7b56\u7565 \u8fd4\u56de false \u8868\u793a\u89e3\u6790\u5931\u8d25 \u4e0d\u4fee\u6539\u76ee\u6807 Set \u5bf9\u8c61 \u63d0\u4f9b\u8be6\u7ec6\u7684\u9519\u8bef\u4fe1\u606f\u7528\u4e8e\u8c03\u8bd5 \u6027\u80fd\u8003\u8651 \u4f18\u5316\u7b56\u7565 \u5185\u5b58\u9884\u5206\u914d : \u6839\u636e\u8868\u8fbe\u5f0f\u590d\u6742\u5ea6\u9884\u5206\u914d\u5185\u5b58 \u89e3\u6790\u4f18\u5316 : \u4f7f\u7528\u9ad8\u6548\u7684 Boost Spirit \u89e3\u6790\u5668 \u8303\u56f4\u4f18\u5316 : \u5bf9\u8fde\u7eed\u8303\u56f4\u8fdb\u884c\u7279\u6b8a\u5904\u7406 \u5185\u5b58\u4f7f\u7528 \u52a8\u6001\u589e\u957f : \u6839\u636e\u89e3\u6790\u7ed3\u679c\u52a8\u6001\u8c03\u6574\u5185\u5b58 \u6700\u5c0f\u5316\u5206\u914d : \u51cf\u5c11\u4e0d\u5fc5\u8981\u7684\u5185\u5b58\u5206\u914d \u7f13\u5b58\u53cb\u597d : \u4f7f\u7528\u8fde\u7eed\u5185\u5b58\u5e03\u5c40 \u6269\u5c55\u6027 \u672a\u6765\u589e\u5f3a \u66f4\u591a\u6570\u5b57\u683c\u5f0f : \u652f\u6301\u516b\u8fdb\u5236\u3001\u4e8c\u8fdb\u5236\u7b49 \u590d\u6742\u8868\u8fbe\u5f0f : \u652f\u6301\u6570\u5b66\u8fd0\u7b97\u548c\u51fd\u6570 \u6027\u80fd\u4f18\u5316 : \u8fdb\u4e00\u6b65\u4f18\u5316\u89e3\u6790\u6027\u80fd \u9519\u8bef\u6062\u590d : \u66f4\u597d\u7684\u9519\u8bef\u6062\u590d\u673a\u5236 \u517c\u5bb9\u6027 \u5411\u540e\u517c\u5bb9 \u4fdd\u6301\u4e0e\u73b0\u6709\u4ee3\u7801\u7684\u517c\u5bb9\u6027 \u652f\u6301\u65e7\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f \u6e10\u8fdb\u5f0f\u5f03\u7528\u8fc7\u65f6\u529f\u80fd \u6807\u51c6\u517c\u5bb9 \u9075\u5faa C++23 \u6807\u51c6 \u4f7f\u7528\u73b0\u4ee3 C++ \u7279\u6027 \u4fdd\u6301\u8de8\u5e73\u53f0\u517c\u5bb9\u6027 \u4e0e CLI \u7684\u96c6\u6210 sets \u6a21\u5757\u5728 CLI \u4e2d\u7528\u4e8e\u89e3\u6790\u548c\u7ba1\u7406\u5185\u5b58\u626b\u63cf\u671f\u95f4\u7684\u7ed3\u679c\u96c6\u3002 scan \u548c reset \u7b49\u547d\u4ee4\u4f9d\u8d56\u6b64\u6a21\u5757\u9ad8\u6548\u5730\u5904\u7406\u96c6\u5408\u64cd\u4f5c\u3002","title":"\u96c6\u5408"},{"location":"sets/#_1","text":"","title":"\u96c6\u5408\u6a21\u5757\u6587\u6863"},{"location":"sets/#_2","text":"sets \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u96c6\u5408\u64cd\u4f5c\u548c\u89e3\u6790\u5de5\u5177\u3002\u5b83\u5305\u62ec\u4e00\u4e2a\u7528\u4e8e\u7ba1\u7406\u6574\u6570\u96c6\u5408\u7684 Set \u7c7b\uff0c\u4ee5\u53ca\u4e00\u4e2a\u5f3a\u5927\u7684\u96c6\u5408\u8868\u8fbe\u5f0f\u89e3\u6790\u5668\uff0c\u652f\u6301\u8303\u56f4\u3001\u5341\u516d\u8fdb\u5236/\u5341\u8fdb\u5236\u6570\u5b57\u548c\u53d6\u53cd\u64cd\u4f5c\u3002","title":"\u6982\u8ff0"},{"location":"sets/#_3","text":"export module sets;","title":"\u6a21\u5757\u7ed3\u6784"},{"location":"sets/#_4","text":"<algorithm> - \u6807\u51c6\u7b97\u6cd5 <boost/regex.hpp> - \u6b63\u5219\u8868\u8fbe\u5f0f\u652f\u6301 <boost/spirit/include/phoenix.hpp> - Boost Spirit Phoenix \u8bed\u4e49\u52a8\u4f5c <boost/spirit/include/qi.hpp> - Boost Spirit Qi \u89e3\u6790 <cctype> - \u5b57\u7b26\u5206\u7c7b <compare> - \u4e09\u8def\u6bd4\u8f83 <cstdlib> - C \u6807\u51c6\u5e93 <stdexcept> - \u6807\u51c6\u5f02\u5e38 <string> - \u5b57\u7b26\u4e32\u64cd\u4f5c <vector> - \u52a8\u6001\u6570\u7ec4\u5bb9\u5668","title":"\u4f9d\u8d56\u9879"},{"location":"sets/#_5","text":"","title":"\u6838\u5fc3\u529f\u80fd"},{"location":"sets/#1-set","text":"export struct Set { std::vector<size_t> buf; size_t size() const; void clear(); static int cmp(const size_t& i1, const size_t& i2); };","title":"1. Set \u7ed3\u6784"},{"location":"sets/#_6","text":"size() : \u8fd4\u56de\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6570\u91cf clear() : \u79fb\u9664\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20 cmp() : \u4f7f\u7528\u4e09\u8def\u6bd4\u8f83\u5bf9\u4e24\u4e2a size_t \u503c\u8fdb\u884c\u9759\u6001\u6bd4\u8f83\u51fd\u6570","title":"\u65b9\u6cd5"},{"location":"sets/#2","text":"export bool parse_uintset(std::string_view lptr, Set& set, size_t maxSZ);","title":"2. \u96c6\u5408\u8868\u8fbe\u5f0f\u89e3\u6790\u5668"},{"location":"sets/#_7","text":"\u5355\u4e2a\u6570\u5b57 : 42 , 0x2A \u8303\u56f4 : 10..20 , 0x10..0xFF \u591a\u4e2a\u503c : 1,2,3,4,5 \u6df7\u5408\u683c\u5f0f : 1,5,10..15,0x20 \u53d6\u53cd : !1,2,3 (\u9664\u4e86 1,2,3 \u4e4b\u5916\u7684\u6240\u6709\u6570\u5b57) \u5341\u516d\u8fdb\u5236 : 0x10 , 0xFF , 0xdeadbeef","title":"\u652f\u6301\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f"},{"location":"sets/#_8","text":"lptr : \u8981\u89e3\u6790\u7684\u96c6\u5408\u8868\u8fbe\u5f0f\u5b57\u7b26\u4e32 set : \u7528\u4e8e\u5b58\u50a8\u7ed3\u679c\u7684 Set \u5bf9\u8c61 maxSZ : \u6700\u5927\u5141\u8bb8\u503c\uff08\u72ec\u5360\u4e0a\u754c\uff09","title":"\u53c2\u6570"},{"location":"sets/#_9","text":"true : \u89e3\u6790\u6210\u529f false : \u89e3\u6790\u5931\u8d25\uff08\u8bed\u6cd5\u65e0\u6548\u3001\u8d85\u51fa\u8303\u56f4\u7b49\uff09","title":"\u8fd4\u56de\u503c"},{"location":"sets/#3","text":"[[deprecated(\"This interface is deprecated...\")]] constexpr auto inc_arr_sz = [](size_t** valarr, size_t* arr_maxsz, size_t maxsz) -> bool; \u4e00\u4e2a\u5df2\u5f03\u7528\u7684 C \u98ce\u683c\u5185\u5b58\u7ba1\u7406\u5de5\u5177\uff0c\u7528\u4e8e\u52a8\u6001\u6570\u7ec4\u5927\u5c0f\u8c03\u6574\u3002","title":"3. \u5df2\u5f03\u7528\u7684\u5185\u5b58\u7ba1\u7406"},{"location":"sets/#_10","text":"","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"sets/#_11","text":"import sets; Set mySet; bool success = parse_uintset(\"1,2,3,4,5\", mySet, 100); if (success) { std::cout << \"\u96c6\u5408\u5305\u542b \" << mySet.size() << \" \u4e2a\u5143\u7d20\\n\"; }","title":"\u57fa\u672c\u96c6\u5408\u89e3\u6790"},{"location":"sets/#_12","text":"Set rangeSet; parse_uintset(\"10..20\", rangeSet, 100); // \u7ed3\u679c: {10, 11, 12, ..., 20}","title":"\u8303\u56f4\u89e3\u6790"},{"location":"sets/#_13","text":"Set hexSet; parse_uintset(\"0x10..0x20\", hexSet, 100); // \u7ed3\u679c: {16, 17, 18, ..., 32}","title":"\u5341\u516d\u8fdb\u5236\u89e3\u6790"},{"location":"sets/#_14","text":"Set mixedSet; parse_uintset(\"1,5,10..15,0x20\", mixedSet, 100); // \u7ed3\u679c: {1, 5, 10, 11, 12, 13, 14, 15, 32}","title":"\u6df7\u5408\u683c\u5f0f\u89e3\u6790"},{"location":"sets/#_15","text":"Set invertedSet; parse_uintset(\"!1,2,3\", invertedSet, 10); // \u7ed3\u679c: {0, 4, 5, 6, 7, 8, 9} (\u9664\u4e86 1,2,3 \u4e4b\u5916\u7684\u6240\u6709\u6570\u5b57)","title":"\u53d6\u53cd\u64cd\u4f5c\u793a\u4f8b"},{"location":"sets/#_16","text":"","title":"\u8868\u8fbe\u5f0f\u8bed\u6cd5"},{"location":"sets/#_17","text":"\u5341\u8fdb\u5236 : 123 , 456 , 789 \u5341\u516d\u8fdb\u5236 : 0x7B , 0x1C8 , 0x315 \u6df7\u5408 : \u5728\u540c\u4e00\u8868\u8fbe\u5f0f\u4e2d\u53ef\u4ee5\u6df7\u5408\u4f7f\u7528","title":"\u6570\u5b57\u683c\u5f0f"},{"location":"sets/#_18","text":"\u57fa\u672c\u8303\u56f4 : start..end \u5341\u516d\u8fdb\u5236\u8303\u56f4 : 0xstart..0xend \u5305\u542b\u8fb9\u754c : \u8303\u56f4\u5305\u542b\u8d77\u59cb\u503c\u548c\u7ed3\u675f\u503c","title":"\u8303\u56f4\u8bed\u6cd5"},{"location":"sets/#_19","text":"\u9017\u53f7\u5206\u9694 : 1,2,3,4,5 \u7a7a\u683c\u5206\u9694 : 1 2 3 4 5 (\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b) \u6df7\u5408\u5206\u9694 : 1, 2, 3, 4, 5","title":"\u5206\u9694\u7b26"},{"location":"sets/#_20","text":"\u8bed\u6cd5 : !expression \u6548\u679c : \u5305\u542b\u6307\u5b9a\u8303\u56f4\u5185\u9664\u4e86\u8868\u8fbe\u5f0f\u6307\u5b9a\u503c\u4e4b\u5916\u7684\u6240\u6709\u6570\u5b57 \u793a\u4f8b : !1,2,3 \u5728\u8303\u56f4 0..10 \u4e2d\u8868\u793a {0,4,5,6,7,8,9,10}","title":"\u53d6\u53cd\u64cd\u4f5c"},{"location":"sets/#_21","text":"","title":"\u9519\u8bef\u5904\u7406"},{"location":"sets/#_22","text":"\u8bed\u6cd5\u9519\u8bef : \u65e0\u6548\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f \u8d85\u51fa\u8303\u56f4 : \u6570\u5b57\u8d85\u51fa\u6307\u5b9a\u7684\u6700\u5927\u503c \u7a7a\u8868\u8fbe\u5f0f : \u7a7a\u5b57\u7b26\u4e32\u6216\u65e0\u6548\u8f93\u5165 \u89e3\u6790\u5931\u8d25 : Boost Spirit \u89e3\u6790\u5668\u9519\u8bef","title":"\u5e38\u89c1\u9519\u8bef"},{"location":"sets/#_23","text":"\u8fd4\u56de false \u8868\u793a\u89e3\u6790\u5931\u8d25 \u4e0d\u4fee\u6539\u76ee\u6807 Set \u5bf9\u8c61 \u63d0\u4f9b\u8be6\u7ec6\u7684\u9519\u8bef\u4fe1\u606f\u7528\u4e8e\u8c03\u8bd5","title":"\u9519\u8bef\u5904\u7406\u7b56\u7565"},{"location":"sets/#_24","text":"","title":"\u6027\u80fd\u8003\u8651"},{"location":"sets/#_25","text":"\u5185\u5b58\u9884\u5206\u914d : \u6839\u636e\u8868\u8fbe\u5f0f\u590d\u6742\u5ea6\u9884\u5206\u914d\u5185\u5b58 \u89e3\u6790\u4f18\u5316 : \u4f7f\u7528\u9ad8\u6548\u7684 Boost Spirit \u89e3\u6790\u5668 \u8303\u56f4\u4f18\u5316 : \u5bf9\u8fde\u7eed\u8303\u56f4\u8fdb\u884c\u7279\u6b8a\u5904\u7406","title":"\u4f18\u5316\u7b56\u7565"},{"location":"sets/#_26","text":"\u52a8\u6001\u589e\u957f : \u6839\u636e\u89e3\u6790\u7ed3\u679c\u52a8\u6001\u8c03\u6574\u5185\u5b58 \u6700\u5c0f\u5316\u5206\u914d : \u51cf\u5c11\u4e0d\u5fc5\u8981\u7684\u5185\u5b58\u5206\u914d \u7f13\u5b58\u53cb\u597d : \u4f7f\u7528\u8fde\u7eed\u5185\u5b58\u5e03\u5c40","title":"\u5185\u5b58\u4f7f\u7528"},{"location":"sets/#_27","text":"","title":"\u6269\u5c55\u6027"},{"location":"sets/#_28","text":"\u66f4\u591a\u6570\u5b57\u683c\u5f0f : \u652f\u6301\u516b\u8fdb\u5236\u3001\u4e8c\u8fdb\u5236\u7b49 \u590d\u6742\u8868\u8fbe\u5f0f : \u652f\u6301\u6570\u5b66\u8fd0\u7b97\u548c\u51fd\u6570 \u6027\u80fd\u4f18\u5316 : \u8fdb\u4e00\u6b65\u4f18\u5316\u89e3\u6790\u6027\u80fd \u9519\u8bef\u6062\u590d : \u66f4\u597d\u7684\u9519\u8bef\u6062\u590d\u673a\u5236","title":"\u672a\u6765\u589e\u5f3a"},{"location":"sets/#_29","text":"","title":"\u517c\u5bb9\u6027"},{"location":"sets/#_30","text":"\u4fdd\u6301\u4e0e\u73b0\u6709\u4ee3\u7801\u7684\u517c\u5bb9\u6027 \u652f\u6301\u65e7\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f \u6e10\u8fdb\u5f0f\u5f03\u7528\u8fc7\u65f6\u529f\u80fd","title":"\u5411\u540e\u517c\u5bb9"},{"location":"sets/#_31","text":"\u9075\u5faa C++23 \u6807\u51c6 \u4f7f\u7528\u73b0\u4ee3 C++ \u7279\u6027 \u4fdd\u6301\u8de8\u5e73\u53f0\u517c\u5bb9\u6027","title":"\u6807\u51c6\u517c\u5bb9"},{"location":"sets/#cli","text":"sets \u6a21\u5757\u5728 CLI \u4e2d\u7528\u4e8e\u89e3\u6790\u548c\u7ba1\u7406\u5185\u5b58\u626b\u63cf\u671f\u95f4\u7684\u7ed3\u679c\u96c6\u3002 scan \u548c reset \u7b49\u547d\u4ee4\u4f9d\u8d56\u6b64\u6a21\u5757\u9ad8\u6548\u5730\u5904\u7406\u96c6\u5408\u64cd\u4f5c\u3002","title":"\u4e0e CLI \u7684\u96c6\u6210"},{"location":"show_message/","text":"\u6d88\u606f\u663e\u793a\u6a21\u5757\u6587\u6863 \u6982\u8ff0 show_message \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5168\u9762\u7684\u6d88\u606f\u6253\u5370\u548c\u65e5\u5fd7\u7cfb\u7edf\u3002\u5b83\u652f\u6301\u591a\u79cd\u6d88\u606f\u7c7b\u578b\u3001\u57fa\u4e8e\u8c03\u8bd5/\u540e\u7aef\u6a21\u5f0f\u7684\u6761\u4ef6\u8f93\u51fa\uff0c\u4ee5\u53ca\u4f7f\u7528 C++20 \u683c\u5f0f\u5b57\u7b26\u4e32\u7684\u683c\u5f0f\u5316\u8f93\u51fa\u3002 \u6a21\u5757\u7ed3\u6784 export module show_message; \u4f9d\u8d56\u9879 <boost/process.hpp> - Boost \u8fdb\u7a0b\u5e93 <cstdint> - \u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b <format> - C++20 \u683c\u5f0f\u5e93 <iostream> - \u6807\u51c6 I/O \u6d41 <string_view> - \u7528\u4e8e\u9ad8\u6548\u5b57\u7b26\u4e32\u5904\u7406\u7684\u5b57\u7b26\u4e32\u89c6\u56fe \u6838\u5fc3\u529f\u80fd 1. \u6d88\u606f\u7c7b\u578b\u7cfb\u7edf enum class MessageType : uint8_t { INFO, // \u4fe1\u606f\u6d88\u606f WARN, // \u8b66\u544a\u6d88\u606f ERROR, // \u9519\u8bef\u6d88\u606f DEBUG, // \u8c03\u8bd5\u6d88\u606f\uff08\u6761\u4ef6\u6027\uff09 USER // \u9762\u5411\u7528\u6237\u7684\u6d88\u606f\uff08\u6761\u4ef6\u6027\uff09 }; 2. \u6d88\u606f\u4e0a\u4e0b\u6587 struct MessageContext { bool debugMode = false; // \u542f\u7528\u8c03\u8bd5\u8f93\u51fa bool backendMode = false; // \u6291\u5236\u7528\u6237\u8f93\u51fa }; 3. MessagePrinter \u7c7b \u6784\u9020\u51fd\u6570 MessagePrinter(MessageContext ctx = {}); \u4e3b\u8981\u6253\u5370\u65b9\u6cd5 template<typename... Args> void print(MessageType type, std::string_view fmt, Args&&... args) const; \u4fbf\u6377\u65b9\u6cd5 template<typename... Args> void info(std::string_view fmt, Args&&... args) const; template<typename... Args> void warn(std::string_view fmt, Args&&... args) const; template<typename... Args> void error(std::string_view fmt, Args&&... args) const; template<typename... Args> void debug(std::string_view fmt, Args&&... args) const; template<typename... Args> void user(std::string_view fmt, Args&&... args) const; \u4f7f\u7528\u793a\u4f8b \u57fa\u672c\u4f7f\u7528 import show_message; MessagePrinter printer; printer.info(\"\u5f00\u59cb\u5185\u5b58\u626b\u63cf\"); printer.warn(\"\u68c0\u6d4b\u5230\u5185\u5b58\u4e0d\u8db3\"); printer.error(\"\u65e0\u6cd5\u6253\u5f00\u8fdb\u7a0b\"); \u4f7f\u7528\u683c\u5f0f\u5b57\u7b26\u4e32 printer.info(\"\u6b63\u5728\u626b\u63cf PID \u4e3a {} \u7684\u8fdb\u7a0b\", pid); printer.warn(\"\u53d1\u73b0 {} \u4e2a\u53ef\u7591\u5185\u5b58\u533a\u57df\", suspicious_count); printer.error(\"\u5728\u5730\u5740 0x{:08x} \u5904\u5185\u5b58\u8bfb\u53d6\u5931\u8d25\", address); \u8c03\u8bd5\u6a21\u5f0f\u4f7f\u7528 MessageContext ctx; ctx.debugMode = true; MessagePrinter debugPrinter(ctx); debugPrinter.debug(\"\u8c03\u8bd5\u4fe1\u606f: \u5185\u5b58\u5730\u5740 0x{:x}\", address); debugPrinter.debug(\"\u5185\u90e8\u72b6\u6001: {}\", internal_state); \u540e\u7aef\u6a21\u5f0f\u4f7f\u7528 MessageContext ctx; ctx.backendMode = true; MessagePrinter backendPrinter(ctx); // \u7528\u6237\u6d88\u606f\u5c06\u88ab\u6291\u5236 backendPrinter.user(\"\u8fd9\u6761\u6d88\u606f\u4e0d\u4f1a\u663e\u793a\"); // \u4f46\u9519\u8bef\u6d88\u606f\u4ecd\u7136\u4f1a\u663e\u793a backendPrinter.error(\"\u9519\u8bef\u6d88\u606f\u4ecd\u7136\u4f1a\u663e\u793a\"); \u6d88\u606f\u7c7b\u578b\u8be6\u89e3 INFO \u6d88\u606f \u7528\u9014 : \u4e00\u822c\u4fe1\u606f\u6027\u6d88\u606f \u663e\u793a\u6761\u4ef6 : \u59cb\u7ec8\u663e\u793a \u793a\u4f8b : \u7a0b\u5e8f\u542f\u52a8\u3001\u626b\u63cf\u5b8c\u6210\u3001\u72b6\u6001\u66f4\u65b0 printer.info(\"\u5185\u5b58\u626b\u63cf\u5b8c\u6210\"); printer.info(\"\u627e\u5230 {} \u4e2a\u5339\u914d\u9879\", match_count); WARN \u6d88\u606f \u7528\u9014 : \u8b66\u544a\u4fe1\u606f\uff0c\u9700\u8981\u6ce8\u610f\u4f46\u4e0d\u81f4\u547d \u663e\u793a\u6761\u4ef6 : \u59cb\u7ec8\u663e\u793a \u793a\u4f8b : \u6027\u80fd\u8b66\u544a\u3001\u914d\u7f6e\u95ee\u9898\u3001\u975e\u5173\u952e\u9519\u8bef printer.warn(\"\u5185\u5b58\u4f7f\u7528\u7387\u8f83\u9ad8: {}%\", memory_usage); printer.warn(\"\u67d0\u4e9b\u533a\u57df\u65e0\u6cd5\u8bbf\u95ee\"); ERROR \u6d88\u606f \u7528\u9014 : \u9519\u8bef\u4fe1\u606f\uff0c\u8868\u793a\u64cd\u4f5c\u5931\u8d25 \u663e\u793a\u6761\u4ef6 : \u59cb\u7ec8\u663e\u793a \u793a\u4f8b : \u6587\u4ef6\u6253\u5f00\u5931\u8d25\u3001\u6743\u9650\u9519\u8bef\u3001\u7cfb\u7edf\u9519\u8bef printer.error(\"\u65e0\u6cd5\u6253\u5f00\u8fdb\u7a0b: {}\", error_message); printer.error(\"\u5185\u5b58\u8bfb\u53d6\u5931\u8d25: {}\", strerror(errno)); DEBUG \u6d88\u606f \u7528\u9014 : \u8c03\u8bd5\u4fe1\u606f\uff0c\u7528\u4e8e\u5f00\u53d1\u8c03\u8bd5 \u663e\u793a\u6761\u4ef6 : \u4ec5\u5728 debugMode = true \u65f6\u663e\u793a \u793a\u4f8b : \u5185\u90e8\u72b6\u6001\u3001\u8be6\u7ec6\u6267\u884c\u6d41\u7a0b\u3001\u6027\u80fd\u6570\u636e printer.debug(\"\u5185\u90e8\u72b6\u6001: {}\", internal_state); printer.debug(\"\u6267\u884c\u65f6\u95f4: {} ms\", execution_time); USER \u6d88\u606f \u7528\u9014 : \u9762\u5411\u7528\u6237\u7684\u6d88\u606f \u663e\u793a\u6761\u4ef6 : \u4ec5\u5728 backendMode = false \u65f6\u663e\u793a \u793a\u4f8b : \u7528\u6237\u63d0\u793a\u3001\u8fdb\u5ea6\u4fe1\u606f\u3001\u4ea4\u4e92\u6d88\u606f printer.user(\"\u8bf7\u8f93\u5165\u76ee\u6807\u8fdb\u7a0b ID:\"); printer.user(\"\u626b\u63cf\u8fdb\u5ea6: {}%\", progress); \u683c\u5f0f\u5316\u529f\u80fd C++20 \u683c\u5f0f\u5b57\u7b26\u4e32 \u652f\u6301\u5b8c\u6574\u7684 C++20 \u683c\u5f0f\u5b57\u7b26\u4e32\u529f\u80fd\uff1a // \u6574\u6570\u683c\u5f0f\u5316 printer.info(\"\u8fdb\u7a0b ID: {}\", pid); printer.info(\"\u5730\u5740: 0x{:08x}\", address); // \u6d6e\u70b9\u6570\u683c\u5f0f\u5316 printer.info(\"\u5185\u5b58\u4f7f\u7528\u7387: {:.2f}%\", memory_usage); // \u5b57\u7b26\u4e32\u683c\u5f0f\u5316 printer.info(\"\u6587\u4ef6\u540d: {}\", filename); // \u590d\u6742\u683c\u5f0f\u5316 printer.info(\"\u626b\u63cf\u7ed3\u679c: {} \u4e2a\u5339\u914d\u9879\uff0c\u8017\u65f6 {:.3f} \u79d2\", match_count, elapsed_time); \u7c7b\u578b\u5b89\u5168 \u7f16\u8bd1\u65f6\u7c7b\u578b\u68c0\u67e5 \u81ea\u52a8\u7c7b\u578b\u63a8\u5bfc \u9632\u6b62\u683c\u5f0f\u5316\u9519\u8bef \u4e0a\u4e0b\u6587\u7ba1\u7406 \u5168\u5c40\u4e0a\u4e0b\u6587 // \u521b\u5efa\u5168\u5c40\u6d88\u606f\u6253\u5370\u673a MessageContext globalContext; globalContext.debugMode = true; MessagePrinter globalPrinter(globalContext); \u5c40\u90e8\u4e0a\u4e0b\u6587 void someFunction() { MessageContext localContext; localContext.backendMode = true; MessagePrinter localPrinter(localContext); // \u4f7f\u7528\u5c40\u90e8\u6253\u5370\u673a localPrinter.info(\"\u5c40\u90e8\u6d88\u606f\"); } \u4e0a\u4e0b\u6587\u7ee7\u627f class MyClass { private: MessagePrinter m_printer; public: MyClass(MessageContext ctx) : m_printer(ctx) {} void doSomething() { m_printer.info(\"\u7c7b\u5185\u90e8\u6d88\u606f\"); } }; \u6027\u80fd\u8003\u8651 \u7f16\u8bd1\u65f6\u4f18\u5316 \u6a21\u677f\u5b9e\u4f8b\u5316\u4f18\u5316 \u5185\u8054\u51fd\u6570\u8c03\u7528 \u6761\u4ef6\u7f16\u8bd1 \u8fd0\u884c\u65f6\u4f18\u5316 \u5b57\u7b26\u4e32\u89c6\u56fe\u907f\u514d\u62f7\u8d1d \u683c\u5f0f\u5316\u53c2\u6570\u5b8c\u7f8e\u8f6c\u53d1 \u6700\u5c0f\u5316\u5185\u5b58\u5206\u914d \u8f93\u51fa\u63a7\u5236 \u6761\u4ef6\u8f93\u51fa\u51cf\u5c11 I/O \u5f00\u9500 \u8c03\u8bd5\u6a21\u5f0f\u53ef\u5b8c\u5168\u7981\u7528 \u540e\u7aef\u6a21\u5f0f\u6291\u5236\u7528\u6237\u8f93\u51fa \u9519\u8bef\u5904\u7406 \u683c\u5f0f\u5316\u9519\u8bef \u7f16\u8bd1\u65f6\u68c0\u67e5\u683c\u5f0f\u5b57\u7b26\u4e32 \u8fd0\u884c\u65f6\u9a8c\u8bc1\u53c2\u6570\u7c7b\u578b \u4f18\u96c5\u7684\u9519\u8bef\u5904\u7406 \u8f93\u51fa\u9519\u8bef \u68c0\u67e5\u8f93\u51fa\u6d41\u72b6\u6001 \u5904\u7406\u5199\u5165\u5931\u8d25 \u63d0\u4f9b\u9519\u8bef\u53cd\u9988 \u6269\u5c55\u6027 \u81ea\u5b9a\u4e49\u6d88\u606f\u7c7b\u578b enum class CustomMessageType : uint8_t { VERBOSE, // \u8be6\u7ec6\u8f93\u51fa TRACE, // \u8ddf\u8e2a\u4fe1\u606f // ... \u5176\u4ed6\u7c7b\u578b }; \u81ea\u5b9a\u4e49\u8f93\u51fa\u76ee\u6807 class CustomPrinter : public MessagePrinter { public: void print(MessageType type, std::string_view fmt, auto&&... args) const override { // \u81ea\u5b9a\u4e49\u8f93\u51fa\u903b\u8f91 } }; \u65e5\u5fd7\u6587\u4ef6\u652f\u6301 class FileLogger { private: std::ofstream m_logFile; MessagePrinter m_printer; public: FileLogger(const std::string& filename) : m_logFile(filename) { // \u914d\u7f6e\u6587\u4ef6\u8f93\u51fa } void log(MessageType type, std::string_view fmt, auto&&... args) { // \u5199\u5165\u6587\u4ef6 m_printer.print(type, fmt, std::forward<decltype(args)>(args)...); } };","title":"\u663e\u793a\u6d88\u606f"},{"location":"show_message/#_1","text":"","title":"\u6d88\u606f\u663e\u793a\u6a21\u5757\u6587\u6863"},{"location":"show_message/#_2","text":"show_message \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5168\u9762\u7684\u6d88\u606f\u6253\u5370\u548c\u65e5\u5fd7\u7cfb\u7edf\u3002\u5b83\u652f\u6301\u591a\u79cd\u6d88\u606f\u7c7b\u578b\u3001\u57fa\u4e8e\u8c03\u8bd5/\u540e\u7aef\u6a21\u5f0f\u7684\u6761\u4ef6\u8f93\u51fa\uff0c\u4ee5\u53ca\u4f7f\u7528 C++20 \u683c\u5f0f\u5b57\u7b26\u4e32\u7684\u683c\u5f0f\u5316\u8f93\u51fa\u3002","title":"\u6982\u8ff0"},{"location":"show_message/#_3","text":"export module show_message;","title":"\u6a21\u5757\u7ed3\u6784"},{"location":"show_message/#_4","text":"<boost/process.hpp> - Boost \u8fdb\u7a0b\u5e93 <cstdint> - \u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b <format> - C++20 \u683c\u5f0f\u5e93 <iostream> - \u6807\u51c6 I/O \u6d41 <string_view> - \u7528\u4e8e\u9ad8\u6548\u5b57\u7b26\u4e32\u5904\u7406\u7684\u5b57\u7b26\u4e32\u89c6\u56fe","title":"\u4f9d\u8d56\u9879"},{"location":"show_message/#_5","text":"","title":"\u6838\u5fc3\u529f\u80fd"},{"location":"show_message/#1","text":"enum class MessageType : uint8_t { INFO, // \u4fe1\u606f\u6d88\u606f WARN, // \u8b66\u544a\u6d88\u606f ERROR, // \u9519\u8bef\u6d88\u606f DEBUG, // \u8c03\u8bd5\u6d88\u606f\uff08\u6761\u4ef6\u6027\uff09 USER // \u9762\u5411\u7528\u6237\u7684\u6d88\u606f\uff08\u6761\u4ef6\u6027\uff09 };","title":"1. \u6d88\u606f\u7c7b\u578b\u7cfb\u7edf"},{"location":"show_message/#2","text":"struct MessageContext { bool debugMode = false; // \u542f\u7528\u8c03\u8bd5\u8f93\u51fa bool backendMode = false; // \u6291\u5236\u7528\u6237\u8f93\u51fa };","title":"2. \u6d88\u606f\u4e0a\u4e0b\u6587"},{"location":"show_message/#3-messageprinter","text":"","title":"3. MessagePrinter \u7c7b"},{"location":"show_message/#_6","text":"MessagePrinter(MessageContext ctx = {});","title":"\u6784\u9020\u51fd\u6570"},{"location":"show_message/#_7","text":"template<typename... Args> void print(MessageType type, std::string_view fmt, Args&&... args) const;","title":"\u4e3b\u8981\u6253\u5370\u65b9\u6cd5"},{"location":"show_message/#_8","text":"template<typename... Args> void info(std::string_view fmt, Args&&... args) const; template<typename... Args> void warn(std::string_view fmt, Args&&... args) const; template<typename... Args> void error(std::string_view fmt, Args&&... args) const; template<typename... Args> void debug(std::string_view fmt, Args&&... args) const; template<typename... Args> void user(std::string_view fmt, Args&&... args) const;","title":"\u4fbf\u6377\u65b9\u6cd5"},{"location":"show_message/#_9","text":"","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"show_message/#_10","text":"import show_message; MessagePrinter printer; printer.info(\"\u5f00\u59cb\u5185\u5b58\u626b\u63cf\"); printer.warn(\"\u68c0\u6d4b\u5230\u5185\u5b58\u4e0d\u8db3\"); printer.error(\"\u65e0\u6cd5\u6253\u5f00\u8fdb\u7a0b\");","title":"\u57fa\u672c\u4f7f\u7528"},{"location":"show_message/#_11","text":"printer.info(\"\u6b63\u5728\u626b\u63cf PID \u4e3a {} \u7684\u8fdb\u7a0b\", pid); printer.warn(\"\u53d1\u73b0 {} \u4e2a\u53ef\u7591\u5185\u5b58\u533a\u57df\", suspicious_count); printer.error(\"\u5728\u5730\u5740 0x{:08x} \u5904\u5185\u5b58\u8bfb\u53d6\u5931\u8d25\", address);","title":"\u4f7f\u7528\u683c\u5f0f\u5b57\u7b26\u4e32"},{"location":"show_message/#_12","text":"MessageContext ctx; ctx.debugMode = true; MessagePrinter debugPrinter(ctx); debugPrinter.debug(\"\u8c03\u8bd5\u4fe1\u606f: \u5185\u5b58\u5730\u5740 0x{:x}\", address); debugPrinter.debug(\"\u5185\u90e8\u72b6\u6001: {}\", internal_state);","title":"\u8c03\u8bd5\u6a21\u5f0f\u4f7f\u7528"},{"location":"show_message/#_13","text":"MessageContext ctx; ctx.backendMode = true; MessagePrinter backendPrinter(ctx); // \u7528\u6237\u6d88\u606f\u5c06\u88ab\u6291\u5236 backendPrinter.user(\"\u8fd9\u6761\u6d88\u606f\u4e0d\u4f1a\u663e\u793a\"); // \u4f46\u9519\u8bef\u6d88\u606f\u4ecd\u7136\u4f1a\u663e\u793a backendPrinter.error(\"\u9519\u8bef\u6d88\u606f\u4ecd\u7136\u4f1a\u663e\u793a\");","title":"\u540e\u7aef\u6a21\u5f0f\u4f7f\u7528"},{"location":"show_message/#_14","text":"","title":"\u6d88\u606f\u7c7b\u578b\u8be6\u89e3"},{"location":"show_message/#info","text":"\u7528\u9014 : \u4e00\u822c\u4fe1\u606f\u6027\u6d88\u606f \u663e\u793a\u6761\u4ef6 : \u59cb\u7ec8\u663e\u793a \u793a\u4f8b : \u7a0b\u5e8f\u542f\u52a8\u3001\u626b\u63cf\u5b8c\u6210\u3001\u72b6\u6001\u66f4\u65b0 printer.info(\"\u5185\u5b58\u626b\u63cf\u5b8c\u6210\"); printer.info(\"\u627e\u5230 {} \u4e2a\u5339\u914d\u9879\", match_count);","title":"INFO \u6d88\u606f"},{"location":"show_message/#warn","text":"\u7528\u9014 : \u8b66\u544a\u4fe1\u606f\uff0c\u9700\u8981\u6ce8\u610f\u4f46\u4e0d\u81f4\u547d \u663e\u793a\u6761\u4ef6 : \u59cb\u7ec8\u663e\u793a \u793a\u4f8b : \u6027\u80fd\u8b66\u544a\u3001\u914d\u7f6e\u95ee\u9898\u3001\u975e\u5173\u952e\u9519\u8bef printer.warn(\"\u5185\u5b58\u4f7f\u7528\u7387\u8f83\u9ad8: {}%\", memory_usage); printer.warn(\"\u67d0\u4e9b\u533a\u57df\u65e0\u6cd5\u8bbf\u95ee\");","title":"WARN \u6d88\u606f"},{"location":"show_message/#error","text":"\u7528\u9014 : \u9519\u8bef\u4fe1\u606f\uff0c\u8868\u793a\u64cd\u4f5c\u5931\u8d25 \u663e\u793a\u6761\u4ef6 : \u59cb\u7ec8\u663e\u793a \u793a\u4f8b : \u6587\u4ef6\u6253\u5f00\u5931\u8d25\u3001\u6743\u9650\u9519\u8bef\u3001\u7cfb\u7edf\u9519\u8bef printer.error(\"\u65e0\u6cd5\u6253\u5f00\u8fdb\u7a0b: {}\", error_message); printer.error(\"\u5185\u5b58\u8bfb\u53d6\u5931\u8d25: {}\", strerror(errno));","title":"ERROR \u6d88\u606f"},{"location":"show_message/#debug","text":"\u7528\u9014 : \u8c03\u8bd5\u4fe1\u606f\uff0c\u7528\u4e8e\u5f00\u53d1\u8c03\u8bd5 \u663e\u793a\u6761\u4ef6 : \u4ec5\u5728 debugMode = true \u65f6\u663e\u793a \u793a\u4f8b : \u5185\u90e8\u72b6\u6001\u3001\u8be6\u7ec6\u6267\u884c\u6d41\u7a0b\u3001\u6027\u80fd\u6570\u636e printer.debug(\"\u5185\u90e8\u72b6\u6001: {}\", internal_state); printer.debug(\"\u6267\u884c\u65f6\u95f4: {} ms\", execution_time);","title":"DEBUG \u6d88\u606f"},{"location":"show_message/#user","text":"\u7528\u9014 : \u9762\u5411\u7528\u6237\u7684\u6d88\u606f \u663e\u793a\u6761\u4ef6 : \u4ec5\u5728 backendMode = false \u65f6\u663e\u793a \u793a\u4f8b : \u7528\u6237\u63d0\u793a\u3001\u8fdb\u5ea6\u4fe1\u606f\u3001\u4ea4\u4e92\u6d88\u606f printer.user(\"\u8bf7\u8f93\u5165\u76ee\u6807\u8fdb\u7a0b ID:\"); printer.user(\"\u626b\u63cf\u8fdb\u5ea6: {}%\", progress);","title":"USER \u6d88\u606f"},{"location":"show_message/#_15","text":"","title":"\u683c\u5f0f\u5316\u529f\u80fd"},{"location":"show_message/#c20","text":"\u652f\u6301\u5b8c\u6574\u7684 C++20 \u683c\u5f0f\u5b57\u7b26\u4e32\u529f\u80fd\uff1a // \u6574\u6570\u683c\u5f0f\u5316 printer.info(\"\u8fdb\u7a0b ID: {}\", pid); printer.info(\"\u5730\u5740: 0x{:08x}\", address); // \u6d6e\u70b9\u6570\u683c\u5f0f\u5316 printer.info(\"\u5185\u5b58\u4f7f\u7528\u7387: {:.2f}%\", memory_usage); // \u5b57\u7b26\u4e32\u683c\u5f0f\u5316 printer.info(\"\u6587\u4ef6\u540d: {}\", filename); // \u590d\u6742\u683c\u5f0f\u5316 printer.info(\"\u626b\u63cf\u7ed3\u679c: {} \u4e2a\u5339\u914d\u9879\uff0c\u8017\u65f6 {:.3f} \u79d2\", match_count, elapsed_time);","title":"C++20 \u683c\u5f0f\u5b57\u7b26\u4e32"},{"location":"show_message/#_16","text":"\u7f16\u8bd1\u65f6\u7c7b\u578b\u68c0\u67e5 \u81ea\u52a8\u7c7b\u578b\u63a8\u5bfc \u9632\u6b62\u683c\u5f0f\u5316\u9519\u8bef","title":"\u7c7b\u578b\u5b89\u5168"},{"location":"show_message/#_17","text":"","title":"\u4e0a\u4e0b\u6587\u7ba1\u7406"},{"location":"show_message/#_18","text":"// \u521b\u5efa\u5168\u5c40\u6d88\u606f\u6253\u5370\u673a MessageContext globalContext; globalContext.debugMode = true; MessagePrinter globalPrinter(globalContext);","title":"\u5168\u5c40\u4e0a\u4e0b\u6587"},{"location":"show_message/#_19","text":"void someFunction() { MessageContext localContext; localContext.backendMode = true; MessagePrinter localPrinter(localContext); // \u4f7f\u7528\u5c40\u90e8\u6253\u5370\u673a localPrinter.info(\"\u5c40\u90e8\u6d88\u606f\"); }","title":"\u5c40\u90e8\u4e0a\u4e0b\u6587"},{"location":"show_message/#_20","text":"class MyClass { private: MessagePrinter m_printer; public: MyClass(MessageContext ctx) : m_printer(ctx) {} void doSomething() { m_printer.info(\"\u7c7b\u5185\u90e8\u6d88\u606f\"); } };","title":"\u4e0a\u4e0b\u6587\u7ee7\u627f"},{"location":"show_message/#_21","text":"","title":"\u6027\u80fd\u8003\u8651"},{"location":"show_message/#_22","text":"\u6a21\u677f\u5b9e\u4f8b\u5316\u4f18\u5316 \u5185\u8054\u51fd\u6570\u8c03\u7528 \u6761\u4ef6\u7f16\u8bd1","title":"\u7f16\u8bd1\u65f6\u4f18\u5316"},{"location":"show_message/#_23","text":"\u5b57\u7b26\u4e32\u89c6\u56fe\u907f\u514d\u62f7\u8d1d \u683c\u5f0f\u5316\u53c2\u6570\u5b8c\u7f8e\u8f6c\u53d1 \u6700\u5c0f\u5316\u5185\u5b58\u5206\u914d","title":"\u8fd0\u884c\u65f6\u4f18\u5316"},{"location":"show_message/#_24","text":"\u6761\u4ef6\u8f93\u51fa\u51cf\u5c11 I/O \u5f00\u9500 \u8c03\u8bd5\u6a21\u5f0f\u53ef\u5b8c\u5168\u7981\u7528 \u540e\u7aef\u6a21\u5f0f\u6291\u5236\u7528\u6237\u8f93\u51fa","title":"\u8f93\u51fa\u63a7\u5236"},{"location":"show_message/#_25","text":"","title":"\u9519\u8bef\u5904\u7406"},{"location":"show_message/#_26","text":"\u7f16\u8bd1\u65f6\u68c0\u67e5\u683c\u5f0f\u5b57\u7b26\u4e32 \u8fd0\u884c\u65f6\u9a8c\u8bc1\u53c2\u6570\u7c7b\u578b \u4f18\u96c5\u7684\u9519\u8bef\u5904\u7406","title":"\u683c\u5f0f\u5316\u9519\u8bef"},{"location":"show_message/#_27","text":"\u68c0\u67e5\u8f93\u51fa\u6d41\u72b6\u6001 \u5904\u7406\u5199\u5165\u5931\u8d25 \u63d0\u4f9b\u9519\u8bef\u53cd\u9988","title":"\u8f93\u51fa\u9519\u8bef"},{"location":"show_message/#_28","text":"","title":"\u6269\u5c55\u6027"},{"location":"show_message/#_29","text":"enum class CustomMessageType : uint8_t { VERBOSE, // \u8be6\u7ec6\u8f93\u51fa TRACE, // \u8ddf\u8e2a\u4fe1\u606f // ... \u5176\u4ed6\u7c7b\u578b };","title":"\u81ea\u5b9a\u4e49\u6d88\u606f\u7c7b\u578b"},{"location":"show_message/#_30","text":"class CustomPrinter : public MessagePrinter { public: void print(MessageType type, std::string_view fmt, auto&&... args) const override { // \u81ea\u5b9a\u4e49\u8f93\u51fa\u903b\u8f91 } };","title":"\u81ea\u5b9a\u4e49\u8f93\u51fa\u76ee\u6807"},{"location":"show_message/#_31","text":"class FileLogger { private: std::ofstream m_logFile; MessagePrinter m_printer; public: FileLogger(const std::string& filename) : m_logFile(filename) { // \u914d\u7f6e\u6587\u4ef6\u8f93\u51fa } void log(MessageType type, std::string_view fmt, auto&&... args) { // \u5199\u5165\u6587\u4ef6 m_printer.print(type, fmt, std::forward<decltype(args)>(args)...); } };","title":"\u65e5\u5fd7\u6587\u4ef6\u652f\u6301"},{"location":"target_mem/","text":"\u76ee\u6807\u5185\u5b58\u6a21\u5757\u6587\u6863 \u6982\u8ff0 targetmem \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5185\u5b58\u5339\u914d\u548c\u5206\u6790\u7ed3\u6784\u3002\u5b83\u5305\u62ec\u7528\u4e8e\u7ba1\u7406\u5185\u5b58\u5339\u914d\u3001\u5b58\u50a8\u65e7\u503c\u4ee5\u53ca\u6267\u884c\u5185\u5b58\u533a\u57df\u64cd\u4f5c\u7684\u7c7b\uff0c\u652f\u6301\u9ad8\u6548\u7684\u641c\u7d22\u548c\u64cd\u4f5c\u3002 \u6a21\u5757\u7ed3\u6784 export module targetmem; \u4f9d\u8d56\u9879 <algorithm> - \u6807\u51c6\u7b97\u6cd5 <cassert> - \u65ad\u8a00\u5b8f <cctype> - \u5b57\u7b26\u5206\u7c7b <cstddef> - \u5927\u5c0f\u7c7b\u578b\u5b9a\u4e49 <cstdint> - \u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b <cstdio> - C \u6807\u51c6 I/O <cstdlib> - C \u6807\u51c6\u5e93 <cstring> - C \u5b57\u7b26\u4e32\u64cd\u4f5c <optional> - \u53ef\u9009\u7c7b\u578b\u652f\u6301 <sstream> - \u5b57\u7b26\u4e32\u6d41\u64cd\u4f5c <string> - \u5b57\u7b26\u4e32\u64cd\u4f5c <vector> - \u52a8\u6001\u6570\u7ec4\u5bb9\u5668 value \u6a21\u5757 - \u503c\u7c7b\u578b\u5b9a\u4e49 show_message \u6a21\u5757 - \u6d88\u606f\u6253\u5370\u7cfb\u7edf \u6838\u5fc3\u529f\u80fd 1. \u5185\u5b58\u5339\u914d\u6807\u5fd7 \u4f7f\u7528\u6765\u81ea value \u6a21\u5757\u7684 MatchFlags \u6765\u6307\u793a\u5185\u5b58\u5339\u914d\u7684\u7c7b\u578b\u548c\u72b6\u6001\u3002 2. OldValueAndMatchInfo \u7ed3\u6784 struct OldValueAndMatchInfo { uint8_t old_value; // \u539f\u59cb\u5b57\u8282\u503c MatchFlags match_info; // \u5339\u914d\u7c7b\u578b\u548c\u72b6\u6001\u6807\u5fd7 }; 3. MatchesAndOldValuesSwath \u7c7b \u8868\u793a\u5177\u6709\u5339\u914d\u4fe1\u606f\u7684\u8fde\u7eed\u5185\u5b58\u533a\u57df\u3002 class MatchesAndOldValuesSwath { public: void* firstByteInChild = nullptr; // \u8d77\u59cb\u5730\u5740 std::vector<OldValueAndMatchInfo> data; // \u5339\u914d\u6570\u636e // \u6784\u9020\u51fd\u6570 MatchesAndOldValuesSwath() = default; // \u5143\u7d20\u7ba1\u7406 void addElement(void* addr, uint8_t byte, MatchFlags matchFlags); // \u5b57\u7b26\u4e32\u8868\u793a\u5de5\u5177 std::string toPrintableString(size_t idx, size_t len) const; std::string toByteArrayText(size_t idx, size_t len) const; }; \u65b9\u6cd5 addElement(void* addr, uint8_t byte, MatchFlags matchFlags) \u5411 swath \u6dfb\u52a0\u65b0\u7684\u5185\u5b58\u5339\u914d\u3002 \u53c2\u6570\uff1a addr : \u5339\u914d\u7684\u5185\u5b58\u5730\u5740 byte : \u6b64\u5730\u5740\u7684\u5b57\u8282\u503c matchFlags : \u5339\u914d\u7c7b\u578b\u548c\u6807\u5fd7 toPrintableString(size_t idx, size_t len) \u5c06\u5185\u5b58\u5b57\u8282\u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u7684 ASCII \u5b57\u7b26\u4e32\u3002 \u53c2\u6570\uff1a idx : \u6570\u636e\u5411\u91cf\u4e2d\u7684\u8d77\u59cb\u7d22\u5f15 len : \u8981\u8f6c\u6362\u7684\u5b57\u8282\u6570 \u8fd4\u56de\uff1a \u53ef\u6253\u5370\u5b57\u7b26\u4e32\uff0c\u4e0d\u53ef\u6253\u5370\u5b57\u7b26\u663e\u793a\u4e3a '.' toByteArrayText(size_t idx, size_t len) \u5c06\u5185\u5b58\u5b57\u8282\u8f6c\u6362\u4e3a\u5341\u516d\u8fdb\u5236\u6587\u672c\u8868\u793a\u3002 \u53c2\u6570\uff1a idx : \u6570\u636e\u5411\u91cf\u4e2d\u7684\u8d77\u59cb\u7d22\u5f15 len : \u8981\u8f6c\u6362\u7684\u5b57\u8282\u6570 \u8fd4\u56de\uff1a \u7a7a\u683c\u5206\u9694\u7684\u5341\u516d\u8fdb\u5236\u503c 4. MatchesAndOldValuesArray \u7c7b \u7ba1\u7406\u591a\u4e2a swath \u5e76\u63d0\u4f9b\u641c\u7d22\u64cd\u4f5c\u3002 class MatchesAndOldValuesArray { public: std::vector<MatchesAndOldValuesSwath> swaths; // \u5185\u5b58\u533a\u57df\u96c6\u5408 // \u6784\u9020\u51fd\u6570 MatchesAndOldValuesArray() = default; // \u641c\u7d22\u64cd\u4f5c std::optional<size_t> findSwathIndex(void* addr) const; std::optional<size_t> findElementIndex(void* addr) const; // \u6570\u636e\u8bbf\u95ee const OldValueAndMatchInfo* getElement(void* addr) const; OldValueAndMatchInfo* getElement(void* addr); // \u5185\u5b58\u7ba1\u7406 void clear(); size_t size() const; }; MatchesAndOldValuesArray\u65b9\u6cd5 findSwathIndex(void* addr) const \u67e5\u627e\u5305\u542b\u6307\u5b9a\u5730\u5740\u7684 swath \u7d22\u5f15\u3002 \u53c2\u6570\uff1a addr : \u8981\u67e5\u627e\u7684\u5185\u5b58\u5730\u5740 \u8fd4\u56de\uff1a \u5305\u542b\u8be5\u5730\u5740\u7684 swath \u7d22\u5f15\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de std::nullopt findElementIndex(void* addr) const \u67e5\u627e\u6307\u5b9a\u5730\u5740\u5728 swath \u4e2d\u7684\u5143\u7d20\u7d22\u5f15\u3002 \u53c2\u6570\uff1a addr : \u8981\u67e5\u627e\u7684\u5185\u5b58\u5730\u5740 \u8fd4\u56de\uff1a \u5143\u7d20\u5728 swath \u4e2d\u7684\u7d22\u5f15\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de std::nullopt getElement(void* addr) \u83b7\u53d6\u6307\u5b9a\u5730\u5740\u7684\u5143\u7d20\u6570\u636e\u3002 \u53c2\u6570\uff1a addr : \u5185\u5b58\u5730\u5740 \u8fd4\u56de\uff1a \u6307\u5411 OldValueAndMatchInfo \u7684\u6307\u9488\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de nullptr \u4f7f\u7528\u793a\u4f8b \u57fa\u672c\u4f7f\u7528 import targetmem; // \u521b\u5efa\u5185\u5b58\u5339\u914d\u6570\u7ec4 MatchesAndOldValuesArray matches; // \u6dfb\u52a0\u5185\u5b58\u5339\u914d void* addr1 = (void*)0x1000; void* addr2 = (void*)0x1001; MatchesAndOldValuesSwath swath; swath.addElement(addr1, 0x42, MatchFlags::EXACT_MATCH); swath.addElement(addr2, 0x7F, MatchFlags::GREATER_THAN); matches.swaths.push_back(swath); \u641c\u7d22\u64cd\u4f5c // \u67e5\u627e\u5305\u542b\u5730\u5740\u7684 swath auto swathIndex = matches.findSwathIndex(addr1); if (swathIndex) { std::cout << \"\u627e\u5230 swath \u7d22\u5f15: \" << *swathIndex << std::endl; } // \u67e5\u627e\u5143\u7d20\u7d22\u5f15 auto elementIndex = matches.findElementIndex(addr1); if (elementIndex) { std::cout << \"\u627e\u5230\u5143\u7d20\u7d22\u5f15: \" << *elementIndex << std::endl; } // \u83b7\u53d6\u5143\u7d20\u6570\u636e const auto* element = matches.getElement(addr1); if (element) { std::cout << \"\u65e7\u503c: 0x\" << std::hex << (int)element->old_value << std::endl; } \u5b57\u7b26\u4e32\u8868\u793a // \u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u5b57\u7b26\u4e32 std::string printable = swath.toPrintableString(0, 10); std::cout << \"\u53ef\u6253\u5370\u5b57\u7b26\u4e32: \" << printable << std::endl; // \u8f6c\u6362\u4e3a\u5b57\u8282\u6570\u7ec4\u6587\u672c std::string byteArray = swath.toByteArrayText(0, 10); std::cout << \"\u5b57\u8282\u6570\u7ec4: \" << byteArray << std::endl; \u5185\u5b58\u7ba1\u7406 \u5185\u5b58\u5e03\u5c40 \u6bcf\u4e2a MatchesAndOldValuesSwath \u8868\u793a\u4e00\u4e2a\u8fde\u7eed\u7684\u5185\u5b58\u533a\u57df\uff1a +----------------+----------------+----------------+ | \u5730\u5740 0x1000 | \u5730\u5740 0x1001 | \u5730\u5740 0x1002 | | \u65e7\u503c: 0x42 | \u65e7\u503c: 0x7F | \u65e7\u503c: 0xAA | | \u6807\u5fd7: EXACT | \u6807\u5fd7: GREATER | \u6807\u5fd7: LESS | +----------------+----------------+----------------+ \u5185\u5b58\u5bf9\u9f50 \u5730\u5740\u6309\u5b57\u8282\u5bf9\u9f50 \u6570\u636e\u7ed3\u6784\u7d27\u51d1\u5b58\u50a8 \u652f\u6301\u8de8\u5e73\u53f0\u5185\u5b58\u5e03\u5c40 \u5185\u5b58\u5b89\u5168 \u8fb9\u754c\u68c0\u67e5\u9632\u6b62\u8d8a\u754c\u8bbf\u95ee \u7a7a\u6307\u9488\u68c0\u67e5 \u5f02\u5e38\u5b89\u5168\u4fdd\u8bc1 \u6027\u80fd\u4f18\u5316 \u641c\u7d22\u4f18\u5316 \u4e8c\u5206\u641c\u7d22 : \u5728\u6709\u5e8f swath \u4e2d\u4f7f\u7528\u4e8c\u5206\u641c\u7d22 \u5730\u5740\u8303\u56f4\u68c0\u67e5 : \u5feb\u901f\u8fc7\u6ee4\u4e0d\u76f8\u5173\u7684 swath \u7f13\u5b58\u53cb\u597d : \u8fde\u7eed\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f \u5185\u5b58\u4f7f\u7528 \u7d27\u51d1\u5b58\u50a8 : \u6700\u5c0f\u5316\u5185\u5b58\u5360\u7528 \u52a8\u6001\u589e\u957f : \u6309\u9700\u5206\u914d\u5185\u5b58 \u5185\u5b58\u6c60 : \u51cf\u5c11\u5206\u914d\u5f00\u9500 \u7b97\u6cd5\u590d\u6742\u5ea6 \u67e5\u627e swath : O(log n) \u5176\u4e2d n \u662f swath \u6570\u91cf \u67e5\u627e\u5143\u7d20 : O(log m) \u5176\u4e2d m \u662f swath \u4e2d\u7684\u5143\u7d20\u6570\u91cf \u6dfb\u52a0\u5143\u7d20 : O(1) \u5e73\u5747\u60c5\u51b5 \u9519\u8bef\u5904\u7406 \u5e38\u89c1\u9519\u8bef \u65e0\u6548\u5730\u5740 : \u7a7a\u6307\u9488\u6216\u65e0\u6548\u5185\u5b58\u5730\u5740 \u8d8a\u754c\u8bbf\u95ee : \u8bbf\u95ee\u8d85\u51fa\u8303\u56f4\u7684\u7d22\u5f15 \u5185\u5b58\u4e0d\u8db3 : \u5206\u914d\u5931\u8d25 \u9519\u8bef\u5904\u7406\u7b56\u7565 \u4f7f\u7528 std::optional \u8868\u793a\u67e5\u627e\u5931\u8d25 \u8fd4\u56de nullptr \u8868\u793a\u65e0\u6548\u8bbf\u95ee \u629b\u51fa\u5f02\u5e38\u5904\u7406\u4e25\u91cd\u9519\u8bef \u6269\u5c55\u6027 \u81ea\u5b9a\u4e49\u5339\u914d\u7c7b\u578b enum class CustomMatchFlags : uint8_t { CUSTOM_MATCH_1, CUSTOM_MATCH_2, // ... \u5176\u4ed6\u7c7b\u578b }; \u81ea\u5b9a\u4e49\u6570\u636e\u7ed3\u6784 struct CustomMatchInfo { uint8_t old_value; CustomMatchFlags flags; std::string additional_info; }; \u63d2\u4ef6\u652f\u6301 class MatchPlugin { public: virtual bool processMatch(void* addr, uint8_t value) = 0; virtual std::string getDescription() const = 0; };","title":"\u76ee\u6807\u5185\u5b58"},{"location":"target_mem/#_1","text":"","title":"\u76ee\u6807\u5185\u5b58\u6a21\u5757\u6587\u6863"},{"location":"target_mem/#_2","text":"targetmem \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5185\u5b58\u5339\u914d\u548c\u5206\u6790\u7ed3\u6784\u3002\u5b83\u5305\u62ec\u7528\u4e8e\u7ba1\u7406\u5185\u5b58\u5339\u914d\u3001\u5b58\u50a8\u65e7\u503c\u4ee5\u53ca\u6267\u884c\u5185\u5b58\u533a\u57df\u64cd\u4f5c\u7684\u7c7b\uff0c\u652f\u6301\u9ad8\u6548\u7684\u641c\u7d22\u548c\u64cd\u4f5c\u3002","title":"\u6982\u8ff0"},{"location":"target_mem/#_3","text":"export module targetmem;","title":"\u6a21\u5757\u7ed3\u6784"},{"location":"target_mem/#_4","text":"<algorithm> - \u6807\u51c6\u7b97\u6cd5 <cassert> - \u65ad\u8a00\u5b8f <cctype> - \u5b57\u7b26\u5206\u7c7b <cstddef> - \u5927\u5c0f\u7c7b\u578b\u5b9a\u4e49 <cstdint> - \u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b <cstdio> - C \u6807\u51c6 I/O <cstdlib> - C \u6807\u51c6\u5e93 <cstring> - C \u5b57\u7b26\u4e32\u64cd\u4f5c <optional> - \u53ef\u9009\u7c7b\u578b\u652f\u6301 <sstream> - \u5b57\u7b26\u4e32\u6d41\u64cd\u4f5c <string> - \u5b57\u7b26\u4e32\u64cd\u4f5c <vector> - \u52a8\u6001\u6570\u7ec4\u5bb9\u5668 value \u6a21\u5757 - \u503c\u7c7b\u578b\u5b9a\u4e49 show_message \u6a21\u5757 - \u6d88\u606f\u6253\u5370\u7cfb\u7edf","title":"\u4f9d\u8d56\u9879"},{"location":"target_mem/#_5","text":"","title":"\u6838\u5fc3\u529f\u80fd"},{"location":"target_mem/#1","text":"\u4f7f\u7528\u6765\u81ea value \u6a21\u5757\u7684 MatchFlags \u6765\u6307\u793a\u5185\u5b58\u5339\u914d\u7684\u7c7b\u578b\u548c\u72b6\u6001\u3002","title":"1. \u5185\u5b58\u5339\u914d\u6807\u5fd7"},{"location":"target_mem/#2-oldvalueandmatchinfo","text":"struct OldValueAndMatchInfo { uint8_t old_value; // \u539f\u59cb\u5b57\u8282\u503c MatchFlags match_info; // \u5339\u914d\u7c7b\u578b\u548c\u72b6\u6001\u6807\u5fd7 };","title":"2. OldValueAndMatchInfo \u7ed3\u6784"},{"location":"target_mem/#3-matchesandoldvaluesswath","text":"\u8868\u793a\u5177\u6709\u5339\u914d\u4fe1\u606f\u7684\u8fde\u7eed\u5185\u5b58\u533a\u57df\u3002 class MatchesAndOldValuesSwath { public: void* firstByteInChild = nullptr; // \u8d77\u59cb\u5730\u5740 std::vector<OldValueAndMatchInfo> data; // \u5339\u914d\u6570\u636e // \u6784\u9020\u51fd\u6570 MatchesAndOldValuesSwath() = default; // \u5143\u7d20\u7ba1\u7406 void addElement(void* addr, uint8_t byte, MatchFlags matchFlags); // \u5b57\u7b26\u4e32\u8868\u793a\u5de5\u5177 std::string toPrintableString(size_t idx, size_t len) const; std::string toByteArrayText(size_t idx, size_t len) const; };","title":"3. MatchesAndOldValuesSwath \u7c7b"},{"location":"target_mem/#_6","text":"","title":"\u65b9\u6cd5"},{"location":"target_mem/#addelementvoid-addr-uint8_t-byte-matchflags-matchflags","text":"\u5411 swath \u6dfb\u52a0\u65b0\u7684\u5185\u5b58\u5339\u914d\u3002 \u53c2\u6570\uff1a addr : \u5339\u914d\u7684\u5185\u5b58\u5730\u5740 byte : \u6b64\u5730\u5740\u7684\u5b57\u8282\u503c matchFlags : \u5339\u914d\u7c7b\u578b\u548c\u6807\u5fd7","title":"addElement(void* addr, uint8_t byte, MatchFlags matchFlags)"},{"location":"target_mem/#toprintablestringsize_t-idx-size_t-len","text":"\u5c06\u5185\u5b58\u5b57\u8282\u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u7684 ASCII \u5b57\u7b26\u4e32\u3002 \u53c2\u6570\uff1a idx : \u6570\u636e\u5411\u91cf\u4e2d\u7684\u8d77\u59cb\u7d22\u5f15 len : \u8981\u8f6c\u6362\u7684\u5b57\u8282\u6570 \u8fd4\u56de\uff1a \u53ef\u6253\u5370\u5b57\u7b26\u4e32\uff0c\u4e0d\u53ef\u6253\u5370\u5b57\u7b26\u663e\u793a\u4e3a '.'","title":"toPrintableString(size_t idx, size_t len)"},{"location":"target_mem/#tobytearraytextsize_t-idx-size_t-len","text":"\u5c06\u5185\u5b58\u5b57\u8282\u8f6c\u6362\u4e3a\u5341\u516d\u8fdb\u5236\u6587\u672c\u8868\u793a\u3002 \u53c2\u6570\uff1a idx : \u6570\u636e\u5411\u91cf\u4e2d\u7684\u8d77\u59cb\u7d22\u5f15 len : \u8981\u8f6c\u6362\u7684\u5b57\u8282\u6570 \u8fd4\u56de\uff1a \u7a7a\u683c\u5206\u9694\u7684\u5341\u516d\u8fdb\u5236\u503c","title":"toByteArrayText(size_t idx, size_t len)"},{"location":"target_mem/#4-matchesandoldvaluesarray","text":"\u7ba1\u7406\u591a\u4e2a swath \u5e76\u63d0\u4f9b\u641c\u7d22\u64cd\u4f5c\u3002 class MatchesAndOldValuesArray { public: std::vector<MatchesAndOldValuesSwath> swaths; // \u5185\u5b58\u533a\u57df\u96c6\u5408 // \u6784\u9020\u51fd\u6570 MatchesAndOldValuesArray() = default; // \u641c\u7d22\u64cd\u4f5c std::optional<size_t> findSwathIndex(void* addr) const; std::optional<size_t> findElementIndex(void* addr) const; // \u6570\u636e\u8bbf\u95ee const OldValueAndMatchInfo* getElement(void* addr) const; OldValueAndMatchInfo* getElement(void* addr); // \u5185\u5b58\u7ba1\u7406 void clear(); size_t size() const; };","title":"4. MatchesAndOldValuesArray \u7c7b"},{"location":"target_mem/#matchesandoldvaluesarray","text":"","title":"MatchesAndOldValuesArray\u65b9\u6cd5"},{"location":"target_mem/#findswathindexvoid-addr-const","text":"\u67e5\u627e\u5305\u542b\u6307\u5b9a\u5730\u5740\u7684 swath \u7d22\u5f15\u3002 \u53c2\u6570\uff1a addr : \u8981\u67e5\u627e\u7684\u5185\u5b58\u5730\u5740 \u8fd4\u56de\uff1a \u5305\u542b\u8be5\u5730\u5740\u7684 swath \u7d22\u5f15\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de std::nullopt","title":"findSwathIndex(void* addr) const"},{"location":"target_mem/#findelementindexvoid-addr-const","text":"\u67e5\u627e\u6307\u5b9a\u5730\u5740\u5728 swath \u4e2d\u7684\u5143\u7d20\u7d22\u5f15\u3002 \u53c2\u6570\uff1a addr : \u8981\u67e5\u627e\u7684\u5185\u5b58\u5730\u5740 \u8fd4\u56de\uff1a \u5143\u7d20\u5728 swath \u4e2d\u7684\u7d22\u5f15\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de std::nullopt","title":"findElementIndex(void* addr) const"},{"location":"target_mem/#getelementvoid-addr","text":"\u83b7\u53d6\u6307\u5b9a\u5730\u5740\u7684\u5143\u7d20\u6570\u636e\u3002 \u53c2\u6570\uff1a addr : \u5185\u5b58\u5730\u5740 \u8fd4\u56de\uff1a \u6307\u5411 OldValueAndMatchInfo \u7684\u6307\u9488\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de nullptr","title":"getElement(void* addr)"},{"location":"target_mem/#_7","text":"","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"target_mem/#_8","text":"import targetmem; // \u521b\u5efa\u5185\u5b58\u5339\u914d\u6570\u7ec4 MatchesAndOldValuesArray matches; // \u6dfb\u52a0\u5185\u5b58\u5339\u914d void* addr1 = (void*)0x1000; void* addr2 = (void*)0x1001; MatchesAndOldValuesSwath swath; swath.addElement(addr1, 0x42, MatchFlags::EXACT_MATCH); swath.addElement(addr2, 0x7F, MatchFlags::GREATER_THAN); matches.swaths.push_back(swath);","title":"\u57fa\u672c\u4f7f\u7528"},{"location":"target_mem/#_9","text":"// \u67e5\u627e\u5305\u542b\u5730\u5740\u7684 swath auto swathIndex = matches.findSwathIndex(addr1); if (swathIndex) { std::cout << \"\u627e\u5230 swath \u7d22\u5f15: \" << *swathIndex << std::endl; } // \u67e5\u627e\u5143\u7d20\u7d22\u5f15 auto elementIndex = matches.findElementIndex(addr1); if (elementIndex) { std::cout << \"\u627e\u5230\u5143\u7d20\u7d22\u5f15: \" << *elementIndex << std::endl; } // \u83b7\u53d6\u5143\u7d20\u6570\u636e const auto* element = matches.getElement(addr1); if (element) { std::cout << \"\u65e7\u503c: 0x\" << std::hex << (int)element->old_value << std::endl; }","title":"\u641c\u7d22\u64cd\u4f5c"},{"location":"target_mem/#_10","text":"// \u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u5b57\u7b26\u4e32 std::string printable = swath.toPrintableString(0, 10); std::cout << \"\u53ef\u6253\u5370\u5b57\u7b26\u4e32: \" << printable << std::endl; // \u8f6c\u6362\u4e3a\u5b57\u8282\u6570\u7ec4\u6587\u672c std::string byteArray = swath.toByteArrayText(0, 10); std::cout << \"\u5b57\u8282\u6570\u7ec4: \" << byteArray << std::endl;","title":"\u5b57\u7b26\u4e32\u8868\u793a"},{"location":"target_mem/#_11","text":"","title":"\u5185\u5b58\u7ba1\u7406"},{"location":"target_mem/#_12","text":"\u6bcf\u4e2a MatchesAndOldValuesSwath \u8868\u793a\u4e00\u4e2a\u8fde\u7eed\u7684\u5185\u5b58\u533a\u57df\uff1a +----------------+----------------+----------------+ | \u5730\u5740 0x1000 | \u5730\u5740 0x1001 | \u5730\u5740 0x1002 | | \u65e7\u503c: 0x42 | \u65e7\u503c: 0x7F | \u65e7\u503c: 0xAA | | \u6807\u5fd7: EXACT | \u6807\u5fd7: GREATER | \u6807\u5fd7: LESS | +----------------+----------------+----------------+","title":"\u5185\u5b58\u5e03\u5c40"},{"location":"target_mem/#_13","text":"\u5730\u5740\u6309\u5b57\u8282\u5bf9\u9f50 \u6570\u636e\u7ed3\u6784\u7d27\u51d1\u5b58\u50a8 \u652f\u6301\u8de8\u5e73\u53f0\u5185\u5b58\u5e03\u5c40","title":"\u5185\u5b58\u5bf9\u9f50"},{"location":"target_mem/#_14","text":"\u8fb9\u754c\u68c0\u67e5\u9632\u6b62\u8d8a\u754c\u8bbf\u95ee \u7a7a\u6307\u9488\u68c0\u67e5 \u5f02\u5e38\u5b89\u5168\u4fdd\u8bc1","title":"\u5185\u5b58\u5b89\u5168"},{"location":"target_mem/#_15","text":"","title":"\u6027\u80fd\u4f18\u5316"},{"location":"target_mem/#_16","text":"\u4e8c\u5206\u641c\u7d22 : \u5728\u6709\u5e8f swath \u4e2d\u4f7f\u7528\u4e8c\u5206\u641c\u7d22 \u5730\u5740\u8303\u56f4\u68c0\u67e5 : \u5feb\u901f\u8fc7\u6ee4\u4e0d\u76f8\u5173\u7684 swath \u7f13\u5b58\u53cb\u597d : \u8fde\u7eed\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f","title":"\u641c\u7d22\u4f18\u5316"},{"location":"target_mem/#_17","text":"\u7d27\u51d1\u5b58\u50a8 : \u6700\u5c0f\u5316\u5185\u5b58\u5360\u7528 \u52a8\u6001\u589e\u957f : \u6309\u9700\u5206\u914d\u5185\u5b58 \u5185\u5b58\u6c60 : \u51cf\u5c11\u5206\u914d\u5f00\u9500","title":"\u5185\u5b58\u4f7f\u7528"},{"location":"target_mem/#_18","text":"\u67e5\u627e swath : O(log n) \u5176\u4e2d n \u662f swath \u6570\u91cf \u67e5\u627e\u5143\u7d20 : O(log m) \u5176\u4e2d m \u662f swath \u4e2d\u7684\u5143\u7d20\u6570\u91cf \u6dfb\u52a0\u5143\u7d20 : O(1) \u5e73\u5747\u60c5\u51b5","title":"\u7b97\u6cd5\u590d\u6742\u5ea6"},{"location":"target_mem/#_19","text":"","title":"\u9519\u8bef\u5904\u7406"},{"location":"target_mem/#_20","text":"\u65e0\u6548\u5730\u5740 : \u7a7a\u6307\u9488\u6216\u65e0\u6548\u5185\u5b58\u5730\u5740 \u8d8a\u754c\u8bbf\u95ee : \u8bbf\u95ee\u8d85\u51fa\u8303\u56f4\u7684\u7d22\u5f15 \u5185\u5b58\u4e0d\u8db3 : \u5206\u914d\u5931\u8d25","title":"\u5e38\u89c1\u9519\u8bef"},{"location":"target_mem/#_21","text":"\u4f7f\u7528 std::optional \u8868\u793a\u67e5\u627e\u5931\u8d25 \u8fd4\u56de nullptr \u8868\u793a\u65e0\u6548\u8bbf\u95ee \u629b\u51fa\u5f02\u5e38\u5904\u7406\u4e25\u91cd\u9519\u8bef","title":"\u9519\u8bef\u5904\u7406\u7b56\u7565"},{"location":"target_mem/#_22","text":"","title":"\u6269\u5c55\u6027"},{"location":"target_mem/#_23","text":"enum class CustomMatchFlags : uint8_t { CUSTOM_MATCH_1, CUSTOM_MATCH_2, // ... \u5176\u4ed6\u7c7b\u578b };","title":"\u81ea\u5b9a\u4e49\u5339\u914d\u7c7b\u578b"},{"location":"target_mem/#_24","text":"struct CustomMatchInfo { uint8_t old_value; CustomMatchFlags flags; std::string additional_info; };","title":"\u81ea\u5b9a\u4e49\u6570\u636e\u7ed3\u6784"},{"location":"target_mem/#_25","text":"class MatchPlugin { public: virtual bool processMatch(void* addr, uint8_t value) = 0; virtual std::string getDescription() const = 0; };","title":"\u63d2\u4ef6\u652f\u6301"},{"location":"value/","text":"\u503c\u7c7b\u578b\u6a21\u5757\u6587\u6863 \u6982\u8ff0 value \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5168\u9762\u7684\u503c\u7c7b\u578b\u5b9a\u4e49\u548c\u5339\u914d\u6807\u5fd7\u3002\u5b83\u5b9a\u4e49\u4e86\u5404\u79cd\u6570\u636e\u7c7b\u578b\u8868\u793a\u3001\u5185\u5b58\u5e03\u5c40\u548c\u5b9e\u7528\u7ed3\u6784\uff0c\u7528\u4e8e\u5904\u7406\u5185\u5b58\u626b\u63cf\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u4e0d\u540c\u6570\u503c\u7c7b\u578b\u3001\u5b57\u8282\u6570\u7ec4\u548c\u901a\u914d\u7b26\u6a21\u5f0f\u3002 \u6a21\u5757\u7ed3\u6784 export module value; \u4f9d\u8d56\u9879 <cstdint> - \u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b <cstring> - \u5b57\u8282\u62f7\u8d1d <optional> - \u53ef\u9009\u7c7b\u578b\u652f\u6301 <span> - \u53ea\u8bfb/\u53ef\u5199\u5b57\u8282\u89c6\u56fe <string> - \u5b57\u7b26\u4e32\u64cd\u4f5c <type_traits> - \u7c7b\u578b\u5de5\u5177 <vector> - \u52a8\u6001\u6570\u7ec4\u5bb9\u5668 \u6838\u5fc3\u529f\u80fd 1. \u5339\u914d\u6807\u5fd7\u679a\u4e3e enum class [[gnu::packed]] MatchFlags : uint16_t { EMPTY = 0, // \u57fa\u672c\u6570\u503c\u7c7b\u578b U8B = 1 << 0, // \u65e0\u7b26\u53f7 8 \u4f4d S8B = 1 << 1, // \u6709\u7b26\u53f7 8 \u4f4d U16B = 1 << 2, // \u65e0\u7b26\u53f7 16 \u4f4d S16B = 1 << 3, // \u6709\u7b26\u53f7 16 \u4f4d U32B = 1 << 4, // \u65e0\u7b26\u53f7 32 \u4f4d S32B = 1 << 5, // \u6709\u7b26\u53f7 32 \u4f4d U64B = 1 << 6, // \u65e0\u7b26\u53f7 64 \u4f4d S64B = 1 << 7, // \u6709\u7b26\u53f7 64 \u4f4d // \u6d6e\u70b9\u7c7b\u578b F32B = 1 << 8, // 32 \u4f4d\u6d6e\u70b9 F64B = 1 << 9, // 64 \u4f4d\u6d6e\u70b9 // \u590d\u5408\u7c7b\u578b I8B = U8B | S8B, // \u4efb\u610f 8 \u4f4d\u6574\u6570 I16B = U16B | S16B, // \u4efb\u610f 16 \u4f4d\u6574\u6570 I32B = U32B | S32B, // \u4efb\u610f 32 \u4f4d\u6574\u6570 I64B = U64B | S64B, // \u4efb\u610f 64 \u4f4d\u6574\u6570 INTEGER = I8B | I16B | I32B | I64B, // \u6240\u6709\u6574\u6570\u7c7b\u578b FLOAT = F32B | F64B, // \u6240\u6709\u6d6e\u70b9\u7c7b\u578b ALL = INTEGER | FLOAT, // \u6240\u6709\u652f\u6301\u7684\u7c7b\u578b // \u57fa\u4e8e\u5b57\u8282\u7684\u5206\u7ec4 B8 = I8B, // 8 \u4f4d\u5757 B16 = I16B, // 16 \u4f4d\u5757 B32 = I32B | F32B, // 32 \u4f4d\u5757 B64 = I64B | F64B, // 64 \u4f4d\u5757 MAX = 0xffffU // \u6700\u5927\u6807\u5fd7\u503c }; 2. Value \u7ed3\u6784\uff08\u7edf\u4e00\u4e3a\u5b57\u8282\u5b58\u50a8\uff09 Value \u4f5c\u4e3a\u201c\u5386\u53f2\u503c\uff08\u65e7\u503c\uff09\u201d\u5bb9\u5668\uff0c\u5e95\u5c42\u4ec5\u5b58\u50a8\u8fde\u7eed\u5b57\u8282\uff0c\u7c7b\u578b/\u5bbd\u5ea6\u8bed\u4e49\u7531 flags \u8868\u793a\u3002 struct [[gnu::packed]] Value { std::vector<uint8_t> bytes; // \u5386\u53f2\u503c\u5b57\u8282 MatchFlags flags = MatchFlags::EMPTY; // \u7c7b\u578b/\u5bbd\u5ea6\u6807\u5fd7\uff08\u4e25\u683c\u6570\u503c\u8def\u5f84\u9700\u8981\uff09 // \u590d\u4f4d\u4e3a\u96f6\u72b6\u6001 constexpr static void zero(Value& val); // \u83b7\u53d6\u53ea\u8bfb\u5b57\u8282\u89c6\u56fe std::span<const uint8_t> view() const noexcept; // \u6309\u5b57\u8282\u8bbe\u7f6e\uff08\u53ef\u9644\u5e26 flag\uff09 void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& val); void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f); void setBytesWithFlag(const std::vector<uint8_t>& val, MatchFlags f); // \u6309\u6807\u91cf\u8bbe\u7f6e\uff08\u62f7\u8d1d\u5176\u5185\u5b58\u8868\u793a\uff09\uff1bTyped \u7248\u672c\u81ea\u52a8\u8bbe\u7f6e\u6b63\u786e flag template <typename T> void setScalar(const T& v); template <typename T> void setScalarWithFlag(const T& v, MatchFlags f); template <typename T> void setScalarTyped(const T& v); }; \u8981\u70b9\uff1a - \u6570\u503c\u6bd4\u8f83\u8def\u5f84\u201c\u4e25\u683c\u6821\u9a8c\u201d\uff1a\u53ea\u6709\u5f53 flags \u4e0e\u671f\u671b\u7c7b\u578b\u76f8\u7b26\u4e14 bytes.size() >= sizeof(T) \u65f6\uff0c\u65e7\u503c\u624d\u4f1a\u88ab\u89e3\u7801\u53c2\u4e0e\u6bd4\u8f83\u3002 - \u5b57\u8282\u4e32/\u5b57\u7b26\u4e32\u5339\u914d\u4e0d\u4f9d\u8d56 flags \uff0c\u4e0d\u53d7\u4e25\u683c\u7b56\u7565\u9650\u5236\u3002 3. Mem64 \u7ed3\u6784\uff08\u5f53\u524d\u503c\u8bfb\u53d6\u7f13\u51b2\uff09 Mem64 \u8868\u793a\u201c\u5f53\u524d\u4f4d\u7f6e\u8bfb\u53d6\u5230\u7684\u5b57\u8282\u201d\u3002 struct [[gnu::packed]] Mem64 { std::vector<uint8_t> buffer; // \u5f53\u524d\u503c\u5b57\u8282 // \u8bfb\u53d6/\u5199\u5165 template <typename T> T get() const; // \u7528 memcpy \u89e3\u7801 T std::span<const uint8_t> bytes() const noexcept; // \u53ea\u8bfb\u89c6\u56fe void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& data); void setString(const std::string& s); template <typename T> void setScalar(const T& v); }; \u7aef\u5e8f\u5904\u7406\uff1a\u5bf9\u4e8e\u6570\u503c\u7c7b\u578b\uff0c\u901a\u8fc7 swapIfReverse \uff08\u5728\u626b\u63cf\u6a21\u5757\u5185\uff09\u6216\u5bf9 Value \u4f7f\u7528 fixEndianness \u5c06\u65e7\u503c\u4e0e\u5f53\u524d\u503c\u7aef\u5e8f\u5bf9\u9f50\u3002 \u4f7f\u7528\u793a\u4f8b \u57fa\u672c\u4f7f\u7528\uff08\u6570\u503c\u4e25\u683c + \u5b57\u8282\u81ea\u7531\uff09 import value; // \u4fdd\u5b58\u65e7\u503c\uff08\u6570\u503c\uff0c\u81ea\u52a8\u8bbe\u7f6e\u6b63\u786e flag\uff09 Value intValue; intValue.setScalarTyped<int32_t>(42); // \u521b\u5efa\u6d6e\u70b9\u7c7b\u578b\u7684 Value Value floatValue; floatValue.setScalarTyped<float>(3.14159f); // \u4fdd\u5b58\u65e7\u503c\uff08\u539f\u59cb\u5b57\u8282\uff0c\u4e0d\u8bbe flag \u4e5f\u53ef\uff09 Value byteArrayValue; std::vector<uint8_t> bytes = {0x01,0x02,0x03,0x04}; byteArrayValue.setBytes(bytes); \u7c7b\u578b/\u6807\u5fd7\u68c0\u67e5 // \u68c0\u67e5\u6807\u5fd7 if (intValue.flags & MatchFlags::INTEGER) { std::cout << \"\u8fd9\u662f\u4e00\u4e2a\u6574\u6570\u7c7b\u578b\" << std::endl; } \u5b57\u8282\u6570\u7ec4\u64cd\u4f5c Value patternValue; std::vector<uint8_t> pattern = {0xDE,0xAD,0xBE,0xEF}; patternValue.setBytes(pattern); for (auto b : patternValue.view()) { /* \u904d\u5386\u5b57\u8282 */ } \u5339\u914d\u64cd\u4f5c \u5339\u914d\u903b\u8f91\u5728 scanroutines \u6a21\u5757\u4e2d\u5b9e\u73b0\uff1a - \u6570\u503c\uff1a\u4e25\u683c\u6309\u7167 flags \u4e0e\u7c7b\u578b\u5339\u914d\uff08\u89e3\u7801\u65e7\u503c\u65f6\u8981\u6c42\u7c7b\u578b\u4e00\u81f4\uff09\u3002 - \u5b57\u8282\u4e32/\u5b57\u7b26\u4e32\uff1a\u6ed1\u52a8\u641c\u7d22\uff1b\u53ef\u9009\u63a9\u7801\uff080xFF=\u7cbe\u786e\uff0c0x00=\u901a\u914d\uff09\uff1b\u5b57\u7b26\u4e32\u652f\u6301 Boost.Regex\u3002 \u66f4\u591a\u5339\u914d\u793a\u4f8b\uff08\u8303\u56f4\u3001\u63a9\u7801\u3001\u6b63\u5219\uff09\u8bf7\u53c2\u8003 scanroutines \u6a21\u5757\u6587\u6863\u4e0e\u5b9e\u73b0\u3002 \u6027\u80fd\u4f18\u5316 \u5185\u5b58\u5e03\u5c40\u4f18\u5316 \u7d27\u51d1\u5b58\u50a8 : \u4f7f\u7528 packed \u5c5e\u6027\u51cf\u5c11\u5185\u5b58\u5360\u7528 \u7f13\u5b58\u53cb\u597d : \u8fde\u7eed\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f \u5bf9\u9f50\u4f18\u5316 : \u9488\u5bf9\u76ee\u6807\u67b6\u6784\u4f18\u5316\u5bf9\u9f50 \u7c7b\u578b\u68c0\u67e5\u4f18\u5316 \u7f16\u8bd1\u65f6\u68c0\u67e5 : \u4f7f\u7528 static_assert \u8fdb\u884c\u7f16\u8bd1\u65f6\u9a8c\u8bc1 \u8fd0\u884c\u65f6\u4f18\u5316 : \u9ad8\u6548\u7684\u7c7b\u578b\u68c0\u67e5\u7b97\u6cd5 \u7f13\u5b58\u7ed3\u679c : \u7f13\u5b58\u9891\u7e41\u7684\u7c7b\u578b\u68c0\u67e5\u7ed3\u679c \u8f6c\u6362\u4f18\u5316 \u96f6\u62f7\u8d1d : \u5c3d\u53ef\u80fd\u907f\u514d\u6570\u636e\u62f7\u8d1d \u5185\u8054\u51fd\u6570 : \u4f7f\u7528\u5185\u8054\u51fd\u6570\u51cf\u5c11\u51fd\u6570\u8c03\u7528\u5f00\u9500 SIMD \u4f18\u5316 : \u5bf9\u5b57\u8282\u6570\u7ec4\u64cd\u4f5c\u4f7f\u7528 SIMD \u6307\u4ee4 \u9519\u8bef\u5904\u7406 \u7c7b\u578b\u9519\u8bef \u6570\u503c\u8def\u5f84\u4e0b\uff0c\u65e7\u503c\u89e3\u7801\u65f6\u8981\u6c42 flags \u4e0e\u671f\u671b\u7c7b\u578b\u4e00\u81f4\u4e14\u957f\u5ea6\u8db3\u591f\uff0c\u5426\u5219\u4e0a\u5c42\u5e94\u5f53\u653e\u5f03\u89e3\u7801\u3002 \u8303\u56f4\u9519\u8bef \u4e0a\u5c42\u5e94\u6839\u636e flags \u63a8\u65ad\u5bbd\u5ea6\u5e76\u8fdb\u884c\u8fb9\u754c\u68c0\u67e5\uff0c Value \u672c\u8eab\u4ec5\u63d0\u4f9b\u5b57\u8282\u89c6\u56fe\u4e0e\u6807\u5fd7\uff0c\u4e0d\u76f4\u63a5\u8fdb\u884c\u8303\u56f4\u5224\u65ad\u3002 \u6269\u5c55\u6027 \u81ea\u5b9a\u4e49\u7c7b\u578b // \u6dfb\u52a0\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b enum class CustomMatchFlags : uint16_t { CUSTOM_TYPE_1 = 1 << 10, CUSTOM_TYPE_2 = 1 << 11, }; // \u6269\u5c55 Value \u7ed3\u6784 struct ExtendedValue : public Value { CustomMatchFlags customFlags = CustomMatchFlags::CUSTOM_TYPE_1; std::string additionalData; }; \u63d2\u4ef6\u7cfb\u7edf // \u503c\u5904\u7406\u63d2\u4ef6\u63a5\u53e3 class ValueProcessor { public: virtual bool process(Value& val) = 0; virtual std::string getDescription() const = 0; }; // \u5177\u4f53\u5b9e\u73b0 class CustomValueProcessor : public ValueProcessor { public: bool process(Value& val) override { // \u81ea\u5b9a\u4e49\u5904\u7406\u903b\u8f91 return true; } std::string getDescription() const override { return \"\u81ea\u5b9a\u4e49\u503c\u5904\u7406\u5668\"; } };","title":"\u503c"},{"location":"value/#_1","text":"","title":"\u503c\u7c7b\u578b\u6a21\u5757\u6587\u6863"},{"location":"value/#_2","text":"value \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5168\u9762\u7684\u503c\u7c7b\u578b\u5b9a\u4e49\u548c\u5339\u914d\u6807\u5fd7\u3002\u5b83\u5b9a\u4e49\u4e86\u5404\u79cd\u6570\u636e\u7c7b\u578b\u8868\u793a\u3001\u5185\u5b58\u5e03\u5c40\u548c\u5b9e\u7528\u7ed3\u6784\uff0c\u7528\u4e8e\u5904\u7406\u5185\u5b58\u626b\u63cf\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u4e0d\u540c\u6570\u503c\u7c7b\u578b\u3001\u5b57\u8282\u6570\u7ec4\u548c\u901a\u914d\u7b26\u6a21\u5f0f\u3002","title":"\u6982\u8ff0"},{"location":"value/#_3","text":"export module value;","title":"\u6a21\u5757\u7ed3\u6784"},{"location":"value/#_4","text":"<cstdint> - \u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b <cstring> - \u5b57\u8282\u62f7\u8d1d <optional> - \u53ef\u9009\u7c7b\u578b\u652f\u6301 <span> - \u53ea\u8bfb/\u53ef\u5199\u5b57\u8282\u89c6\u56fe <string> - \u5b57\u7b26\u4e32\u64cd\u4f5c <type_traits> - \u7c7b\u578b\u5de5\u5177 <vector> - \u52a8\u6001\u6570\u7ec4\u5bb9\u5668","title":"\u4f9d\u8d56\u9879"},{"location":"value/#_5","text":"","title":"\u6838\u5fc3\u529f\u80fd"},{"location":"value/#1","text":"enum class [[gnu::packed]] MatchFlags : uint16_t { EMPTY = 0, // \u57fa\u672c\u6570\u503c\u7c7b\u578b U8B = 1 << 0, // \u65e0\u7b26\u53f7 8 \u4f4d S8B = 1 << 1, // \u6709\u7b26\u53f7 8 \u4f4d U16B = 1 << 2, // \u65e0\u7b26\u53f7 16 \u4f4d S16B = 1 << 3, // \u6709\u7b26\u53f7 16 \u4f4d U32B = 1 << 4, // \u65e0\u7b26\u53f7 32 \u4f4d S32B = 1 << 5, // \u6709\u7b26\u53f7 32 \u4f4d U64B = 1 << 6, // \u65e0\u7b26\u53f7 64 \u4f4d S64B = 1 << 7, // \u6709\u7b26\u53f7 64 \u4f4d // \u6d6e\u70b9\u7c7b\u578b F32B = 1 << 8, // 32 \u4f4d\u6d6e\u70b9 F64B = 1 << 9, // 64 \u4f4d\u6d6e\u70b9 // \u590d\u5408\u7c7b\u578b I8B = U8B | S8B, // \u4efb\u610f 8 \u4f4d\u6574\u6570 I16B = U16B | S16B, // \u4efb\u610f 16 \u4f4d\u6574\u6570 I32B = U32B | S32B, // \u4efb\u610f 32 \u4f4d\u6574\u6570 I64B = U64B | S64B, // \u4efb\u610f 64 \u4f4d\u6574\u6570 INTEGER = I8B | I16B | I32B | I64B, // \u6240\u6709\u6574\u6570\u7c7b\u578b FLOAT = F32B | F64B, // \u6240\u6709\u6d6e\u70b9\u7c7b\u578b ALL = INTEGER | FLOAT, // \u6240\u6709\u652f\u6301\u7684\u7c7b\u578b // \u57fa\u4e8e\u5b57\u8282\u7684\u5206\u7ec4 B8 = I8B, // 8 \u4f4d\u5757 B16 = I16B, // 16 \u4f4d\u5757 B32 = I32B | F32B, // 32 \u4f4d\u5757 B64 = I64B | F64B, // 64 \u4f4d\u5757 MAX = 0xffffU // \u6700\u5927\u6807\u5fd7\u503c };","title":"1. \u5339\u914d\u6807\u5fd7\u679a\u4e3e"},{"location":"value/#2-value","text":"Value \u4f5c\u4e3a\u201c\u5386\u53f2\u503c\uff08\u65e7\u503c\uff09\u201d\u5bb9\u5668\uff0c\u5e95\u5c42\u4ec5\u5b58\u50a8\u8fde\u7eed\u5b57\u8282\uff0c\u7c7b\u578b/\u5bbd\u5ea6\u8bed\u4e49\u7531 flags \u8868\u793a\u3002 struct [[gnu::packed]] Value { std::vector<uint8_t> bytes; // \u5386\u53f2\u503c\u5b57\u8282 MatchFlags flags = MatchFlags::EMPTY; // \u7c7b\u578b/\u5bbd\u5ea6\u6807\u5fd7\uff08\u4e25\u683c\u6570\u503c\u8def\u5f84\u9700\u8981\uff09 // \u590d\u4f4d\u4e3a\u96f6\u72b6\u6001 constexpr static void zero(Value& val); // \u83b7\u53d6\u53ea\u8bfb\u5b57\u8282\u89c6\u56fe std::span<const uint8_t> view() const noexcept; // \u6309\u5b57\u8282\u8bbe\u7f6e\uff08\u53ef\u9644\u5e26 flag\uff09 void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& val); void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f); void setBytesWithFlag(const std::vector<uint8_t>& val, MatchFlags f); // \u6309\u6807\u91cf\u8bbe\u7f6e\uff08\u62f7\u8d1d\u5176\u5185\u5b58\u8868\u793a\uff09\uff1bTyped \u7248\u672c\u81ea\u52a8\u8bbe\u7f6e\u6b63\u786e flag template <typename T> void setScalar(const T& v); template <typename T> void setScalarWithFlag(const T& v, MatchFlags f); template <typename T> void setScalarTyped(const T& v); }; \u8981\u70b9\uff1a - \u6570\u503c\u6bd4\u8f83\u8def\u5f84\u201c\u4e25\u683c\u6821\u9a8c\u201d\uff1a\u53ea\u6709\u5f53 flags \u4e0e\u671f\u671b\u7c7b\u578b\u76f8\u7b26\u4e14 bytes.size() >= sizeof(T) \u65f6\uff0c\u65e7\u503c\u624d\u4f1a\u88ab\u89e3\u7801\u53c2\u4e0e\u6bd4\u8f83\u3002 - \u5b57\u8282\u4e32/\u5b57\u7b26\u4e32\u5339\u914d\u4e0d\u4f9d\u8d56 flags \uff0c\u4e0d\u53d7\u4e25\u683c\u7b56\u7565\u9650\u5236\u3002","title":"2. Value \u7ed3\u6784\uff08\u7edf\u4e00\u4e3a\u5b57\u8282\u5b58\u50a8\uff09"},{"location":"value/#3-mem64","text":"Mem64 \u8868\u793a\u201c\u5f53\u524d\u4f4d\u7f6e\u8bfb\u53d6\u5230\u7684\u5b57\u8282\u201d\u3002 struct [[gnu::packed]] Mem64 { std::vector<uint8_t> buffer; // \u5f53\u524d\u503c\u5b57\u8282 // \u8bfb\u53d6/\u5199\u5165 template <typename T> T get() const; // \u7528 memcpy \u89e3\u7801 T std::span<const uint8_t> bytes() const noexcept; // \u53ea\u8bfb\u89c6\u56fe void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& data); void setString(const std::string& s); template <typename T> void setScalar(const T& v); }; \u7aef\u5e8f\u5904\u7406\uff1a\u5bf9\u4e8e\u6570\u503c\u7c7b\u578b\uff0c\u901a\u8fc7 swapIfReverse \uff08\u5728\u626b\u63cf\u6a21\u5757\u5185\uff09\u6216\u5bf9 Value \u4f7f\u7528 fixEndianness \u5c06\u65e7\u503c\u4e0e\u5f53\u524d\u503c\u7aef\u5e8f\u5bf9\u9f50\u3002","title":"3. Mem64 \u7ed3\u6784\uff08\u5f53\u524d\u503c\u8bfb\u53d6\u7f13\u51b2\uff09"},{"location":"value/#_6","text":"","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"value/#_7","text":"import value; // \u4fdd\u5b58\u65e7\u503c\uff08\u6570\u503c\uff0c\u81ea\u52a8\u8bbe\u7f6e\u6b63\u786e flag\uff09 Value intValue; intValue.setScalarTyped<int32_t>(42); // \u521b\u5efa\u6d6e\u70b9\u7c7b\u578b\u7684 Value Value floatValue; floatValue.setScalarTyped<float>(3.14159f); // \u4fdd\u5b58\u65e7\u503c\uff08\u539f\u59cb\u5b57\u8282\uff0c\u4e0d\u8bbe flag \u4e5f\u53ef\uff09 Value byteArrayValue; std::vector<uint8_t> bytes = {0x01,0x02,0x03,0x04}; byteArrayValue.setBytes(bytes);","title":"\u57fa\u672c\u4f7f\u7528\uff08\u6570\u503c\u4e25\u683c + \u5b57\u8282\u81ea\u7531\uff09"},{"location":"value/#_8","text":"// \u68c0\u67e5\u6807\u5fd7 if (intValue.flags & MatchFlags::INTEGER) { std::cout << \"\u8fd9\u662f\u4e00\u4e2a\u6574\u6570\u7c7b\u578b\" << std::endl; }","title":"\u7c7b\u578b/\u6807\u5fd7\u68c0\u67e5"},{"location":"value/#_9","text":"Value patternValue; std::vector<uint8_t> pattern = {0xDE,0xAD,0xBE,0xEF}; patternValue.setBytes(pattern); for (auto b : patternValue.view()) { /* \u904d\u5386\u5b57\u8282 */ }","title":"\u5b57\u8282\u6570\u7ec4\u64cd\u4f5c"},{"location":"value/#_10","text":"\u5339\u914d\u903b\u8f91\u5728 scanroutines \u6a21\u5757\u4e2d\u5b9e\u73b0\uff1a - \u6570\u503c\uff1a\u4e25\u683c\u6309\u7167 flags \u4e0e\u7c7b\u578b\u5339\u914d\uff08\u89e3\u7801\u65e7\u503c\u65f6\u8981\u6c42\u7c7b\u578b\u4e00\u81f4\uff09\u3002 - \u5b57\u8282\u4e32/\u5b57\u7b26\u4e32\uff1a\u6ed1\u52a8\u641c\u7d22\uff1b\u53ef\u9009\u63a9\u7801\uff080xFF=\u7cbe\u786e\uff0c0x00=\u901a\u914d\uff09\uff1b\u5b57\u7b26\u4e32\u652f\u6301 Boost.Regex\u3002 \u66f4\u591a\u5339\u914d\u793a\u4f8b\uff08\u8303\u56f4\u3001\u63a9\u7801\u3001\u6b63\u5219\uff09\u8bf7\u53c2\u8003 scanroutines \u6a21\u5757\u6587\u6863\u4e0e\u5b9e\u73b0\u3002","title":"\u5339\u914d\u64cd\u4f5c"},{"location":"value/#_11","text":"","title":"\u6027\u80fd\u4f18\u5316"},{"location":"value/#_12","text":"\u7d27\u51d1\u5b58\u50a8 : \u4f7f\u7528 packed \u5c5e\u6027\u51cf\u5c11\u5185\u5b58\u5360\u7528 \u7f13\u5b58\u53cb\u597d : \u8fde\u7eed\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f \u5bf9\u9f50\u4f18\u5316 : \u9488\u5bf9\u76ee\u6807\u67b6\u6784\u4f18\u5316\u5bf9\u9f50","title":"\u5185\u5b58\u5e03\u5c40\u4f18\u5316"},{"location":"value/#_13","text":"\u7f16\u8bd1\u65f6\u68c0\u67e5 : \u4f7f\u7528 static_assert \u8fdb\u884c\u7f16\u8bd1\u65f6\u9a8c\u8bc1 \u8fd0\u884c\u65f6\u4f18\u5316 : \u9ad8\u6548\u7684\u7c7b\u578b\u68c0\u67e5\u7b97\u6cd5 \u7f13\u5b58\u7ed3\u679c : \u7f13\u5b58\u9891\u7e41\u7684\u7c7b\u578b\u68c0\u67e5\u7ed3\u679c","title":"\u7c7b\u578b\u68c0\u67e5\u4f18\u5316"},{"location":"value/#_14","text":"\u96f6\u62f7\u8d1d : \u5c3d\u53ef\u80fd\u907f\u514d\u6570\u636e\u62f7\u8d1d \u5185\u8054\u51fd\u6570 : \u4f7f\u7528\u5185\u8054\u51fd\u6570\u51cf\u5c11\u51fd\u6570\u8c03\u7528\u5f00\u9500 SIMD \u4f18\u5316 : \u5bf9\u5b57\u8282\u6570\u7ec4\u64cd\u4f5c\u4f7f\u7528 SIMD \u6307\u4ee4","title":"\u8f6c\u6362\u4f18\u5316"},{"location":"value/#_15","text":"","title":"\u9519\u8bef\u5904\u7406"},{"location":"value/#_16","text":"\u6570\u503c\u8def\u5f84\u4e0b\uff0c\u65e7\u503c\u89e3\u7801\u65f6\u8981\u6c42 flags \u4e0e\u671f\u671b\u7c7b\u578b\u4e00\u81f4\u4e14\u957f\u5ea6\u8db3\u591f\uff0c\u5426\u5219\u4e0a\u5c42\u5e94\u5f53\u653e\u5f03\u89e3\u7801\u3002","title":"\u7c7b\u578b\u9519\u8bef"},{"location":"value/#_17","text":"\u4e0a\u5c42\u5e94\u6839\u636e flags \u63a8\u65ad\u5bbd\u5ea6\u5e76\u8fdb\u884c\u8fb9\u754c\u68c0\u67e5\uff0c Value \u672c\u8eab\u4ec5\u63d0\u4f9b\u5b57\u8282\u89c6\u56fe\u4e0e\u6807\u5fd7\uff0c\u4e0d\u76f4\u63a5\u8fdb\u884c\u8303\u56f4\u5224\u65ad\u3002","title":"\u8303\u56f4\u9519\u8bef"},{"location":"value/#_18","text":"","title":"\u6269\u5c55\u6027"},{"location":"value/#_19","text":"// \u6dfb\u52a0\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b enum class CustomMatchFlags : uint16_t { CUSTOM_TYPE_1 = 1 << 10, CUSTOM_TYPE_2 = 1 << 11, }; // \u6269\u5c55 Value \u7ed3\u6784 struct ExtendedValue : public Value { CustomMatchFlags customFlags = CustomMatchFlags::CUSTOM_TYPE_1; std::string additionalData; };","title":"\u81ea\u5b9a\u4e49\u7c7b\u578b"},{"location":"value/#_20","text":"// \u503c\u5904\u7406\u63d2\u4ef6\u63a5\u53e3 class ValueProcessor { public: virtual bool process(Value& val) = 0; virtual std::string getDescription() const = 0; }; // \u5177\u4f53\u5b9e\u73b0 class CustomValueProcessor : public ValueProcessor { public: bool process(Value& val) override { // \u81ea\u5b9a\u4e49\u5904\u7406\u903b\u8f91 return true; } std::string getDescription() const override { return \"\u81ea\u5b9a\u4e49\u503c\u5904\u7406\u5668\"; } };","title":"\u63d2\u4ef6\u7cfb\u7edf"},{"location":"en/","text":"Start Welcome to the NewScanmem documentation site! This site provides detailed information about the project, including its features, usage, and API references. About NewScanmem NewScanmem is a modernized version of the scanmem tool, rebuilt using C++20 modules. It is designed for memory scanning and debugging processes on Linux systems. Key Features C++20 Modules : Improved code organization and compilation speed. Boost Integration : Enhanced file and string handling. High Performance : Optimized memory scanning algorithms.","title":"Home"},{"location":"en/#start","text":"Welcome to the NewScanmem documentation site! This site provides detailed information about the project, including its features, usage, and API references.","title":"Start"},{"location":"en/#about-newscanmem","text":"NewScanmem is a modernized version of the scanmem tool, rebuilt using C++20 modules. It is designed for memory scanning and debugging processes on Linux systems.","title":"About NewScanmem"},{"location":"en/#key-features","text":"C++20 Modules : Improved code organization and compilation speed. Boost Integration : Enhanced file and string handling. High Performance : Optimized memory scanning algorithms.","title":"Key Features"},{"location":"en/API_REFERENCE/","text":"API Reference Module Index endianness maps process_checker sets show_message targetmem value maps Enum: region_type enum class region_type : uint8_t { misc, // Miscellaneous memory regions exe, // Executable binary regions code, // Code segments (shared libraries, etc.) heap, // Heap memory regions stack // Stack memory regions }; constexpr std::array<std::string_view, 5> region_type_names; Enum: region_scan_level enum class region_scan_level : uint8_t { all, // All readable regions all_rw, // All readable/writable regions heap_stack_executable, // Heap, stack, and executable regions heap_stack_executable_bss // Above plus BSS segments }; Struct: region_flags struct region_flags { bool read : 1; // Read permission bool write : 1; // Write permission bool exec : 1; // Execute permission bool shared : 1; // Shared mapping bool private_ : 1; // Private mapping }; Struct: region struct region { void* start; // Starting address std::size_t size; // Region size in bytes region_type type; // Region classification region_flags flags; // Permission flags void* load_addr; // Load address for ELF files std::string filename; // Associated file path std::size_t id; // Unique identifier [[nodiscard]] bool is_readable() const noexcept; [[nodiscard]] bool is_writable() const noexcept; [[nodiscard]] bool is_executable() const noexcept; [[nodiscard]] bool is_shared() const noexcept; [[nodiscard]] bool is_private() const noexcept; [[nodiscard]] std::pair<void*, std::size_t> as_span() const noexcept; [[nodiscard]] bool contains(void* address) const noexcept; }; Struct: maps_reader::error struct error { std::string message; // Human-readable error description std::error_code code; // System error code }; Class: maps_reader Static Methods [[nodiscard]] static std::expected<std::vector<region>, error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all); Convenience Functions [[nodiscard]] std::expected<std::vector<region>, maps_reader::error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all); Usage Examples import maps; // Basic usage auto regions = maps::read_process_maps(1234); // Filtered scanning auto heap_regions = maps::read_process_maps( pid, maps::region_scan_level::heap_stack_executable ); // Error handling if (!regions) { std::cerr << \"Error: \" << regions.error().message << \"\\n\"; } endianness Namespace: endianness Functions // Endianness detection constexpr bool is_big_endian() noexcept; constexpr bool is_little_endian() noexcept; // Byte swapping constexpr uint8_t swap_bytes(uint8_t value) noexcept; constexpr uint16_t swap_bytes(uint16_t value) noexcept; constexpr uint32_t swap_bytes(uint32_t value) noexcept; constexpr uint64_t swap_bytes(uint64_t value) noexcept; template<typename T> constexpr T swap_bytes_integral(T value) noexcept; void swap_bytes_inplace(void* data, size_t size); // Endianness correction void fix_endianness(Value& value, bool reverse_endianness) noexcept; // Network byte order template<SwappableIntegral T> constexpr T host_to_network(T value) noexcept; template<SwappableIntegral T> constexpr T network_to_host(T value) noexcept; // Little-endian conversion template<SwappableIntegral T> constexpr T host_to_little_endian(T value) noexcept; template<SwappableIntegral T> constexpr T little_endian_to_host(T value) noexcept; Concept template<typename T> concept SwappableIntegral = std::integral<T> && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8); process_checker Enum: ProcessState enum class ProcessState { RUNNING, ERROR, DEAD, ZOMBIE }; Class: ProcessChecker ProcessChecker Static Methods static ProcessState check_process(pid_t pid); static bool is_process_dead(pid_t pid); sets Struct: Set struct Set { std::vector<size_t> buf; size_t size() const; void clear(); static int cmp(const size_t& i1, const size_t& i2); }; Set Functions bool parse_uintset(std::string_view lptr, Set& set, size_t maxSZ); Deprecated [[deprecated]] constexpr auto inc_arr_sz = [](size_t** valarr, size_t* arr_maxsz, size_t maxsz) -> bool; show_message Enum: MessageType enum class MessageType : uint8_t { INFO, WARN, ERROR, DEBUG, USER }; Struct: MessageContext struct MessageContext { bool debugMode = false; bool backendMode = false; }; Class: MessagePrinter Constructor MessagePrinter(MessageContext ctx = {}); Methods template<typename... Args> void print(MessageType type, std::string_view fmt, Args&&... args) const; template<typename... Args> void info(std::string_view fmt, Args&&... args) const; template<typename... Args> void warn(std::string_view fmt, Args&&... args) const; template<typename... Args> void error(std::string_view fmt, Args&&... args) const; template<typename... Args> void debug(std::string_view fmt, Args&&... args) const; template<typename... Args> void user(std::string_view fmt, Args&&... args) const; [[nodiscard]] const MessageContext& conext() const; targetmem Struct: OldValueAndMatchInfo struct OldValueAndMatchInfo { uint8_t old_value; MatchFlags match_info; }; Class: MatchesAndOldValuesSwath class MatchesAndOldValuesSwath { public: void* firstByteInChild = nullptr; std::vector<OldValueAndMatchInfo> data; MatchesAndOldValuesSwath() = default; void addElement(void* addr, uint8_t byte, MatchFlags matchFlags); std::string toPrintableString(size_t idx, size_t len) const; std::string toByteArrayText(size_t idx, size_t len) const; }; Class: MatchesAndOldValuesArray class MatchesAndOldValuesArray { public: size_t maxNeededBytes; std::vector<MatchesAndOldValuesSwath> swaths; MatchesAndOldValuesArray(size_t maxBytes); void addSwath(const MatchesAndOldValuesSwath& swath); std::optional<std::pair<MatchesAndOldValuesSwath*, size_t>> nthMatch(size_t n); void deleteInAddressRange(void* start, void* end, unsigned long& numMatches); }; value Enum: MatchFlags enum class [[gnu::packed]] MatchFlags : uint16_t { EMPTY = 0, U8B = 1 << 0, S8B = 1 << 1, U16B = 1 << 2, S16B = 1 << 3, U32B = 1 << 4, S32B = 1 << 5, U64B = 1 << 6, S64B = 1 << 7, F32B = 1 << 8, F64B = 1 << 9, I8B = U8B | S8B, I16B = U16B | S16B, I32B = U32B | S32B, I64B = U64B | S64B, INTEGER = I8B | I16B | I32B | I64B, FLOAT = F32B | F64B, ALL = INTEGER | FLOAT, B8 = I8B, B16 = I16B, B32 = I32B | F32B, B64 = I64B | F64B, MAX = 0xffffU }; Enum: Wildcard enum class Wildcard : uint8_t { FIXED = 0xffU, WILDCARD = 0x00U }; Struct: Value struct [[gnu::packed]] Value { std::vector<uint8_t> bytes; // Snapshot bytes MatchFlags flags = MatchFlags::EMPTY; // Type/width flag constexpr static void zero(Value& val); std::span<const uint8_t> view() const noexcept; void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& val); void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f); void setBytesWithFlag(const std::vector<uint8_t>& val, MatchFlags f); template <typename T> void setScalar(const T& v); template <typename T> void setScalarWithFlag(const T& v, MatchFlags f); template <typename T> void setScalarTyped(const T& v); }; Strict numeric decoding: the requested type must match flags and width must be sufficient. Struct: Mem64 struct [[gnu::packed]] Mem64 { std::vector<uint8_t> buffer; // Current bytes template <typename T> T get() const; // memcpy-based decode std::span<const uint8_t> bytes() const noexcept; // read-only view void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& data); void setString(const std::string& s); template <typename T> void setScalar(const T& v); }; Struct: UserValue struct [[gnu::packed]] UserValue { int8_t int8_value = 0; uint8_t uint8_value = 0; int16_t int16_value = 0; uint16_t uint16_value = 0; int32_t int32_value = 0; uint32_t uint32_value = 0; int64_t int64_value = 0; uint64_t uint64_value = 0; float float32_value = 0.0F; double float64_value = 0.0; std::optional<std::vector<uint8_t>> bytearray_value; std::optional<std::vector<uint8_t>> byteMask; // 0xFF=fixed, 0x00=wildcard std::optional<Wildcard> wildcard_value; std::string string_value; MatchFlags flags = MatchFlags::EMPTY; }; Usage Patterns Common Patterns 1. Process Checking auto state = ProcessChecker::check_process(pid); if (state == ProcessState::RUNNING) { /* ... */ } 2. Set Parsing Set mySet; if (parse_uintset(\"1,2,3,10..15\", mySet, 100)) { // Use parsed set } 3. Message Printing MessagePrinter printer{.debugMode = true}; printer.info(\"Process {} is running\", pid); printer.error(\"Failed to read memory at 0x{:08x}\", address); 4. Memory Analysis MatchesAndOldValuesArray matches(4096); MatchesAndOldValuesSwath swath; swath.addElement(addr, byte, MatchFlags::U32B); matches.addSwath(swath); 5. Value Handling Value val = uint32_t{42}; val.flags = MatchFlags::U32B; Mem64 mem64; mem64.set<double>(3.14159); auto value = mem64.get<double>(); Error Handling Return Values parse_uintset : Returns bool (true/false) nthMatch : Returns std::optional check_process : Returns ProcessState Exceptions Mem64::get<T>() : Throws std::bad_variant_access on type mismatch Format strings: Throw appropriate exceptions on format errors","title":"API Reference"},{"location":"en/API_REFERENCE/#api-reference","text":"","title":"API Reference"},{"location":"en/API_REFERENCE/#module-index","text":"endianness maps process_checker sets show_message targetmem value","title":"Module Index"},{"location":"en/API_REFERENCE/#enum-region_type","text":"enum class region_type : uint8_t { misc, // Miscellaneous memory regions exe, // Executable binary regions code, // Code segments (shared libraries, etc.) heap, // Heap memory regions stack // Stack memory regions }; constexpr std::array<std::string_view, 5> region_type_names;","title":"Enum: region_type"},{"location":"en/API_REFERENCE/#enum-region_scan_level","text":"enum class region_scan_level : uint8_t { all, // All readable regions all_rw, // All readable/writable regions heap_stack_executable, // Heap, stack, and executable regions heap_stack_executable_bss // Above plus BSS segments };","title":"Enum: region_scan_level"},{"location":"en/API_REFERENCE/#struct-region_flags","text":"struct region_flags { bool read : 1; // Read permission bool write : 1; // Write permission bool exec : 1; // Execute permission bool shared : 1; // Shared mapping bool private_ : 1; // Private mapping };","title":"Struct: region_flags"},{"location":"en/API_REFERENCE/#struct-region","text":"struct region { void* start; // Starting address std::size_t size; // Region size in bytes region_type type; // Region classification region_flags flags; // Permission flags void* load_addr; // Load address for ELF files std::string filename; // Associated file path std::size_t id; // Unique identifier [[nodiscard]] bool is_readable() const noexcept; [[nodiscard]] bool is_writable() const noexcept; [[nodiscard]] bool is_executable() const noexcept; [[nodiscard]] bool is_shared() const noexcept; [[nodiscard]] bool is_private() const noexcept; [[nodiscard]] std::pair<void*, std::size_t> as_span() const noexcept; [[nodiscard]] bool contains(void* address) const noexcept; };","title":"Struct: region"},{"location":"en/API_REFERENCE/#struct-maps_readererror","text":"struct error { std::string message; // Human-readable error description std::error_code code; // System error code };","title":"Struct: maps_reader::error"},{"location":"en/API_REFERENCE/#class-maps_reader","text":"","title":"Class: maps_reader"},{"location":"en/API_REFERENCE/#static-methods","text":"[[nodiscard]] static std::expected<std::vector<region>, error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);","title":"Static Methods"},{"location":"en/API_REFERENCE/#convenience-functions","text":"[[nodiscard]] std::expected<std::vector<region>, maps_reader::error> read_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);","title":"Convenience Functions"},{"location":"en/API_REFERENCE/#usage-examples","text":"import maps; // Basic usage auto regions = maps::read_process_maps(1234); // Filtered scanning auto heap_regions = maps::read_process_maps( pid, maps::region_scan_level::heap_stack_executable ); // Error handling if (!regions) { std::cerr << \"Error: \" << regions.error().message << \"\\n\"; }","title":"Usage Examples"},{"location":"en/API_REFERENCE/#namespace-endianness","text":"","title":"Namespace: endianness"},{"location":"en/API_REFERENCE/#functions","text":"// Endianness detection constexpr bool is_big_endian() noexcept; constexpr bool is_little_endian() noexcept; // Byte swapping constexpr uint8_t swap_bytes(uint8_t value) noexcept; constexpr uint16_t swap_bytes(uint16_t value) noexcept; constexpr uint32_t swap_bytes(uint32_t value) noexcept; constexpr uint64_t swap_bytes(uint64_t value) noexcept; template<typename T> constexpr T swap_bytes_integral(T value) noexcept; void swap_bytes_inplace(void* data, size_t size); // Endianness correction void fix_endianness(Value& value, bool reverse_endianness) noexcept; // Network byte order template<SwappableIntegral T> constexpr T host_to_network(T value) noexcept; template<SwappableIntegral T> constexpr T network_to_host(T value) noexcept; // Little-endian conversion template<SwappableIntegral T> constexpr T host_to_little_endian(T value) noexcept; template<SwappableIntegral T> constexpr T little_endian_to_host(T value) noexcept;","title":"Functions"},{"location":"en/API_REFERENCE/#concept","text":"template<typename T> concept SwappableIntegral = std::integral<T> && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8);","title":"Concept"},{"location":"en/API_REFERENCE/#enum-processstate","text":"enum class ProcessState { RUNNING, ERROR, DEAD, ZOMBIE };","title":"Enum: ProcessState"},{"location":"en/API_REFERENCE/#class-processchecker","text":"","title":"Class: ProcessChecker"},{"location":"en/API_REFERENCE/#processchecker-static-methods","text":"static ProcessState check_process(pid_t pid); static bool is_process_dead(pid_t pid);","title":"ProcessChecker Static Methods"},{"location":"en/API_REFERENCE/#struct-set","text":"struct Set { std::vector<size_t> buf; size_t size() const; void clear(); static int cmp(const size_t& i1, const size_t& i2); };","title":"Struct: Set"},{"location":"en/API_REFERENCE/#set-functions","text":"bool parse_uintset(std::string_view lptr, Set& set, size_t maxSZ);","title":"Set Functions"},{"location":"en/API_REFERENCE/#deprecated","text":"[[deprecated]] constexpr auto inc_arr_sz = [](size_t** valarr, size_t* arr_maxsz, size_t maxsz) -> bool;","title":"Deprecated"},{"location":"en/API_REFERENCE/#enum-messagetype","text":"enum class MessageType : uint8_t { INFO, WARN, ERROR, DEBUG, USER };","title":"Enum: MessageType"},{"location":"en/API_REFERENCE/#struct-messagecontext","text":"struct MessageContext { bool debugMode = false; bool backendMode = false; };","title":"Struct: MessageContext"},{"location":"en/API_REFERENCE/#class-messageprinter","text":"","title":"Class: MessagePrinter"},{"location":"en/API_REFERENCE/#constructor","text":"MessagePrinter(MessageContext ctx = {});","title":"Constructor"},{"location":"en/API_REFERENCE/#methods","text":"template<typename... Args> void print(MessageType type, std::string_view fmt, Args&&... args) const; template<typename... Args> void info(std::string_view fmt, Args&&... args) const; template<typename... Args> void warn(std::string_view fmt, Args&&... args) const; template<typename... Args> void error(std::string_view fmt, Args&&... args) const; template<typename... Args> void debug(std::string_view fmt, Args&&... args) const; template<typename... Args> void user(std::string_view fmt, Args&&... args) const; [[nodiscard]] const MessageContext& conext() const;","title":"Methods"},{"location":"en/API_REFERENCE/#struct-oldvalueandmatchinfo","text":"struct OldValueAndMatchInfo { uint8_t old_value; MatchFlags match_info; };","title":"Struct: OldValueAndMatchInfo"},{"location":"en/API_REFERENCE/#class-matchesandoldvaluesswath","text":"class MatchesAndOldValuesSwath { public: void* firstByteInChild = nullptr; std::vector<OldValueAndMatchInfo> data; MatchesAndOldValuesSwath() = default; void addElement(void* addr, uint8_t byte, MatchFlags matchFlags); std::string toPrintableString(size_t idx, size_t len) const; std::string toByteArrayText(size_t idx, size_t len) const; };","title":"Class: MatchesAndOldValuesSwath"},{"location":"en/API_REFERENCE/#class-matchesandoldvaluesarray","text":"class MatchesAndOldValuesArray { public: size_t maxNeededBytes; std::vector<MatchesAndOldValuesSwath> swaths; MatchesAndOldValuesArray(size_t maxBytes); void addSwath(const MatchesAndOldValuesSwath& swath); std::optional<std::pair<MatchesAndOldValuesSwath*, size_t>> nthMatch(size_t n); void deleteInAddressRange(void* start, void* end, unsigned long& numMatches); };","title":"Class: MatchesAndOldValuesArray"},{"location":"en/API_REFERENCE/#enum-matchflags","text":"enum class [[gnu::packed]] MatchFlags : uint16_t { EMPTY = 0, U8B = 1 << 0, S8B = 1 << 1, U16B = 1 << 2, S16B = 1 << 3, U32B = 1 << 4, S32B = 1 << 5, U64B = 1 << 6, S64B = 1 << 7, F32B = 1 << 8, F64B = 1 << 9, I8B = U8B | S8B, I16B = U16B | S16B, I32B = U32B | S32B, I64B = U64B | S64B, INTEGER = I8B | I16B | I32B | I64B, FLOAT = F32B | F64B, ALL = INTEGER | FLOAT, B8 = I8B, B16 = I16B, B32 = I32B | F32B, B64 = I64B | F64B, MAX = 0xffffU };","title":"Enum: MatchFlags"},{"location":"en/API_REFERENCE/#enum-wildcard","text":"enum class Wildcard : uint8_t { FIXED = 0xffU, WILDCARD = 0x00U };","title":"Enum: Wildcard"},{"location":"en/API_REFERENCE/#struct-value","text":"struct [[gnu::packed]] Value { std::vector<uint8_t> bytes; // Snapshot bytes MatchFlags flags = MatchFlags::EMPTY; // Type/width flag constexpr static void zero(Value& val); std::span<const uint8_t> view() const noexcept; void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& val); void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f); void setBytesWithFlag(const std::vector<uint8_t>& val, MatchFlags f); template <typename T> void setScalar(const T& v); template <typename T> void setScalarWithFlag(const T& v, MatchFlags f); template <typename T> void setScalarTyped(const T& v); }; Strict numeric decoding: the requested type must match flags and width must be sufficient.","title":"Struct: Value"},{"location":"en/API_REFERENCE/#struct-mem64","text":"struct [[gnu::packed]] Mem64 { std::vector<uint8_t> buffer; // Current bytes template <typename T> T get() const; // memcpy-based decode std::span<const uint8_t> bytes() const noexcept; // read-only view void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& data); void setString(const std::string& s); template <typename T> void setScalar(const T& v); };","title":"Struct: Mem64"},{"location":"en/API_REFERENCE/#struct-uservalue","text":"struct [[gnu::packed]] UserValue { int8_t int8_value = 0; uint8_t uint8_value = 0; int16_t int16_value = 0; uint16_t uint16_value = 0; int32_t int32_value = 0; uint32_t uint32_value = 0; int64_t int64_value = 0; uint64_t uint64_value = 0; float float32_value = 0.0F; double float64_value = 0.0; std::optional<std::vector<uint8_t>> bytearray_value; std::optional<std::vector<uint8_t>> byteMask; // 0xFF=fixed, 0x00=wildcard std::optional<Wildcard> wildcard_value; std::string string_value; MatchFlags flags = MatchFlags::EMPTY; };","title":"Struct: UserValue"},{"location":"en/API_REFERENCE/#usage-patterns","text":"","title":"Usage Patterns"},{"location":"en/API_REFERENCE/#common-patterns","text":"","title":"Common Patterns"},{"location":"en/API_REFERENCE/#1-process-checking","text":"auto state = ProcessChecker::check_process(pid); if (state == ProcessState::RUNNING) { /* ... */ }","title":"1. Process Checking"},{"location":"en/API_REFERENCE/#2-set-parsing","text":"Set mySet; if (parse_uintset(\"1,2,3,10..15\", mySet, 100)) { // Use parsed set }","title":"2. Set Parsing"},{"location":"en/API_REFERENCE/#3-message-printing","text":"MessagePrinter printer{.debugMode = true}; printer.info(\"Process {} is running\", pid); printer.error(\"Failed to read memory at 0x{:08x}\", address);","title":"3. Message Printing"},{"location":"en/API_REFERENCE/#4-memory-analysis","text":"MatchesAndOldValuesArray matches(4096); MatchesAndOldValuesSwath swath; swath.addElement(addr, byte, MatchFlags::U32B); matches.addSwath(swath);","title":"4. Memory Analysis"},{"location":"en/API_REFERENCE/#5-value-handling","text":"Value val = uint32_t{42}; val.flags = MatchFlags::U32B; Mem64 mem64; mem64.set<double>(3.14159); auto value = mem64.get<double>();","title":"5. Value Handling"},{"location":"en/API_REFERENCE/#error-handling","text":"","title":"Error Handling"},{"location":"en/API_REFERENCE/#return-values","text":"parse_uintset : Returns bool (true/false) nthMatch : Returns std::optional check_process : Returns ProcessState","title":"Return Values"},{"location":"en/API_REFERENCE/#exceptions","text":"Mem64::get<T>() : Throws std::bad_variant_access on type mismatch Format strings: Throw appropriate exceptions on format errors","title":"Exceptions"},{"location":"en/NamingConvention/","text":"C++ Naming Conventions 1. Classes and Structures Class Names : Use CamelCase style. Example: cpp class MyClassName {}; Structure Names : Use CamelCase style. Example: cpp struct MyStructName {}; 2. Enums Enum Type Names : Use CamelCase style. Example: cpp enum MyEnumType {}; Enum Constant Names : Use UPPER_CASE style. Example: cpp enum MyEnumType { ENUM_CONSTANT_ONE, ENUM_CONSTANT_TWO }; 3. Functions Function Names : Use camelBack style. Example: cpp void myFunctionName(); 4. Variables Regular Variable Names : Use camelBack style. Example: cpp int myVariableName; Global Variable Names : Use UPPER_CASE style. Example: cpp int GLOBAL_VARIABLE_NAME; Constant Names : Use UPPER_CASE style. Example: cpp const int MAX_BUFFER_SIZE = 1024; 5. Parameters Function Parameter Names : Use camelBack style. Example: cpp void myFunction(int parameterName); 6. Namespaces Namespace Names : Use lower_case style. Example: cpp namespace my_namespace { void myFunction(); } 7. Macros Macro Names : Use UPPER_CASE style. Example: ```cpp define MAX_BUFFER_SIZE 1024 ``` 8. Member Variables Private Member Variables : Prefix with m_ and use camelBack style. Example: cpp class MyClass { private: int m_privateMember; }; Protected Member Variables : Prefix with m_ and use camelBack style. Example: cpp class MyClass { protected: int m_protectedMember; }; Static Member Variables : Prefix with s_ and use camelBack style. Example: cpp class MyClass { private: static int s_staticMember; }; Public Member Variables : Use camelBack style. Example: cpp class MyClass { public: int publicMemberVariable; }; 9. Special Rules Disabled Rules : Disable modernize-use-trailing-return-type . Disable modernize-avoid-c-arrays .","title":"Naming Convention"},{"location":"en/NamingConvention/#c-naming-conventions","text":"","title":"C++ Naming Conventions"},{"location":"en/NamingConvention/#1-classes-and-structures","text":"Class Names : Use CamelCase style. Example: cpp class MyClassName {}; Structure Names : Use CamelCase style. Example: cpp struct MyStructName {};","title":"1. Classes and Structures"},{"location":"en/NamingConvention/#2-enums","text":"Enum Type Names : Use CamelCase style. Example: cpp enum MyEnumType {}; Enum Constant Names : Use UPPER_CASE style. Example: cpp enum MyEnumType { ENUM_CONSTANT_ONE, ENUM_CONSTANT_TWO };","title":"2. Enums"},{"location":"en/NamingConvention/#3-functions","text":"Function Names : Use camelBack style. Example: cpp void myFunctionName();","title":"3. Functions"},{"location":"en/NamingConvention/#4-variables","text":"Regular Variable Names : Use camelBack style. Example: cpp int myVariableName; Global Variable Names : Use UPPER_CASE style. Example: cpp int GLOBAL_VARIABLE_NAME; Constant Names : Use UPPER_CASE style. Example: cpp const int MAX_BUFFER_SIZE = 1024;","title":"4. Variables"},{"location":"en/NamingConvention/#5-parameters","text":"Function Parameter Names : Use camelBack style. Example: cpp void myFunction(int parameterName);","title":"5. Parameters"},{"location":"en/NamingConvention/#6-namespaces","text":"Namespace Names : Use lower_case style. Example: cpp namespace my_namespace { void myFunction(); }","title":"6. Namespaces"},{"location":"en/NamingConvention/#7-macros","text":"Macro Names : Use UPPER_CASE style. Example: ```cpp","title":"7. Macros"},{"location":"en/NamingConvention/#8-member-variables","text":"Private Member Variables : Prefix with m_ and use camelBack style. Example: cpp class MyClass { private: int m_privateMember; }; Protected Member Variables : Prefix with m_ and use camelBack style. Example: cpp class MyClass { protected: int m_protectedMember; }; Static Member Variables : Prefix with s_ and use camelBack style. Example: cpp class MyClass { private: static int s_staticMember; }; Public Member Variables : Use camelBack style. Example: cpp class MyClass { public: int publicMemberVariable; };","title":"8. Member Variables"},{"location":"en/NamingConvention/#9-special-rules","text":"Disabled Rules : Disable modernize-use-trailing-return-type . Disable modernize-avoid-c-arrays .","title":"9. Special Rules"},{"location":"en/endianness/","text":"Endianness Module Documentation Overview The endianness module provides comprehensive byte order handling utilities for the NewScanmem project. It supports both compile-time and runtime endianness detection, byte swapping operations, and automatic endianness correction for various data types. Module Structure export module endianness; Dependencies <cstdint> - Fixed-width integer types <cstring> - C string operations <bit> - Bit operations and endian detection <type_traits> - Type traits for template metaprogramming <concepts> - C++20 concepts value module - Value type definitions Core Features 1. Endianness Detection Compile-time Detection constexpr bool isBigEndian() noexcept; constexpr bool isLittleEndian() noexcept; Uses std::endian::native to determine host endianness at compile time. 2. Byte Swapping Functions Basic Byte Swapping constexpr uint8_t swapBytes(uint8_t value) noexcept; constexpr uint16_t swapBytes(uint16_t value) noexcept; constexpr uint32_t swapBytes(uint32_t value) noexcept; constexpr uint64_t swapBytes(uint64_t value) noexcept; Generic Byte Swapping template<typename T> constexpr T swapBytesIntegral(T value) noexcept; Supports integer types of sizes 1, 2, 4, and 8 bytes. 3. Endianness Correction for Value Types void fixEndianness(Value& value, bool reverseEndianness) noexcept; Performs in-place endianness correction on Value.bytes based on flags (width 2/4/8). 4. Network Byte Order Conversion template<SwappableIntegral T> constexpr T hostToNetwork(T value) noexcept; template<SwappableIntegral T> constexpr T networkToHost(T value) noexcept; Converts between host and network byte order (big-endian). 5. Little-endian Conversion template<SwappableIntegral T> constexpr T hostToLittleEndian(T value) noexcept; template<SwappableIntegral T> constexpr T littleEndianToHost(T value) noexcept; Usage Examples Examples Basic Byte Swapping import endianness; uint32_t value = 0x12345678; uint32_t swapped = endianness::swapBytes(value); // swapped = 0x78563412 on little-endian systems Endianness Correction import endianness; import value; Value val = uint32_t{0x12345678}; endianness::fixEndianness(val, true); // Reverse endianness Network Communication uint16_t port = 8080; uint16_t networkPort = endianness::hostToNetwork(port); Concepts and Constraints SwappableIntegral Concept template<typename T> concept SwappableIntegral = std::integral<T> && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8); Restricts byte swapping operations to integral types of specific sizes. Implementation Details Byte Swapping Algorithms 16-bit : Uses bit rotation: (value << 8) | (value >> 8) 32-bit : Uses bit masking and shifting for optimal performance 64-bit : Uses bit masking and shifting across 8 bytes Compile-time Optimization All byte swapping operations are marked constexpr for compile-time evaluation when possible. Type Safety Uses C++20 concepts to ensure type safety and provide clear error messages for unsupported types. Error Handling swapBytesIntegral uses static_assert for compile-time type checking swapBytesInPlace silently ignores unsupported sizes fixEndianness infers width from flags (B16/B32/B64) and swaps Value.bytes in place Performance Considerations All operations are constexpr for compile-time optimization Byte swapping uses efficient bit manipulation operations No dynamic memory allocation Minimal runtime overhead for supported types Integration with CLI The endianness module is utilized in the CLI for automatic byte order handling during memory scanning operations. For example, the scan command leverages this module to ensure correct endianness for target values. See Also Value Module - For Value type definitions Target Memory Module - For memory analysis operations","title":"Endianness"},{"location":"en/endianness/#endianness-module-documentation","text":"","title":"Endianness Module Documentation"},{"location":"en/endianness/#overview","text":"The endianness module provides comprehensive byte order handling utilities for the NewScanmem project. It supports both compile-time and runtime endianness detection, byte swapping operations, and automatic endianness correction for various data types.","title":"Overview"},{"location":"en/endianness/#module-structure","text":"export module endianness;","title":"Module Structure"},{"location":"en/endianness/#dependencies","text":"<cstdint> - Fixed-width integer types <cstring> - C string operations <bit> - Bit operations and endian detection <type_traits> - Type traits for template metaprogramming <concepts> - C++20 concepts value module - Value type definitions","title":"Dependencies"},{"location":"en/endianness/#core-features","text":"","title":"Core Features"},{"location":"en/endianness/#1-endianness-detection","text":"","title":"1. Endianness Detection"},{"location":"en/endianness/#compile-time-detection","text":"constexpr bool isBigEndian() noexcept; constexpr bool isLittleEndian() noexcept; Uses std::endian::native to determine host endianness at compile time.","title":"Compile-time Detection"},{"location":"en/endianness/#2-byte-swapping-functions","text":"","title":"2. Byte Swapping Functions"},{"location":"en/endianness/#basic-byte-swapping","text":"constexpr uint8_t swapBytes(uint8_t value) noexcept; constexpr uint16_t swapBytes(uint16_t value) noexcept; constexpr uint32_t swapBytes(uint32_t value) noexcept; constexpr uint64_t swapBytes(uint64_t value) noexcept;","title":"Basic Byte Swapping"},{"location":"en/endianness/#generic-byte-swapping","text":"template<typename T> constexpr T swapBytesIntegral(T value) noexcept; Supports integer types of sizes 1, 2, 4, and 8 bytes.","title":"Generic Byte Swapping"},{"location":"en/endianness/#3-endianness-correction-for-value-types","text":"void fixEndianness(Value& value, bool reverseEndianness) noexcept; Performs in-place endianness correction on Value.bytes based on flags (width 2/4/8).","title":"3. Endianness Correction for Value Types"},{"location":"en/endianness/#4-network-byte-order-conversion","text":"template<SwappableIntegral T> constexpr T hostToNetwork(T value) noexcept; template<SwappableIntegral T> constexpr T networkToHost(T value) noexcept; Converts between host and network byte order (big-endian).","title":"4. Network Byte Order Conversion"},{"location":"en/endianness/#5-little-endian-conversion","text":"template<SwappableIntegral T> constexpr T hostToLittleEndian(T value) noexcept; template<SwappableIntegral T> constexpr T littleEndianToHost(T value) noexcept;","title":"5. Little-endian Conversion"},{"location":"en/endianness/#usage-examples","text":"","title":"Usage Examples"},{"location":"en/endianness/#examples-basic-byte-swapping","text":"import endianness; uint32_t value = 0x12345678; uint32_t swapped = endianness::swapBytes(value); // swapped = 0x78563412 on little-endian systems","title":"Examples Basic Byte Swapping"},{"location":"en/endianness/#endianness-correction","text":"import endianness; import value; Value val = uint32_t{0x12345678}; endianness::fixEndianness(val, true); // Reverse endianness","title":"Endianness Correction"},{"location":"en/endianness/#network-communication","text":"uint16_t port = 8080; uint16_t networkPort = endianness::hostToNetwork(port);","title":"Network Communication"},{"location":"en/endianness/#concepts-and-constraints","text":"","title":"Concepts and Constraints"},{"location":"en/endianness/#swappableintegral-concept","text":"template<typename T> concept SwappableIntegral = std::integral<T> && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8); Restricts byte swapping operations to integral types of specific sizes.","title":"SwappableIntegral Concept"},{"location":"en/endianness/#implementation-details","text":"","title":"Implementation Details"},{"location":"en/endianness/#byte-swapping-algorithms","text":"16-bit : Uses bit rotation: (value << 8) | (value >> 8) 32-bit : Uses bit masking and shifting for optimal performance 64-bit : Uses bit masking and shifting across 8 bytes","title":"Byte Swapping Algorithms"},{"location":"en/endianness/#compile-time-optimization","text":"All byte swapping operations are marked constexpr for compile-time evaluation when possible.","title":"Compile-time Optimization"},{"location":"en/endianness/#type-safety","text":"Uses C++20 concepts to ensure type safety and provide clear error messages for unsupported types.","title":"Type Safety"},{"location":"en/endianness/#error-handling","text":"swapBytesIntegral uses static_assert for compile-time type checking swapBytesInPlace silently ignores unsupported sizes fixEndianness infers width from flags (B16/B32/B64) and swaps Value.bytes in place","title":"Error Handling"},{"location":"en/endianness/#performance-considerations","text":"All operations are constexpr for compile-time optimization Byte swapping uses efficient bit manipulation operations No dynamic memory allocation Minimal runtime overhead for supported types","title":"Performance Considerations"},{"location":"en/endianness/#integration-with-cli","text":"The endianness module is utilized in the CLI for automatic byte order handling during memory scanning operations. For example, the scan command leverages this module to ensure correct endianness for target values.","title":"Integration with CLI"},{"location":"en/endianness/#see-also","text":"Value Module - For Value type definitions Target Memory Module - For memory analysis operations","title":"See Also"},{"location":"en/main/","text":"Main Application Documentation Overview The main.cpp file serves as the entry point for the NewScanmem application. It demonstrates basic module integration and provides a foundation for the memory scanning utility. File Structure import sets; int main() { Set val; return 0; } Current Implementation The current main function is minimal and serves as a placeholder for: Module Integration Testing : Demonstrates that the sets module can be successfully imported and used Basic Framework : Provides a starting point for application development Compilation Verification : Ensures all modules compile correctly together Planned Features Command Line Interface // Future implementation int main(int argc, char* argv[]) { // Parse command line arguments // Initialize modules // Start memory scanning // Display results } Integration Points The main application will integrate all modules: Process Management (process_checker) Target process selection Process state monitoring Permission checking Memory Analysis (targetmem) Memory region scanning Value matching Pattern detection Data Types (value) Multi-type value support Endianness handling Byte array operations Utilities (sets, endianness, show_message) Set operations for results Byte order conversion User messaging and logging Usage Examples Basic Execution # Current usage ./newscanmem # Future usage examples ./newscanmem --pid 1234 --type int32 --value 42 ./newscanmem --pid 1234 --range 0x1000-0x2000 --string \"hello\" ./newscanmem --pid 1234 --float --tolerance 0.001 Development Roadmap Phase 1: Basic Framework [ ] Command line argument parsing [ ] Process selection and validation [ ] Basic memory scanning [ ] Result display Phase 2: Advanced Features [ ] Multiple value type support [ ] Memory region filtering [ ] Pattern matching [ ] Interactive mode Phase 3: Optimization [ ] Performance tuning [ ] Memory usage optimization [ ] Parallel processing [ ] Result caching Phase 4: UI/UX [ ] Progress indicators [ ] Color output [ ] Export formats [ ] Configuration files Module Integration Example // Future main.cpp structure import process_checker; import targetmem; import value; import show_message; import sets; import endianness; int main(int argc, char* argv[]) { MessagePrinter printer; // Parse arguments if (argc < 2) { printer.error(\"Usage: {} --pid <pid> [...]\", argv[0]); return 1; } // Check process pid_t pid = std::stoi(argv[2]); if (ProcessChecker::is_process_dead(pid)) { printer.error(\"Process {} is not running\", pid); return 1; } // Initialize scanner printer.info(\"Scanning process {}...\", pid); // Perform scan MatchesAndOldValuesArray matches(get_memory_size(pid)); // ... scanning logic ... // Display results printer.info(\"Found {} matches\", get_total_matches(matches)); return 0; } Build Instructions Current Build # Build the project mkdir build && cd build cmake .. make # Run the application ./newscanmem Module Dependencies The main application depends on all modules: sets - Set operations and parsing process_checker - Process state checking targetmem - Memory analysis structures value - Value type definitions endianness - Byte order handling show_message - Message and logging system Testing Framework Unit Tests // Test basic functionality void test_main_integration() { Set test_set; bool parse_result = parse_uintset(\"1,2,3\", test_set, 100); assert(parse_result == true); assert(test_set.size() == 3); std::cout << \"Main integration test passed!\\n\"; } int main() { test_main_integration(); return 0; } Configuration Environment Variables Future versions may support: SCANMEM_DEBUG : Enable debug mode SCANMEM_BACKEND : Enable backend mode SCANMEM_LOG_FILE : Log file path Configuration Files # ~/.scanmemrc example [general] debug=true backend=false [scanning] default_type=int32 batch_size=1000 timeout=30 Error Handling Current Error Handling The current implementation provides minimal error handling through: Module import verification Basic compilation checks Placeholder return codes Future Error Handling enum class ScanError { SUCCESS = 0, INVALID_PID, PROCESS_NOT_FOUND, PERMISSION_DENIED, MEMORY_ACCESS_FAILED, INVALID_ARGUMENTS, OUT_OF_MEMORY }; ScanError perform_scan(const ScanConfig& config); Security Considerations Current Security No elevated privileges required Read-only memory access Process permission validation Future Security Capability checking Sandboxing considerations Secure memory access patterns Input validation Performance Metrics Current Metrics Compilation time: ~2-3 seconds Binary size: ~50KB (minimal) Memory usage: ~1MB (minimal) Target Metrics Scan speed: 1GB/sec for basic types Memory usage: <100MB for large processes Response time: <1 second for initial results Platform Compatibility Current Support Linux : Full support (primary platform) macOS : Planned support Windows : Not currently supported System Requirements OS : Linux with /proc filesystem Compiler : C++23 with modules support Memory : 64MB minimum, 1GB recommended Permissions : Read access to target process memory Debugging Debug Build # Build with debug symbols cmake -DCMAKE_BUILD_TYPE=Debug .. make # Run with debugger gdb ./newscanmem (gdb) run --pid 1234 Logging // Enable debug logging MessageContext ctx{.debugMode = true}; MessagePrinter printer(ctx); printer.debug(\"Starting scan for PID: {}\", pid); Future API Design Future API Command Line Interface # Basic scan ./newscanmem --pid 1234 --int32 42 # Advanced scan ./newscanmem --pid 1234 --range 0x1000-0xFFFF --float 3.14 --tolerance 0.001 # Interactive mode ./newscanmem --interactive # Batch mode ./newscanmem --pid 1234 --batch --output results.json Programmatic API // Future C++ API class ScanManager { public: ScanResult scan(const ScanConfig& config); void set_progress_callback(ProgressCallback callback); void cancel_scan(); }; See Also Sets Module - Set operations and parsing Process Checker Module - Process state checking Target Memory Module - Memory analysis structures Value Module - Value type definitions Endianness Module - Byte order handling Show Message Module - Message and logging system Contributing Development Setup # Clone repository git clone https://github.com/your-org/newscanmem.git cd newscanmem # Install dependencies sudo apt install build-essential cmake libboost-all-dev # Build and test mkdir build && cd build cmake .. make test Code Style Use modern C++23 features Follow RAII principles Prefer compile-time checks Use modules for encapsulation Document public APIs License and Legal This project is part of the NewScanmem memory scanning utility. See individual module documentation for specific licensing information. Support For issues and questions: Check individual module documentation Review build requirements Verify system compatibility Test with minimal examples CLI and REPL Integration The main application now integrates a Command-Line Interface (CLI) with a REPL loop. This allows users to interactively execute commands for memory scanning and analysis. The main.cpp file initializes the REPL and registers commands such as help , quit , and pid .","title":"Main"},{"location":"en/main/#main-application-documentation","text":"","title":"Main Application Documentation"},{"location":"en/main/#overview","text":"The main.cpp file serves as the entry point for the NewScanmem application. It demonstrates basic module integration and provides a foundation for the memory scanning utility.","title":"Overview"},{"location":"en/main/#file-structure","text":"import sets; int main() { Set val; return 0; }","title":"File Structure"},{"location":"en/main/#current-implementation","text":"The current main function is minimal and serves as a placeholder for: Module Integration Testing : Demonstrates that the sets module can be successfully imported and used Basic Framework : Provides a starting point for application development Compilation Verification : Ensures all modules compile correctly together","title":"Current Implementation"},{"location":"en/main/#planned-features","text":"","title":"Planned Features"},{"location":"en/main/#command-line-interface","text":"// Future implementation int main(int argc, char* argv[]) { // Parse command line arguments // Initialize modules // Start memory scanning // Display results }","title":"Command Line Interface"},{"location":"en/main/#integration-points","text":"The main application will integrate all modules: Process Management (process_checker) Target process selection Process state monitoring Permission checking Memory Analysis (targetmem) Memory region scanning Value matching Pattern detection Data Types (value) Multi-type value support Endianness handling Byte array operations Utilities (sets, endianness, show_message) Set operations for results Byte order conversion User messaging and logging","title":"Integration Points"},{"location":"en/main/#usage-examples","text":"","title":"Usage Examples"},{"location":"en/main/#basic-execution","text":"# Current usage ./newscanmem # Future usage examples ./newscanmem --pid 1234 --type int32 --value 42 ./newscanmem --pid 1234 --range 0x1000-0x2000 --string \"hello\" ./newscanmem --pid 1234 --float --tolerance 0.001","title":"Basic Execution"},{"location":"en/main/#development-roadmap","text":"","title":"Development Roadmap"},{"location":"en/main/#phase-1-basic-framework","text":"[ ] Command line argument parsing [ ] Process selection and validation [ ] Basic memory scanning [ ] Result display","title":"Phase 1: Basic Framework"},{"location":"en/main/#phase-2-advanced-features","text":"[ ] Multiple value type support [ ] Memory region filtering [ ] Pattern matching [ ] Interactive mode","title":"Phase 2: Advanced Features"},{"location":"en/main/#phase-3-optimization","text":"[ ] Performance tuning [ ] Memory usage optimization [ ] Parallel processing [ ] Result caching","title":"Phase 3: Optimization"},{"location":"en/main/#phase-4-uiux","text":"[ ] Progress indicators [ ] Color output [ ] Export formats [ ] Configuration files","title":"Phase 4: UI/UX"},{"location":"en/main/#module-integration-example","text":"// Future main.cpp structure import process_checker; import targetmem; import value; import show_message; import sets; import endianness; int main(int argc, char* argv[]) { MessagePrinter printer; // Parse arguments if (argc < 2) { printer.error(\"Usage: {} --pid <pid> [...]\", argv[0]); return 1; } // Check process pid_t pid = std::stoi(argv[2]); if (ProcessChecker::is_process_dead(pid)) { printer.error(\"Process {} is not running\", pid); return 1; } // Initialize scanner printer.info(\"Scanning process {}...\", pid); // Perform scan MatchesAndOldValuesArray matches(get_memory_size(pid)); // ... scanning logic ... // Display results printer.info(\"Found {} matches\", get_total_matches(matches)); return 0; }","title":"Module Integration Example"},{"location":"en/main/#build-instructions","text":"","title":"Build Instructions"},{"location":"en/main/#current-build","text":"# Build the project mkdir build && cd build cmake .. make # Run the application ./newscanmem","title":"Current Build"},{"location":"en/main/#module-dependencies","text":"The main application depends on all modules: sets - Set operations and parsing process_checker - Process state checking targetmem - Memory analysis structures value - Value type definitions endianness - Byte order handling show_message - Message and logging system","title":"Module Dependencies"},{"location":"en/main/#testing-framework","text":"","title":"Testing Framework"},{"location":"en/main/#unit-tests","text":"// Test basic functionality void test_main_integration() { Set test_set; bool parse_result = parse_uintset(\"1,2,3\", test_set, 100); assert(parse_result == true); assert(test_set.size() == 3); std::cout << \"Main integration test passed!\\n\"; } int main() { test_main_integration(); return 0; }","title":"Unit Tests"},{"location":"en/main/#configuration","text":"","title":"Configuration"},{"location":"en/main/#environment-variables","text":"Future versions may support: SCANMEM_DEBUG : Enable debug mode SCANMEM_BACKEND : Enable backend mode SCANMEM_LOG_FILE : Log file path","title":"Environment Variables"},{"location":"en/main/#configuration-files","text":"# ~/.scanmemrc example [general] debug=true backend=false [scanning] default_type=int32 batch_size=1000 timeout=30","title":"Configuration Files"},{"location":"en/main/#error-handling","text":"","title":"Error Handling"},{"location":"en/main/#current-error-handling","text":"The current implementation provides minimal error handling through: Module import verification Basic compilation checks Placeholder return codes","title":"Current Error Handling"},{"location":"en/main/#future-error-handling","text":"enum class ScanError { SUCCESS = 0, INVALID_PID, PROCESS_NOT_FOUND, PERMISSION_DENIED, MEMORY_ACCESS_FAILED, INVALID_ARGUMENTS, OUT_OF_MEMORY }; ScanError perform_scan(const ScanConfig& config);","title":"Future Error Handling"},{"location":"en/main/#security-considerations","text":"","title":"Security Considerations"},{"location":"en/main/#current-security","text":"No elevated privileges required Read-only memory access Process permission validation","title":"Current Security"},{"location":"en/main/#future-security","text":"Capability checking Sandboxing considerations Secure memory access patterns Input validation","title":"Future Security"},{"location":"en/main/#performance-metrics","text":"","title":"Performance Metrics"},{"location":"en/main/#current-metrics","text":"Compilation time: ~2-3 seconds Binary size: ~50KB (minimal) Memory usage: ~1MB (minimal)","title":"Current Metrics"},{"location":"en/main/#target-metrics","text":"Scan speed: 1GB/sec for basic types Memory usage: <100MB for large processes Response time: <1 second for initial results","title":"Target Metrics"},{"location":"en/main/#platform-compatibility","text":"","title":"Platform Compatibility"},{"location":"en/main/#current-support","text":"Linux : Full support (primary platform) macOS : Planned support Windows : Not currently supported","title":"Current Support"},{"location":"en/main/#system-requirements","text":"OS : Linux with /proc filesystem Compiler : C++23 with modules support Memory : 64MB minimum, 1GB recommended Permissions : Read access to target process memory","title":"System Requirements"},{"location":"en/main/#debugging","text":"","title":"Debugging"},{"location":"en/main/#debug-build","text":"# Build with debug symbols cmake -DCMAKE_BUILD_TYPE=Debug .. make # Run with debugger gdb ./newscanmem (gdb) run --pid 1234","title":"Debug Build"},{"location":"en/main/#logging","text":"// Enable debug logging MessageContext ctx{.debugMode = true}; MessagePrinter printer(ctx); printer.debug(\"Starting scan for PID: {}\", pid);","title":"Logging"},{"location":"en/main/#future-api-design","text":"","title":"Future API Design"},{"location":"en/main/#future-api-command-line-interface","text":"# Basic scan ./newscanmem --pid 1234 --int32 42 # Advanced scan ./newscanmem --pid 1234 --range 0x1000-0xFFFF --float 3.14 --tolerance 0.001 # Interactive mode ./newscanmem --interactive # Batch mode ./newscanmem --pid 1234 --batch --output results.json","title":"Future API Command Line Interface"},{"location":"en/main/#programmatic-api","text":"// Future C++ API class ScanManager { public: ScanResult scan(const ScanConfig& config); void set_progress_callback(ProgressCallback callback); void cancel_scan(); };","title":"Programmatic API"},{"location":"en/main/#see-also","text":"Sets Module - Set operations and parsing Process Checker Module - Process state checking Target Memory Module - Memory analysis structures Value Module - Value type definitions Endianness Module - Byte order handling Show Message Module - Message and logging system","title":"See Also"},{"location":"en/main/#contributing","text":"","title":"Contributing"},{"location":"en/main/#development-setup","text":"# Clone repository git clone https://github.com/your-org/newscanmem.git cd newscanmem # Install dependencies sudo apt install build-essential cmake libboost-all-dev # Build and test mkdir build && cd build cmake .. make test","title":"Development Setup"},{"location":"en/main/#code-style","text":"Use modern C++23 features Follow RAII principles Prefer compile-time checks Use modules for encapsulation Document public APIs","title":"Code Style"},{"location":"en/main/#license-and-legal","text":"This project is part of the NewScanmem memory scanning utility. See individual module documentation for specific licensing information.","title":"License and Legal"},{"location":"en/main/#support","text":"For issues and questions: Check individual module documentation Review build requirements Verify system compatibility Test with minimal examples","title":"Support"},{"location":"en/main/#cli-and-repl-integration","text":"The main application now integrates a Command-Line Interface (CLI) with a REPL loop. This allows users to interactively execute commands for memory scanning and analysis. The main.cpp file initializes the REPL and registers commands such as help , quit , and pid .","title":"CLI and REPL Integration"},{"location":"en/maps/","text":"Maps Module Documentation Overview The Maps module provides functionality to read and parse Linux /proc/[pid]/maps files, extracting memory region information for process analysis. This is a modern C++20 implementation that replaces the legacy C code with type-safe, RAII-compliant interfaces. Module Structure import maps; Core Components 1. Region Types RegionType Enum Represents the classification of memory regions: enum class RegionType : uint8_t { MISC, // Miscellaneous memory regions EXE, // Executable binary regions CODE, // Code segments (shared libraries, etc.) HEAP, // Heap memory regions STACK // Stack memory regions }; constexpr std::array<std::string_view, 5> REGION_TYPE_NAMES = { \"misc\", \"exe\", \"code\", \"heap\", \"stack\" }; 2. Scan Levels RegionScanLevel Enum Controls which memory regions are included in scanning: enum class RegionScanLevel : uint8_t { ALL, // All readable regions ALL_RW, // All readable/writable regions HEAP_STACK_EXECUTABLE, // Heap, stack, and executable regions HEAP_STACK_EXECUTABLE_BSS // Above plus BSS segments }; 3. Region Metadata RegionFlags Structure Contains permission and state flags for memory regions: struct RegionFlags { bool read : 1; // Read permission bool write : 1; // Write permission bool exec : 1; // Execute permission bool shared : 1; // Shared mapping bool private_ : 1; // Private mapping }; Region Structure Complete information about a memory region: struct Region { void* start; // Starting address std::size_t size; // Region size in bytes RegionType type; // Region classification RegionFlags flags; // Permission flags void* loadAddr; // Load address for ELF files std::string filename; // Associated file path std::size_t id; // Unique identifier // Helper methods [[nodiscard]] bool isReadable() const noexcept; [[nodiscard]] bool isWritable() const noexcept; [[nodiscard]] bool isExecutable() const noexcept; [[nodiscard]] bool isShared() const noexcept; [[nodiscard]] bool isPrivate() const noexcept; [[nodiscard]] std::pair<void*, std::size_t> asSpan() const noexcept; [[nodiscard]] bool contains(void* address) const noexcept; }; Usage Examples Basic Usage import maps; // Read all memory regions from process auto result = maps::readProcessMaps(1234); if (result) { for (const auto& region : *result) { std::cout << std::format(\"Region: {}-{} ({})\\n\", region.start, static_cast<char*>(region.start) + region.size, REGION_TYPE_NAMES[static_cast<size_t>(region.type)]); } } Filtered Scanning // Only scan heap and stack regions auto regions = maps::readProcessMaps( pid, maps::RegionScanLevel::HEAP_STACK_EXECUTABLE ); if (regions) { for (const auto& region : *regions) { if (region.type == maps::RegionType::HEAP) { std::cout << \"Heap region found: \" << region.filename << \"\\n\"; } } } Error Handling auto result = maps::readProcessMaps(pid); if (!result) { std::cerr << \"Error: \" << result.error().message << \"\\n\"; return; } Class: MapsReader Static Methods readProcessMaps Reads memory regions from a process: [[nodiscard]] static std::expected<std::vector<Region>, Error> readProcessMaps(pid_t pid, RegionScanLevel level = RegionScanLevel::ALL); Parameters: pid : Target process ID level : Scan level filter (default: all ) Returns: std::expected containing vector of regions or error information Error Handling: Returns std::error_code with appropriate error messages Common errors: file not found, permission denied, invalid format Error Handling Module MapsReader::Error Structure struct Error { std::string message; // Human-readable error description std::error_code code; // System error code }; Common Error Scenarios Process doesn't exist : no_such_file_or_directory Permission denied : permission_denied Invalid format : invalid_argument Advanced Features Region Analysis // Check if address is within any region auto regions = maps::readProcessMaps(pid); void* address = /* some address */; for (const auto& region : *regions) { if (region.contains(address)) { std::cout << \"Address found in: \" << region.filename << \"\\n\"; break; } } Permission Checking // Find writable executable regions (potential shellcode targets) for (const auto& region : *regions) { if (region.is_writable() && region.is_executable()) { std::cout << \"WX region: \" << region.filename << \"\\n\"; } } Performance Notes Memory Efficient : Uses std::string with SSO for small filenames Zero-Copy : Direct string extraction from map lines Early Filtering : Regions filtered during parsing based on scan level RAII : Automatic resource cleanup via std::ifstream Thread Safety Thread-Safe : All methods are thread-safe for concurrent access No Shared State : Each call creates independent state Immutable Results : Returned vectors contain immutable data Platform Compatibility Linux Only : Requires /proc/[pid]/maps filesystem C++23 Required : Uses std::expected and other C++23 features 64-bit Support : Handles both 32-bit and 64-bit address spaces Migration from Legacy C Code Legacy C \u2192 Modern C++ Legacy C Modern C++ region_t* maps::Region list_t std::vector<Region> bool return std::expected char* filename std::string Manual memory management RAII Error codes Exception-safe error handling Integration with CLI The maps module is used in the CLI to retrieve and display memory region information for the target process. For example, the list command utilizes this module to parse and output /proc/[pid]/maps data. Examples Complete Working Example #include <iostream> import maps; int main() { pid_t target_pid = 1234; // Replace with actual PID auto regions = maps::readProcessMaps(target_pid); if (!regions) { std::cerr << \"Failed to read maps: \" << regions.error().message << \"\\n\"; return 1; } std::cout << \"Found \" << regions->size() << \" memory regions:\\n\"; for (const auto& region : *regions) { std::cout << std::format( \"0x{:x}-0x{:x} {} {} {}\\n\", reinterpret_cast<uintptr_t>(region.start), reinterpret_cast<uintptr_t>(region.start) + region.size, region.is_readable() ? 'r' : '-', region.is_writable() ? 'w' : '-', region.is_executable() ? 'x' : '-', region.filename.empty() ? \"[anonymous]\" : region.filename ); } return 0; }","title":"Maps"},{"location":"en/maps/#maps-module-documentation","text":"","title":"Maps Module Documentation"},{"location":"en/maps/#overview","text":"The Maps module provides functionality to read and parse Linux /proc/[pid]/maps files, extracting memory region information for process analysis. This is a modern C++20 implementation that replaces the legacy C code with type-safe, RAII-compliant interfaces.","title":"Overview"},{"location":"en/maps/#module-structure","text":"import maps;","title":"Module Structure"},{"location":"en/maps/#core-components","text":"","title":"Core Components"},{"location":"en/maps/#1-region-types","text":"","title":"1. Region Types"},{"location":"en/maps/#regiontype-enum","text":"Represents the classification of memory regions: enum class RegionType : uint8_t { MISC, // Miscellaneous memory regions EXE, // Executable binary regions CODE, // Code segments (shared libraries, etc.) HEAP, // Heap memory regions STACK // Stack memory regions }; constexpr std::array<std::string_view, 5> REGION_TYPE_NAMES = { \"misc\", \"exe\", \"code\", \"heap\", \"stack\" };","title":"RegionType Enum"},{"location":"en/maps/#2-scan-levels","text":"","title":"2. Scan Levels"},{"location":"en/maps/#regionscanlevel-enum","text":"Controls which memory regions are included in scanning: enum class RegionScanLevel : uint8_t { ALL, // All readable regions ALL_RW, // All readable/writable regions HEAP_STACK_EXECUTABLE, // Heap, stack, and executable regions HEAP_STACK_EXECUTABLE_BSS // Above plus BSS segments };","title":"RegionScanLevel Enum"},{"location":"en/maps/#3-region-metadata","text":"","title":"3. Region Metadata"},{"location":"en/maps/#regionflags-structure","text":"Contains permission and state flags for memory regions: struct RegionFlags { bool read : 1; // Read permission bool write : 1; // Write permission bool exec : 1; // Execute permission bool shared : 1; // Shared mapping bool private_ : 1; // Private mapping };","title":"RegionFlags Structure"},{"location":"en/maps/#region-structure","text":"Complete information about a memory region: struct Region { void* start; // Starting address std::size_t size; // Region size in bytes RegionType type; // Region classification RegionFlags flags; // Permission flags void* loadAddr; // Load address for ELF files std::string filename; // Associated file path std::size_t id; // Unique identifier // Helper methods [[nodiscard]] bool isReadable() const noexcept; [[nodiscard]] bool isWritable() const noexcept; [[nodiscard]] bool isExecutable() const noexcept; [[nodiscard]] bool isShared() const noexcept; [[nodiscard]] bool isPrivate() const noexcept; [[nodiscard]] std::pair<void*, std::size_t> asSpan() const noexcept; [[nodiscard]] bool contains(void* address) const noexcept; };","title":"Region Structure"},{"location":"en/maps/#usage-examples","text":"","title":"Usage Examples"},{"location":"en/maps/#basic-usage","text":"import maps; // Read all memory regions from process auto result = maps::readProcessMaps(1234); if (result) { for (const auto& region : *result) { std::cout << std::format(\"Region: {}-{} ({})\\n\", region.start, static_cast<char*>(region.start) + region.size, REGION_TYPE_NAMES[static_cast<size_t>(region.type)]); } }","title":"Basic Usage"},{"location":"en/maps/#filtered-scanning","text":"// Only scan heap and stack regions auto regions = maps::readProcessMaps( pid, maps::RegionScanLevel::HEAP_STACK_EXECUTABLE ); if (regions) { for (const auto& region : *regions) { if (region.type == maps::RegionType::HEAP) { std::cout << \"Heap region found: \" << region.filename << \"\\n\"; } } }","title":"Filtered Scanning"},{"location":"en/maps/#error-handling","text":"auto result = maps::readProcessMaps(pid); if (!result) { std::cerr << \"Error: \" << result.error().message << \"\\n\"; return; }","title":"Error Handling"},{"location":"en/maps/#class-mapsreader","text":"","title":"Class: MapsReader"},{"location":"en/maps/#static-methods","text":"","title":"Static Methods"},{"location":"en/maps/#readprocessmaps","text":"Reads memory regions from a process: [[nodiscard]] static std::expected<std::vector<Region>, Error> readProcessMaps(pid_t pid, RegionScanLevel level = RegionScanLevel::ALL); Parameters: pid : Target process ID level : Scan level filter (default: all ) Returns: std::expected containing vector of regions or error information Error Handling: Returns std::error_code with appropriate error messages Common errors: file not found, permission denied, invalid format","title":"readProcessMaps"},{"location":"en/maps/#error-handling-module","text":"","title":"Error Handling Module"},{"location":"en/maps/#mapsreadererror-structure","text":"struct Error { std::string message; // Human-readable error description std::error_code code; // System error code };","title":"MapsReader::Error Structure"},{"location":"en/maps/#common-error-scenarios","text":"Process doesn't exist : no_such_file_or_directory Permission denied : permission_denied Invalid format : invalid_argument","title":"Common Error Scenarios"},{"location":"en/maps/#advanced-features","text":"","title":"Advanced Features"},{"location":"en/maps/#region-analysis","text":"// Check if address is within any region auto regions = maps::readProcessMaps(pid); void* address = /* some address */; for (const auto& region : *regions) { if (region.contains(address)) { std::cout << \"Address found in: \" << region.filename << \"\\n\"; break; } }","title":"Region Analysis"},{"location":"en/maps/#permission-checking","text":"// Find writable executable regions (potential shellcode targets) for (const auto& region : *regions) { if (region.is_writable() && region.is_executable()) { std::cout << \"WX region: \" << region.filename << \"\\n\"; } }","title":"Permission Checking"},{"location":"en/maps/#performance-notes","text":"Memory Efficient : Uses std::string with SSO for small filenames Zero-Copy : Direct string extraction from map lines Early Filtering : Regions filtered during parsing based on scan level RAII : Automatic resource cleanup via std::ifstream","title":"Performance Notes"},{"location":"en/maps/#thread-safety","text":"Thread-Safe : All methods are thread-safe for concurrent access No Shared State : Each call creates independent state Immutable Results : Returned vectors contain immutable data","title":"Thread Safety"},{"location":"en/maps/#platform-compatibility","text":"Linux Only : Requires /proc/[pid]/maps filesystem C++23 Required : Uses std::expected and other C++23 features 64-bit Support : Handles both 32-bit and 64-bit address spaces","title":"Platform Compatibility"},{"location":"en/maps/#migration-from-legacy-c-code","text":"","title":"Migration from Legacy C Code"},{"location":"en/maps/#legacy-c-modern-c","text":"Legacy C Modern C++ region_t* maps::Region list_t std::vector<Region> bool return std::expected char* filename std::string Manual memory management RAII Error codes Exception-safe error handling","title":"Legacy C \u2192 Modern C++"},{"location":"en/maps/#integration-with-cli","text":"The maps module is used in the CLI to retrieve and display memory region information for the target process. For example, the list command utilizes this module to parse and output /proc/[pid]/maps data.","title":"Integration with CLI"},{"location":"en/maps/#examples","text":"","title":"Examples"},{"location":"en/maps/#complete-working-example","text":"#include <iostream> import maps; int main() { pid_t target_pid = 1234; // Replace with actual PID auto regions = maps::readProcessMaps(target_pid); if (!regions) { std::cerr << \"Failed to read maps: \" << regions.error().message << \"\\n\"; return 1; } std::cout << \"Found \" << regions->size() << \" memory regions:\\n\"; for (const auto& region : *regions) { std::cout << std::format( \"0x{:x}-0x{:x} {} {} {}\\n\", reinterpret_cast<uintptr_t>(region.start), reinterpret_cast<uintptr_t>(region.start) + region.size, region.is_readable() ? 'r' : '-', region.is_writable() ? 'w' : '-', region.is_executable() ? 'x' : '-', region.filename.empty() ? \"[anonymous]\" : region.filename ); } return 0; }","title":"Complete Working Example"},{"location":"en/process_checker/","text":"Process Checker Module Documentation Overview The process_checker module provides process state monitoring and checking functionality for the NewScanmem project. It allows checking if processes are running, dead, or in zombie states by examining the Linux /proc filesystem. Module Structure export module process_checker; Dependencies <unistd.h> - POSIX operating system API <filesystem> - C++17 filesystem operations <fstream> - File stream operations <string> - String operations Core Features 1. Process State Enumeration enum class ProcessState { RUNNING, // Process is running ERROR, // Error occurred during checking DEAD, // Process does not exist ZOMBIE // Process is in zombie state }; 2. ProcessChecker Class Public Interface class ProcessChecker { public: static ProcessState checkProcess(pid_t pid); static bool isProcessDead(pid_t pid); }; Methods checkProcess(pid_t pid) Checks the state of a process given its PID. Parameters: pid : Process ID to check Returns: ProcessState::RUNNING : Process is running (includes sleeping, waiting, stopped states) ProcessState::ERROR : Error occurred during checking (invalid PID, file access issues) ProcessState::DEAD : Process does not exist (/proc/[pid] directory missing) ProcessState::ZOMBIE : Process is in zombie or dead state isProcessDead(pid_t pid) Convenience method to check if a process is not running. Parameters: pid : Process ID to check Returns: true : Process is dead, zombie, or error occurred false : Process is running Implementation Details Process State Detection The module reads /proc/[pid]/status and examines the \"State:\" field: Running states : 'R' (Running), 'S' (Sleeping), 'D' (Waiting), 'T' (Stopped) Zombie states : 'Z' (Zombie), 'X' (Dead) Error handling : Invalid state characters, file access errors File System Operations Validation : Checks if PID is positive Existence : Verifies /proc/[pid] directory exists Access : Opens /proc/[pid]/status file Parsing : Reads state information from file content Usage Examples Basic Process Checking import process_checker; pid_t pid = 1234; ProcessState state = ProcessChecker::checkProcess(pid); switch (state) { case ProcessState::RUNNING: std::cout << \"Process is running\\n\"; break; case ProcessState::DEAD: std::cout << \"Process does not exist\\n\"; break; case ProcessState::ZOMBIE: std::cout << \"Process is zombie/dead\\n\"; break; case ProcessState::ERROR: std::cout << \"Error checking process\\n\"; break; } Quick Process Death Check if (ProcessChecker::isProcessDead(pid)) { std::cout << \"Process is no longer running\\n\"; } else { std::cout << \"Process is still running\\n\"; } Monitoring Loop #include <chrono> #include <thread> void monitorProcess(pid_t pid) { while (true) { if (ProcessChecker::isProcessDead(pid)) { std::cout << \"Process \" << pid << \" has terminated\\n\"; break; } std::this_thread::sleep_for(std::chrono::seconds(1)); } } Error Handling Error Conditions Invalid PID : PIDs less than or equal to 0 return ProcessState::ERROR File Access : Cannot open /proc/[pid]/status returns ProcessState::ERROR Parse Errors : Malformed state information returns ProcessState::ERROR Linux Specific Notes Requires Linux /proc filesystem Needs read permissions on /proc/[pid]/status May not work on systems with restricted /proc access Performance Considerations File I/O operations may have some overhead Consider caching results for frequent checks Thread-safe for concurrent access to different PIDs Security Considerations No elevated privileges required for basic checking May require appropriate permissions to read /proc/[pid]/status Does not perform any process memory access Platform Compatibility Linux : Full support (primary target platform) macOS : Not supported (different proc filesystem structure) Windows : Not supported (requires different implementation) See Also Target Memory Module - For memory analysis operations Main Application - For process targeting in the application Future Enhancements Support for additional process information Cross-platform compatibility Non-blocking process checking Process permission checking Integration with CLI The process_checker module is directly used in the CLI for commands like pid , which checks and displays the state of the target process. This ensures that users can verify process status interactively.","title":"Process Checker"},{"location":"en/process_checker/#process-checker-module-documentation","text":"","title":"Process Checker Module Documentation"},{"location":"en/process_checker/#overview","text":"The process_checker module provides process state monitoring and checking functionality for the NewScanmem project. It allows checking if processes are running, dead, or in zombie states by examining the Linux /proc filesystem.","title":"Overview"},{"location":"en/process_checker/#module-structure","text":"export module process_checker;","title":"Module Structure"},{"location":"en/process_checker/#dependencies","text":"<unistd.h> - POSIX operating system API <filesystem> - C++17 filesystem operations <fstream> - File stream operations <string> - String operations","title":"Dependencies"},{"location":"en/process_checker/#core-features","text":"","title":"Core Features"},{"location":"en/process_checker/#1-process-state-enumeration","text":"enum class ProcessState { RUNNING, // Process is running ERROR, // Error occurred during checking DEAD, // Process does not exist ZOMBIE // Process is in zombie state };","title":"1. Process State Enumeration"},{"location":"en/process_checker/#2-processchecker-class","text":"","title":"2. ProcessChecker Class"},{"location":"en/process_checker/#public-interface","text":"class ProcessChecker { public: static ProcessState checkProcess(pid_t pid); static bool isProcessDead(pid_t pid); };","title":"Public Interface"},{"location":"en/process_checker/#methods","text":"","title":"Methods"},{"location":"en/process_checker/#checkprocesspid_t-pid","text":"Checks the state of a process given its PID. Parameters: pid : Process ID to check Returns: ProcessState::RUNNING : Process is running (includes sleeping, waiting, stopped states) ProcessState::ERROR : Error occurred during checking (invalid PID, file access issues) ProcessState::DEAD : Process does not exist (/proc/[pid] directory missing) ProcessState::ZOMBIE : Process is in zombie or dead state","title":"checkProcess(pid_t pid)"},{"location":"en/process_checker/#isprocessdeadpid_t-pid","text":"Convenience method to check if a process is not running. Parameters: pid : Process ID to check Returns: true : Process is dead, zombie, or error occurred false : Process is running","title":"isProcessDead(pid_t pid)"},{"location":"en/process_checker/#implementation-details","text":"","title":"Implementation Details"},{"location":"en/process_checker/#process-state-detection","text":"The module reads /proc/[pid]/status and examines the \"State:\" field: Running states : 'R' (Running), 'S' (Sleeping), 'D' (Waiting), 'T' (Stopped) Zombie states : 'Z' (Zombie), 'X' (Dead) Error handling : Invalid state characters, file access errors","title":"Process State Detection"},{"location":"en/process_checker/#file-system-operations","text":"Validation : Checks if PID is positive Existence : Verifies /proc/[pid] directory exists Access : Opens /proc/[pid]/status file Parsing : Reads state information from file content","title":"File System Operations"},{"location":"en/process_checker/#usage-examples","text":"","title":"Usage Examples"},{"location":"en/process_checker/#basic-process-checking","text":"import process_checker; pid_t pid = 1234; ProcessState state = ProcessChecker::checkProcess(pid); switch (state) { case ProcessState::RUNNING: std::cout << \"Process is running\\n\"; break; case ProcessState::DEAD: std::cout << \"Process does not exist\\n\"; break; case ProcessState::ZOMBIE: std::cout << \"Process is zombie/dead\\n\"; break; case ProcessState::ERROR: std::cout << \"Error checking process\\n\"; break; }","title":"Basic Process Checking"},{"location":"en/process_checker/#quick-process-death-check","text":"if (ProcessChecker::isProcessDead(pid)) { std::cout << \"Process is no longer running\\n\"; } else { std::cout << \"Process is still running\\n\"; }","title":"Quick Process Death Check"},{"location":"en/process_checker/#monitoring-loop","text":"#include <chrono> #include <thread> void monitorProcess(pid_t pid) { while (true) { if (ProcessChecker::isProcessDead(pid)) { std::cout << \"Process \" << pid << \" has terminated\\n\"; break; } std::this_thread::sleep_for(std::chrono::seconds(1)); } }","title":"Monitoring Loop"},{"location":"en/process_checker/#error-handling","text":"","title":"Error Handling"},{"location":"en/process_checker/#error-conditions","text":"Invalid PID : PIDs less than or equal to 0 return ProcessState::ERROR File Access : Cannot open /proc/[pid]/status returns ProcessState::ERROR Parse Errors : Malformed state information returns ProcessState::ERROR","title":"Error Conditions"},{"location":"en/process_checker/#linux-specific-notes","text":"Requires Linux /proc filesystem Needs read permissions on /proc/[pid]/status May not work on systems with restricted /proc access","title":"Linux Specific Notes"},{"location":"en/process_checker/#performance-considerations","text":"File I/O operations may have some overhead Consider caching results for frequent checks Thread-safe for concurrent access to different PIDs","title":"Performance Considerations"},{"location":"en/process_checker/#security-considerations","text":"No elevated privileges required for basic checking May require appropriate permissions to read /proc/[pid]/status Does not perform any process memory access","title":"Security Considerations"},{"location":"en/process_checker/#platform-compatibility","text":"Linux : Full support (primary target platform) macOS : Not supported (different proc filesystem structure) Windows : Not supported (requires different implementation)","title":"Platform Compatibility"},{"location":"en/process_checker/#see-also","text":"Target Memory Module - For memory analysis operations Main Application - For process targeting in the application","title":"See Also"},{"location":"en/process_checker/#future-enhancements","text":"Support for additional process information Cross-platform compatibility Non-blocking process checking Process permission checking","title":"Future Enhancements"},{"location":"en/process_checker/#integration-with-cli","text":"The process_checker module is directly used in the CLI for commands like pid , which checks and displays the state of the target process. This ensures that users can verify process status interactively.","title":"Integration with CLI"},{"location":"en/sets/","text":"Sets Module Documentation Overview The sets module provides set operations and parsing utilities for the NewScanmem project. It includes a Set class for managing collections of integers and a powerful parser for set expressions with support for ranges, hex/decimal numbers, and inversion operations. Module Structure export module sets; Dependencies <algorithm> - Standard algorithms <boost/regex.hpp> - Regular expression support <boost/spirit/include/phoenix.hpp> - Boost Spirit Phoenix for semantic actions <boost/spirit/include/qi.hpp> - Boost Spirit Qi for parsing <cctype> - Character classification <compare> - Three-way comparison <cstdlib> - C standard library <stdexcept> - Standard exceptions <string> - String operations <vector> - Dynamic array container Core Features 1. Set Structure export struct Set { std::vector<size_t> buf; size_t size() const; void clear(); static int cmp(const size_t& i1, const size_t& i2); }; Methods size() : Returns the number of elements in the set clear() : Removes all elements from the set cmp() : Static comparison function for two size_t values using three-way comparison 2. Set Expression Parser export bool parse_uintset(std::string_view lptr, Set& set, size_t maxSZ); Supported Expression Formats Single numbers : 42 , 0x2A Ranges : 10..20 , 0x10..0xFF Multiple values : 1,2,3,4,5 Mixed format : 1,5,10..15,0x20 Inversion : !1,2,3 (all numbers except 1,2,3) Hexadecimal : 0x10 , 0xFF , 0xdeadbeef Parameters lptr : The set expression string to parse set : The Set object to populate with results maxSZ : Maximum allowed value (exclusive upper bound) Return Value true : Parsing successful false : Parsing failed (invalid syntax, out of bounds, etc.) 3. Deprecated Memory Management [[deprecated(\"This interface is deprecated...\")]] constexpr auto inc_arr_sz = [](size_t** valarr, size_t* arr_maxsz, size_t maxsz) -> bool; A deprecated C-style memory management utility for dynamic array resizing. Integration with CLI The sets module is utilized in the CLI for parsing and managing result sets during memory scanning. Commands like scan and reset rely on this module to handle set operations efficiently. Usage Examples Basic Set Parsing import sets; Set mySet; bool success = parse_uintset(\"1,2,3,4,5\", mySet, 100); if (success) { std::cout << \"Set contains \" << mySet.size() << \" elements\\n\"; } Range Parsing Set rangeSet; parse_uintset(\"10..20\", rangeSet, 100); // Results: {10, 11, 12, ..., 20} Hexadecimal Support Set hexSet; parse_uintset(\"0x10,0x20,0x30..0x35\", hexSet, 256); // Results: {16, 32, 48, 49, 50, 51, 52, 53} Set Inversion Set invertedSet; parse_uintset(\"!0,1,2\", invertedSet, 10); // Results: {3, 4, 5, 6, 7, 8, 9} Complex Expressions Set complexSet; parse_uintset(\"0,5,10..15,0x20,!12\", complexSet, 100); // Results: {0, 5, 10, 11, 13, 14, 15, 32} Empty Set Handling Set emptySet; bool result = parse_uintset(\"\", emptySet, 100); // Returns false Set invertedEmpty; parse_uintset(\"!\", invertedEmpty, 5); // Results: {0, 1, 2, 3, 4} Parser Grammar The parser uses Boost Spirit Qi and supports the following grammar: expression ::= [\"!\"] (range | single) { \",\" (range | single) } range ::= number \"..\" number single ::= number number ::= hex_number | decimal_number hex_number ::= \"0x\" hex_digits decimal_number ::= decimal_digits Error Handling Parse Errors The parser will return false for: Invalid syntax (e.g., \"1..\", \"abc\", \"1..2..3\") Out of bounds values (exceeding maxSZ) Empty expressions (except for inversion of empty set) Invalid ranges (start > end) Exception Safety The parser uses exception handling internally but converts all Boost Spirit exceptions to boolean return values for clean API usage. Performance Considerations Complexity : O(n log n) due to sorting and duplicate removal Memory : Uses std::vector for storage with automatic memory management Boost Spirit : Parser is efficient but has some compile-time overhead Implementation Details Sorting and Deduplication After parsing, the module automatically: Sorts the elements in ascending order Removes duplicate values Handles inversion logic efficiently Range Expansion Ranges are expanded into individual values: 10..15 becomes {10, 11, 12, 13, 14, 15} Each value is validated against maxSZ Inversion Logic Inversion creates the complement set: Original: {1, 3, 5} with maxSZ=10 Inverted: {0, 2, 4, 6, 7, 8, 9} Limitations maxSZ : All values must be less than maxSZ Memory : Large ranges can consume significant memory Performance : Very large ranges may impact performance Examples of Invalid Input Set set; parse_uintset(\"5..2\", set, 100); // false - invalid range parse_uintset(\"1,200\", set, 100); // false - out of bounds parse_uintset(\"abc\", set, 100); // false - invalid syntax parse_uintset(\"1..\", set, 100); // false - incomplete range Testing #include <iostream> #include <set> void test_parser() { Set set; // Test basic parsing parse_uintset(\"1,2,3\", set, 100); assert(set.size() == 3); // Test ranges parse_uintset(\"1..3\", set, 100); assert(set.size() == 3); // Test inversion parse_uintset(\"!1..3\", set, 10); assert(set.size() == 7); std::cout << \"All tests passed!\\n\"; } See Also Main Application - For integration examples Value Module - For value type definitions used with sets Future Enhancements Support for floating-point ranges Custom delimiters Performance optimizations for large ranges Memory-efficient sparse set representation","title":"Sets"},{"location":"en/sets/#sets-module-documentation","text":"","title":"Sets Module Documentation"},{"location":"en/sets/#overview","text":"The sets module provides set operations and parsing utilities for the NewScanmem project. It includes a Set class for managing collections of integers and a powerful parser for set expressions with support for ranges, hex/decimal numbers, and inversion operations.","title":"Overview"},{"location":"en/sets/#module-structure","text":"export module sets;","title":"Module Structure"},{"location":"en/sets/#dependencies","text":"<algorithm> - Standard algorithms <boost/regex.hpp> - Regular expression support <boost/spirit/include/phoenix.hpp> - Boost Spirit Phoenix for semantic actions <boost/spirit/include/qi.hpp> - Boost Spirit Qi for parsing <cctype> - Character classification <compare> - Three-way comparison <cstdlib> - C standard library <stdexcept> - Standard exceptions <string> - String operations <vector> - Dynamic array container","title":"Dependencies"},{"location":"en/sets/#core-features","text":"","title":"Core Features"},{"location":"en/sets/#1-set-structure","text":"export struct Set { std::vector<size_t> buf; size_t size() const; void clear(); static int cmp(const size_t& i1, const size_t& i2); };","title":"1. Set Structure"},{"location":"en/sets/#methods","text":"size() : Returns the number of elements in the set clear() : Removes all elements from the set cmp() : Static comparison function for two size_t values using three-way comparison","title":"Methods"},{"location":"en/sets/#2-set-expression-parser","text":"export bool parse_uintset(std::string_view lptr, Set& set, size_t maxSZ);","title":"2. Set Expression Parser"},{"location":"en/sets/#supported-expression-formats","text":"Single numbers : 42 , 0x2A Ranges : 10..20 , 0x10..0xFF Multiple values : 1,2,3,4,5 Mixed format : 1,5,10..15,0x20 Inversion : !1,2,3 (all numbers except 1,2,3) Hexadecimal : 0x10 , 0xFF , 0xdeadbeef","title":"Supported Expression Formats"},{"location":"en/sets/#parameters","text":"lptr : The set expression string to parse set : The Set object to populate with results maxSZ : Maximum allowed value (exclusive upper bound)","title":"Parameters"},{"location":"en/sets/#return-value","text":"true : Parsing successful false : Parsing failed (invalid syntax, out of bounds, etc.)","title":"Return Value"},{"location":"en/sets/#3-deprecated-memory-management","text":"[[deprecated(\"This interface is deprecated...\")]] constexpr auto inc_arr_sz = [](size_t** valarr, size_t* arr_maxsz, size_t maxsz) -> bool; A deprecated C-style memory management utility for dynamic array resizing.","title":"3. Deprecated Memory Management"},{"location":"en/sets/#integration-with-cli","text":"The sets module is utilized in the CLI for parsing and managing result sets during memory scanning. Commands like scan and reset rely on this module to handle set operations efficiently.","title":"Integration with CLI"},{"location":"en/sets/#usage-examples","text":"","title":"Usage Examples"},{"location":"en/sets/#basic-set-parsing","text":"import sets; Set mySet; bool success = parse_uintset(\"1,2,3,4,5\", mySet, 100); if (success) { std::cout << \"Set contains \" << mySet.size() << \" elements\\n\"; }","title":"Basic Set Parsing"},{"location":"en/sets/#range-parsing","text":"Set rangeSet; parse_uintset(\"10..20\", rangeSet, 100); // Results: {10, 11, 12, ..., 20}","title":"Range Parsing"},{"location":"en/sets/#hexadecimal-support","text":"Set hexSet; parse_uintset(\"0x10,0x20,0x30..0x35\", hexSet, 256); // Results: {16, 32, 48, 49, 50, 51, 52, 53}","title":"Hexadecimal Support"},{"location":"en/sets/#set-inversion","text":"Set invertedSet; parse_uintset(\"!0,1,2\", invertedSet, 10); // Results: {3, 4, 5, 6, 7, 8, 9}","title":"Set Inversion"},{"location":"en/sets/#complex-expressions","text":"Set complexSet; parse_uintset(\"0,5,10..15,0x20,!12\", complexSet, 100); // Results: {0, 5, 10, 11, 13, 14, 15, 32}","title":"Complex Expressions"},{"location":"en/sets/#empty-set-handling","text":"Set emptySet; bool result = parse_uintset(\"\", emptySet, 100); // Returns false Set invertedEmpty; parse_uintset(\"!\", invertedEmpty, 5); // Results: {0, 1, 2, 3, 4}","title":"Empty Set Handling"},{"location":"en/sets/#parser-grammar","text":"The parser uses Boost Spirit Qi and supports the following grammar: expression ::= [\"!\"] (range | single) { \",\" (range | single) } range ::= number \"..\" number single ::= number number ::= hex_number | decimal_number hex_number ::= \"0x\" hex_digits decimal_number ::= decimal_digits","title":"Parser Grammar"},{"location":"en/sets/#error-handling","text":"","title":"Error Handling"},{"location":"en/sets/#parse-errors","text":"The parser will return false for: Invalid syntax (e.g., \"1..\", \"abc\", \"1..2..3\") Out of bounds values (exceeding maxSZ) Empty expressions (except for inversion of empty set) Invalid ranges (start > end)","title":"Parse Errors"},{"location":"en/sets/#exception-safety","text":"The parser uses exception handling internally but converts all Boost Spirit exceptions to boolean return values for clean API usage.","title":"Exception Safety"},{"location":"en/sets/#performance-considerations","text":"Complexity : O(n log n) due to sorting and duplicate removal Memory : Uses std::vector for storage with automatic memory management Boost Spirit : Parser is efficient but has some compile-time overhead","title":"Performance Considerations"},{"location":"en/sets/#implementation-details","text":"","title":"Implementation Details"},{"location":"en/sets/#sorting-and-deduplication","text":"After parsing, the module automatically: Sorts the elements in ascending order Removes duplicate values Handles inversion logic efficiently","title":"Sorting and Deduplication"},{"location":"en/sets/#range-expansion","text":"Ranges are expanded into individual values: 10..15 becomes {10, 11, 12, 13, 14, 15} Each value is validated against maxSZ","title":"Range Expansion"},{"location":"en/sets/#inversion-logic","text":"Inversion creates the complement set: Original: {1, 3, 5} with maxSZ=10 Inverted: {0, 2, 4, 6, 7, 8, 9}","title":"Inversion Logic"},{"location":"en/sets/#limitations","text":"maxSZ : All values must be less than maxSZ Memory : Large ranges can consume significant memory Performance : Very large ranges may impact performance","title":"Limitations"},{"location":"en/sets/#examples-of-invalid-input","text":"Set set; parse_uintset(\"5..2\", set, 100); // false - invalid range parse_uintset(\"1,200\", set, 100); // false - out of bounds parse_uintset(\"abc\", set, 100); // false - invalid syntax parse_uintset(\"1..\", set, 100); // false - incomplete range","title":"Examples of Invalid Input"},{"location":"en/sets/#testing","text":"#include <iostream> #include <set> void test_parser() { Set set; // Test basic parsing parse_uintset(\"1,2,3\", set, 100); assert(set.size() == 3); // Test ranges parse_uintset(\"1..3\", set, 100); assert(set.size() == 3); // Test inversion parse_uintset(\"!1..3\", set, 10); assert(set.size() == 7); std::cout << \"All tests passed!\\n\"; }","title":"Testing"},{"location":"en/sets/#see-also","text":"Main Application - For integration examples Value Module - For value type definitions used with sets","title":"See Also"},{"location":"en/sets/#future-enhancements","text":"Support for floating-point ranges Custom delimiters Performance optimizations for large ranges Memory-efficient sparse set representation","title":"Future Enhancements"},{"location":"en/show_message/","text":"Show Message Module Documentation Overview The show_message module provides a comprehensive message printing and logging system for the NewScanmem project. It supports multiple message types, conditional output based on debug/backend modes, and formatted output using C++20 format strings. Module Structure export module show_message; Dependencies <boost/process.hpp> - Boost process library <cstdint> - Fixed-width integer types <format> - C++20 format library <iostream> - Standard I/O streams <string_view> - String view for efficient string handling Core Features 1. Message Type System enum class MessageType : uint8_t { INFO, // Informational messages WARN, // Warning messages ERROR, // Error messages DEBUG, // Debug messages (conditional) USER // User-facing messages (conditional) }; 2. Message Context struct MessageContext { bool debugMode = false; // Enable debug output bool backendMode = false; // Suppress user output }; 3. MessagePrinter Class Constructor MessagePrinter(MessageContext ctx = {}); Main Print Method template<typename... Args> void print(MessageType type, std::string_view fmt, Args&&... args) const; Convenience Methods template<typename... Args> void info(std::string_view fmt, Args&&... args) const; template<typename... Args> void warn(std::string_view fmt, Args&&... args) const; template<typename... Args> void error(std::string_view fmt, Args&&... args) const; template<typename... Args> void debug(std::string_view fmt, Args&&... args) const; template<typename... Args> void user(std::string_view fmt, Args&&... args) const; Usage Examples Basic Usage import show_message; MessagePrinter printer; printer.info(\"Starting memory scan\"); printer.warn(\"Low memory detected\"); printer.error(\"Failed to open process\"); With Format Strings printer.info(\"Scanning process with PID: {}\", pid); printer.warn(\"Found {} suspicious memory regions\", suspicious_count); printer.error(\"Memory read failed at address: 0x{:08x}\", address); Debug Mode Usage MessageContext ctx{.debugMode = true}; MessagePrinter debug_printer(ctx); debug_printer.debug(\"Current memory usage: {} bytes\", memory_usage); debug_printer.debug(\"Processing region: 0x{:08x}-0x{:08x}\", start, end); Backend Mode Usage MessageContext ctx{.backendMode = true}; MessagePrinter backend_printer(ctx); backend_printer.user(\"Scan complete\"); // Won't print in backend mode backend_printer.info(\"Scan complete\"); // Will print to stderr Combined Context MessageContext ctx{ .debugMode = true, .backendMode = false }; MessagePrinter printer(ctx); printer.debug(\"Debug info\"); // Prints to stderr printer.user(\"User message\"); // Prints to stdout Output Channels INFO, WARN, ERROR, DEBUG Output : std::cerr Format : [level]: message USER Output : std::cout (unless backend mode is enabled) Format : Raw message without prefix Message Formatting The module uses C++20 format strings with the following features: Supported Format Specifiers printer.info(\"Integer: {}\", 42); printer.info(\"Hex: 0x{:08x}\", 0x1234); printer.info(\"Float: {:.2f}\", 3.14159); printer.info(\"String: {}\", \"hello\"); printer.info(\"Multiple: {} and {}\", 1, \"two\"); Error Handling Format string errors are handled by the standard format library and will throw appropriate exceptions. Integration Examples With Other Modules import show_message; import process_checker; void check_and_report(pid_t pid) { MessagePrinter printer; auto state = ProcessChecker::check_process(pid); switch (state) { case ProcessState::RUNNING: printer.info(\"Process {} is running\", pid); break; case ProcessState::DEAD: printer.warn(\"Process {} is dead\", pid); break; case ProcessState::ERROR: printer.error(\"Error checking process {}\", pid); break; } } Configuration-based Usage struct Config { bool debug; bool backend; }; void initialize_logging(const Config& config) { MessageContext ctx{ .debugMode = config.debug, .backendMode = config.backend }; static MessagePrinter printer(ctx); // Use printer throughout application } Thread Safety The MessagePrinter class is thread-safe for concurrent use. Each instance maintains its own context and can be used from multiple threads simultaneously. Performance Considerations Format String Parsing : Done at compile time for literal strings Memory Allocation : Minimal heap allocation for formatted strings I/O Buffering : Uses standard stream buffering Customization Extending Message Types To add new message types, extend the MessageType enum and add appropriate handling in the print method: // Example extension enum class ExtendedMessageType { VERBOSE, // More detailed than DEBUG TRACE // Function tracing }; Custom Output Redirection While the module uses fixed output streams, you can create wrapper functions: class CustomMessagePrinter : public MessagePrinter { std::ofstream log_file; public: void custom_log(std::string_view msg) { log_file << std::format(\"{}\\n\", msg); info(\"Logged: {}\", msg); } }; Error Handling Module Exception Safety All methods provide strong exception safety guarantee. Format string errors are propagated to the caller. Common Issues Format String Mismatches : Ensure format specifiers match argument types Locale Issues : Consider locale settings for number formatting Buffer Overflow : Not possible with C++20 format library Testing void test_message_printer() { MessagePrinter printer; printer.info(\"Test info message\"); printer.warn(\"Test warning message\"); printer.error(\"Test error message\"); MessageContext ctx{.debugMode = true}; MessagePrinter debug_printer(ctx); debug_printer.debug(\"Test debug message\"); ctx.backendMode = true; MessagePrinter backend_printer(ctx); backend_printer.user(\"Test user message\"); // Won't print } See Also Target Memory Module - Uses message printing for memory operations Process Checker Module - Uses messages for process state reporting Main Application - Integration in main application flow Future Enhancements Log file support Colored output support Custom log levels Timestamp support Log rotation capabilities JSON format output option Syslog integration Windows Event Log support (cross-platform) Platform Notes Linux/macOS : Full support for all features Windows : Full support for all features UTF-8 : Supports Unicode messages on all platforms Terminal Colors : Future enhancement for colorized output Best Practices Use appropriate message types for different severity levels Enable debug mode only when needed to reduce noise Use backend mode for automated/scripted operations Format strings : Use appropriate format specifiers for readability Error handling : Always handle format string errors appropriately Performance : Avoid complex formatting in tight loops Migration from printf-style logging // Old style printf(\"Error: %s at line %d\\n\", message, line); // New style printer.error(\"{} at line {}\", message, line); Integration with Build Systems The module can be configured through build flags: #ifdef NDEBUG MessageContext ctx{.debugMode = false}; #else MessageContext ctx{.debugMode = true}; #endif Common Patterns Scoped Debugging class ScopedDebug { MessagePrinter& printer; std::string name; public: ScopedDebug(MessagePrinter& p, std::string_view n) : printer(p), name(n) { printer.debug(\"Entering {}\", name); } ~ScopedDebug() { printer.debug(\"Exiting {}\", name); } }; // Usage { ScopedDebug debug(printer, \"memory_scan\"); // ... scan memory ... } // Automatically logs exit","title":"Show Message"},{"location":"en/show_message/#show-message-module-documentation","text":"","title":"Show Message Module Documentation"},{"location":"en/show_message/#overview","text":"The show_message module provides a comprehensive message printing and logging system for the NewScanmem project. It supports multiple message types, conditional output based on debug/backend modes, and formatted output using C++20 format strings.","title":"Overview"},{"location":"en/show_message/#module-structure","text":"export module show_message;","title":"Module Structure"},{"location":"en/show_message/#dependencies","text":"<boost/process.hpp> - Boost process library <cstdint> - Fixed-width integer types <format> - C++20 format library <iostream> - Standard I/O streams <string_view> - String view for efficient string handling","title":"Dependencies"},{"location":"en/show_message/#core-features","text":"","title":"Core Features"},{"location":"en/show_message/#1-message-type-system","text":"enum class MessageType : uint8_t { INFO, // Informational messages WARN, // Warning messages ERROR, // Error messages DEBUG, // Debug messages (conditional) USER // User-facing messages (conditional) };","title":"1. Message Type System"},{"location":"en/show_message/#2-message-context","text":"struct MessageContext { bool debugMode = false; // Enable debug output bool backendMode = false; // Suppress user output };","title":"2. Message Context"},{"location":"en/show_message/#3-messageprinter-class","text":"","title":"3. MessagePrinter Class"},{"location":"en/show_message/#constructor","text":"MessagePrinter(MessageContext ctx = {});","title":"Constructor"},{"location":"en/show_message/#main-print-method","text":"template<typename... Args> void print(MessageType type, std::string_view fmt, Args&&... args) const;","title":"Main Print Method"},{"location":"en/show_message/#convenience-methods","text":"template<typename... Args> void info(std::string_view fmt, Args&&... args) const; template<typename... Args> void warn(std::string_view fmt, Args&&... args) const; template<typename... Args> void error(std::string_view fmt, Args&&... args) const; template<typename... Args> void debug(std::string_view fmt, Args&&... args) const; template<typename... Args> void user(std::string_view fmt, Args&&... args) const;","title":"Convenience Methods"},{"location":"en/show_message/#usage-examples","text":"","title":"Usage Examples"},{"location":"en/show_message/#basic-usage","text":"import show_message; MessagePrinter printer; printer.info(\"Starting memory scan\"); printer.warn(\"Low memory detected\"); printer.error(\"Failed to open process\");","title":"Basic Usage"},{"location":"en/show_message/#with-format-strings","text":"printer.info(\"Scanning process with PID: {}\", pid); printer.warn(\"Found {} suspicious memory regions\", suspicious_count); printer.error(\"Memory read failed at address: 0x{:08x}\", address);","title":"With Format Strings"},{"location":"en/show_message/#debug-mode-usage","text":"MessageContext ctx{.debugMode = true}; MessagePrinter debug_printer(ctx); debug_printer.debug(\"Current memory usage: {} bytes\", memory_usage); debug_printer.debug(\"Processing region: 0x{:08x}-0x{:08x}\", start, end);","title":"Debug Mode Usage"},{"location":"en/show_message/#backend-mode-usage","text":"MessageContext ctx{.backendMode = true}; MessagePrinter backend_printer(ctx); backend_printer.user(\"Scan complete\"); // Won't print in backend mode backend_printer.info(\"Scan complete\"); // Will print to stderr","title":"Backend Mode Usage"},{"location":"en/show_message/#combined-context","text":"MessageContext ctx{ .debugMode = true, .backendMode = false }; MessagePrinter printer(ctx); printer.debug(\"Debug info\"); // Prints to stderr printer.user(\"User message\"); // Prints to stdout","title":"Combined Context"},{"location":"en/show_message/#output-channels","text":"","title":"Output Channels"},{"location":"en/show_message/#info-warn-error-debug","text":"Output : std::cerr Format : [level]: message","title":"INFO, WARN, ERROR, DEBUG"},{"location":"en/show_message/#user","text":"Output : std::cout (unless backend mode is enabled) Format : Raw message without prefix","title":"USER"},{"location":"en/show_message/#message-formatting","text":"The module uses C++20 format strings with the following features:","title":"Message Formatting"},{"location":"en/show_message/#supported-format-specifiers","text":"printer.info(\"Integer: {}\", 42); printer.info(\"Hex: 0x{:08x}\", 0x1234); printer.info(\"Float: {:.2f}\", 3.14159); printer.info(\"String: {}\", \"hello\"); printer.info(\"Multiple: {} and {}\", 1, \"two\");","title":"Supported Format Specifiers"},{"location":"en/show_message/#error-handling","text":"Format string errors are handled by the standard format library and will throw appropriate exceptions.","title":"Error Handling"},{"location":"en/show_message/#integration-examples","text":"","title":"Integration Examples"},{"location":"en/show_message/#with-other-modules","text":"import show_message; import process_checker; void check_and_report(pid_t pid) { MessagePrinter printer; auto state = ProcessChecker::check_process(pid); switch (state) { case ProcessState::RUNNING: printer.info(\"Process {} is running\", pid); break; case ProcessState::DEAD: printer.warn(\"Process {} is dead\", pid); break; case ProcessState::ERROR: printer.error(\"Error checking process {}\", pid); break; } }","title":"With Other Modules"},{"location":"en/show_message/#configuration-based-usage","text":"struct Config { bool debug; bool backend; }; void initialize_logging(const Config& config) { MessageContext ctx{ .debugMode = config.debug, .backendMode = config.backend }; static MessagePrinter printer(ctx); // Use printer throughout application }","title":"Configuration-based Usage"},{"location":"en/show_message/#thread-safety","text":"The MessagePrinter class is thread-safe for concurrent use. Each instance maintains its own context and can be used from multiple threads simultaneously.","title":"Thread Safety"},{"location":"en/show_message/#performance-considerations","text":"Format String Parsing : Done at compile time for literal strings Memory Allocation : Minimal heap allocation for formatted strings I/O Buffering : Uses standard stream buffering","title":"Performance Considerations"},{"location":"en/show_message/#customization","text":"","title":"Customization"},{"location":"en/show_message/#extending-message-types","text":"To add new message types, extend the MessageType enum and add appropriate handling in the print method: // Example extension enum class ExtendedMessageType { VERBOSE, // More detailed than DEBUG TRACE // Function tracing };","title":"Extending Message Types"},{"location":"en/show_message/#custom-output-redirection","text":"While the module uses fixed output streams, you can create wrapper functions: class CustomMessagePrinter : public MessagePrinter { std::ofstream log_file; public: void custom_log(std::string_view msg) { log_file << std::format(\"{}\\n\", msg); info(\"Logged: {}\", msg); } };","title":"Custom Output Redirection"},{"location":"en/show_message/#error-handling-module","text":"","title":"Error Handling Module"},{"location":"en/show_message/#exception-safety","text":"All methods provide strong exception safety guarantee. Format string errors are propagated to the caller.","title":"Exception Safety"},{"location":"en/show_message/#common-issues","text":"Format String Mismatches : Ensure format specifiers match argument types Locale Issues : Consider locale settings for number formatting Buffer Overflow : Not possible with C++20 format library","title":"Common Issues"},{"location":"en/show_message/#testing","text":"void test_message_printer() { MessagePrinter printer; printer.info(\"Test info message\"); printer.warn(\"Test warning message\"); printer.error(\"Test error message\"); MessageContext ctx{.debugMode = true}; MessagePrinter debug_printer(ctx); debug_printer.debug(\"Test debug message\"); ctx.backendMode = true; MessagePrinter backend_printer(ctx); backend_printer.user(\"Test user message\"); // Won't print }","title":"Testing"},{"location":"en/show_message/#see-also","text":"Target Memory Module - Uses message printing for memory operations Process Checker Module - Uses messages for process state reporting Main Application - Integration in main application flow","title":"See Also"},{"location":"en/show_message/#future-enhancements","text":"Log file support Colored output support Custom log levels Timestamp support Log rotation capabilities JSON format output option Syslog integration Windows Event Log support (cross-platform)","title":"Future Enhancements"},{"location":"en/show_message/#platform-notes","text":"Linux/macOS : Full support for all features Windows : Full support for all features UTF-8 : Supports Unicode messages on all platforms Terminal Colors : Future enhancement for colorized output","title":"Platform Notes"},{"location":"en/show_message/#best-practices","text":"Use appropriate message types for different severity levels Enable debug mode only when needed to reduce noise Use backend mode for automated/scripted operations Format strings : Use appropriate format specifiers for readability Error handling : Always handle format string errors appropriately Performance : Avoid complex formatting in tight loops","title":"Best Practices"},{"location":"en/show_message/#migration-from-printf-style-logging","text":"// Old style printf(\"Error: %s at line %d\\n\", message, line); // New style printer.error(\"{} at line {}\", message, line);","title":"Migration from printf-style logging"},{"location":"en/show_message/#integration-with-build-systems","text":"The module can be configured through build flags: #ifdef NDEBUG MessageContext ctx{.debugMode = false}; #else MessageContext ctx{.debugMode = true}; #endif","title":"Integration with Build Systems"},{"location":"en/show_message/#common-patterns","text":"","title":"Common Patterns"},{"location":"en/show_message/#scoped-debugging","text":"class ScopedDebug { MessagePrinter& printer; std::string name; public: ScopedDebug(MessagePrinter& p, std::string_view n) : printer(p), name(n) { printer.debug(\"Entering {}\", name); } ~ScopedDebug() { printer.debug(\"Exiting {}\", name); } }; // Usage { ScopedDebug debug(printer, \"memory_scan\"); // ... scan memory ... } // Automatically logs exit","title":"Scoped Debugging"},{"location":"en/target_mem/","text":"Target Memory Module Documentation Overview The targetmem module provides memory matching and analysis structures for the NewScanmem project. It includes classes for managing memory matches, storing old values, and performing memory region operations with support for efficient searching and manipulation. Module Structure export module targetmem; Dependencies <algorithm> - Standard algorithms <cassert> - Assert macros <cctype> - Character classification <cstddef> - Size type definitions <cstdint> - Fixed-width integer types <cstdio> - C standard I/O <cstdlib> - C standard library <cstring> - C string operations <optional> - Optional type support <sstream> - String stream operations <string> - String operations <vector> - Dynamic array container value module - Value type definitions show_message module - Message printing system Core Features 1. Memory Match Flags Uses MatchFlags from the value module to indicate the type and status of memory matches. 2. OldValueAndMatchInfo Structure struct OldValueAndMatchInfo { uint8_t old_value; // The original byte value MatchFlags match_info; // Match type and status flags }; 3. MatchesAndOldValuesSwath Class Represents a contiguous memory region with match information. class MatchesAndOldValuesSwath { public: void* firstByteInChild = nullptr; // Starting address std::vector<OldValueAndMatchInfo> data; // Match data // Constructors MatchesAndOldValuesSwath() = default; // Element management void addElement(void* addr, uint8_t byte, MatchFlags matchFlags); // String representation utilities std::string toPrintableString(size_t idx, size_t len) const; std::string toByteArrayText(size_t idx, size_t len) const; }; Methods addElement(void* addr, uint8_t byte, MatchFlags matchFlags) Adds a new memory match to the swath. Parameters: addr : Memory address of the match byte : The byte value at this address matchFlags : Type of match and flags toPrintableString(size_t idx, size_t len) Converts memory bytes to a printable ASCII string. Parameters: idx : Starting index in the data vector len : Number of bytes to convert Returns: Printable string with non-printable characters as '.' toByteArrayText(size_t idx, size_t len) Converts memory bytes to hexadecimal text representation. Parameters: idx : Starting index in the data vector len : Number of bytes to convert Returns: Space-separated hexadecimal values 4. MatchesAndOldValuesArray Class Manages multiple swaths and provides search operations. class MatchesAndOldValuesArray { public: size_t maxNeededBytes; // Maximum memory needed std::vector<MatchesAndOldValuesSwath> swaths; // Collection of swaths // Constructor MatchesAndOldValuesArray(size_t maxBytes); // Swath management void addSwath(const MatchesAndOldValuesSwath& swath); // Search operations std::optional<std::pair<MatchesAndOldValuesSwath*, size_t>> nthMatch(size_t n); // Memory range operations void deleteInAddressRange(void* start, void* end, unsigned long& numMatches); }; MatchesAndOldValuesArray Methods Constructor(size_t maxBytes) Initializes with maximum memory requirement. Parameters: maxBytes : Maximum bytes needed for all matches addSwath(const MatchesAndOldValuesSwath& swath) Adds a new swath to the collection. nthMatch(size_t n) Finds the nth valid match across all swaths. Parameters: n : Match index to find (0-based) Returns: Optional pair of (swath pointer, index within swath) or nullopt if not found deleteInAddressRange(void start, void end, unsigned long& numMatches) Removes all matches within a specified address range. Parameters: start : Starting address of range (inclusive) end : Ending address of range (exclusive) numMatches : Output parameter counting removed matches Usage Examples Creating and Populating Swaths import targetmem; MatchesAndOldValuesSwath swath; // Add memory matches void* base_addr = reinterpret_cast<void*>(0x1000); swath.addElement(base_addr, 0x41, MatchFlags::U8B); // 'A' character swath.addElement(static_cast<char*>(base_addr) + 1, 0x42, MatchFlags::U8B); // 'B' character swath.addElement(static_cast<char*>(base_addr) + 2, 0x00, MatchFlags::EMPTY); // No match String Representations // Get printable representation std::string printable = swath.toPrintableString(0, 3); // Result: \"AB.\" // Get hex representation std::string hex = swath.toByteArrayText(0, 3); // Result: \"41 42 0\" Managing Multiple Swaths MatchesAndOldValuesArray array(1024); // Max 1KB of matches // Add swaths array.addSwath(swath1); array.addSwath(swath2); // Find specific matches auto match = array.nthMatch(5); if (match) { auto [swath_ptr, index] = *match; // Process the 6th match (0-based index 5) } Address Range Operations // Remove matches in a specific address range unsigned long removed_count = 0; void* start_range = reinterpret_cast<void*>(0x1000); void* end_range = reinterpret_cast<void*>(0x2000); array.deleteInAddressRange(start_range, end_range, removed_count); std::cout << \"Removed \" << removed_count << \" matches\\n\"; Memory Layout and Addressing Address Calculation The module uses pointer arithmetic to calculate actual memory addresses: // Calculate actual address from swath data void* actual_address = static_cast<char*>(swath.firstByteInChild) + index; Swath Organization Each swath represents a contiguous memory region with: Fixed starting address ( firstByteInChild ) Sequential byte values ( data vector) Match flags for each byte Performance Considerations Memory Usage Swath overhead : Each swath has minimal overhead Data storage : Stores one byte + flags per address Vector growth : Uses std::vector with amortized growth Search Performance nthMatch : O(n) traversal across all swaths Range deletion : O(n) with efficient std::remove_if Memory locality : Good cache performance due to vector storage Error Handling Bounds Checking All methods include bounds checking: toPrintableString and toByteArrayText use std::min to prevent overflow nthMatch returns std::nullopt for invalid indices Null Pointer Safety firstByteInChild is initialized to nullptr Methods verify vector sizes before access Advanced Usage Complex Memory Analysis void analyze_memory_region(void* start, size_t size) { MatchesAndOldValuesArray matches(size); MatchesAndOldValuesSwath swath; swath.firstByteInChild = start; // Analyze each byte for (size_t i = 0; i < size; ++i) { void* addr = static_cast<char*>(start) + i; uint8_t value = read_memory_byte(addr); // Implementation specific MatchFlags flags = analyze_value(value); // Determine match type swath.addElement(addr, value, flags); } matches.addSwath(swath); // Process results auto first_match = matches.nthMatch(0); if (first_match) { // Found at least one match } } Memory Pattern Matching void find_string_patterns(const MatchesAndOldValuesArray& matches) { for (const auto& swath : matches.swaths) { for (size_t i = 0; i < swath.data.size(); ++i) { if (swath.data[i].match_info != MatchFlags::EMPTY) { // Check for ASCII string patterns std::string chars = swath.toPrintableString(i, 16); if (is_printable_string(chars)) { void* addr = static_cast<char*>(swath.firstByteInChild) + i; std::cout << \"String at \" << addr << \": \" << chars << \"\\n\"; } } } } } Integration with Other Modules With Show Message Module import targetmem; import show_message; void report_matches(const MatchesAndOldValuesArray& matches) { MessagePrinter printer; size_t total_matches = 0; for (const auto& swath : matches.swaths) { for (const auto& [value, flags] : swath.data) { if (flags != MatchFlags::EMPTY) { total_matches++; } } } printer.info(\"Found {} total matches\", total_matches); } With Process Checker void scan_process_memory(pid_t pid) { if (ProcessChecker::is_process_dead(pid)) { return; } // Create memory scanner MatchesAndOldValuesArray matches(get_process_memory_size(pid)); // Perform scan... } Testing void test_target_memory() { // Test swath creation MatchesAndOldValuesSwath swath; swath.addElement(nullptr, 0x41, MatchFlags::U8B); assert(swath.data.size() == 1); assert(swath.data[0].old_value == 0x41); assert(swath.data[0].match_info == MatchFlags::U8B); // Test string representations std::string printable = swath.toPrintableString(0, 1); assert(printable == \"A\"); std::string hex = swath.toByteArrayText(0, 1); assert(hex == \"41\"); // Test array operations MatchesAndOldValuesArray array(1024); array.addSwath(swath); auto match = array.nthMatch(0); assert(match.has_value()); std::cout << \"All tests passed!\\n\"; } See Also Value Module - For MatchFlags definitions Process Checker Module - For process state checking Show Message Module - For logging and reporting Future Enhancements Support for larger memory regions Compression for sparse match data Parallel processing support Memory scanning optimizations Integration with memory mapping APIs Support for different memory types (heap, stack, code) Pattern matching algorithms Memory write operations Snapshot and comparison features Thread Safety The classes are not thread-safe by default. For concurrent access: Use external synchronization Consider immutable copies for read-only access Use separate instances for different threads Memory Management Automatic memory management via std::vector RAII principles for exception safety Efficient move semantics for large datasets Minimal heap allocations during operations","title":"Target Memory"},{"location":"en/target_mem/#target-memory-module-documentation","text":"","title":"Target Memory Module Documentation"},{"location":"en/target_mem/#overview","text":"The targetmem module provides memory matching and analysis structures for the NewScanmem project. It includes classes for managing memory matches, storing old values, and performing memory region operations with support for efficient searching and manipulation.","title":"Overview"},{"location":"en/target_mem/#module-structure","text":"export module targetmem;","title":"Module Structure"},{"location":"en/target_mem/#dependencies","text":"<algorithm> - Standard algorithms <cassert> - Assert macros <cctype> - Character classification <cstddef> - Size type definitions <cstdint> - Fixed-width integer types <cstdio> - C standard I/O <cstdlib> - C standard library <cstring> - C string operations <optional> - Optional type support <sstream> - String stream operations <string> - String operations <vector> - Dynamic array container value module - Value type definitions show_message module - Message printing system","title":"Dependencies"},{"location":"en/target_mem/#core-features","text":"","title":"Core Features"},{"location":"en/target_mem/#1-memory-match-flags","text":"Uses MatchFlags from the value module to indicate the type and status of memory matches.","title":"1. Memory Match Flags"},{"location":"en/target_mem/#2-oldvalueandmatchinfo-structure","text":"struct OldValueAndMatchInfo { uint8_t old_value; // The original byte value MatchFlags match_info; // Match type and status flags };","title":"2. OldValueAndMatchInfo Structure"},{"location":"en/target_mem/#3-matchesandoldvaluesswath-class","text":"Represents a contiguous memory region with match information. class MatchesAndOldValuesSwath { public: void* firstByteInChild = nullptr; // Starting address std::vector<OldValueAndMatchInfo> data; // Match data // Constructors MatchesAndOldValuesSwath() = default; // Element management void addElement(void* addr, uint8_t byte, MatchFlags matchFlags); // String representation utilities std::string toPrintableString(size_t idx, size_t len) const; std::string toByteArrayText(size_t idx, size_t len) const; };","title":"3. MatchesAndOldValuesSwath Class"},{"location":"en/target_mem/#methods","text":"","title":"Methods"},{"location":"en/target_mem/#addelementvoid-addr-uint8_t-byte-matchflags-matchflags","text":"Adds a new memory match to the swath. Parameters: addr : Memory address of the match byte : The byte value at this address matchFlags : Type of match and flags","title":"addElement(void* addr, uint8_t byte, MatchFlags matchFlags)"},{"location":"en/target_mem/#toprintablestringsize_t-idx-size_t-len","text":"Converts memory bytes to a printable ASCII string. Parameters: idx : Starting index in the data vector len : Number of bytes to convert Returns: Printable string with non-printable characters as '.'","title":"toPrintableString(size_t idx, size_t len)"},{"location":"en/target_mem/#tobytearraytextsize_t-idx-size_t-len","text":"Converts memory bytes to hexadecimal text representation. Parameters: idx : Starting index in the data vector len : Number of bytes to convert Returns: Space-separated hexadecimal values","title":"toByteArrayText(size_t idx, size_t len)"},{"location":"en/target_mem/#4-matchesandoldvaluesarray-class","text":"Manages multiple swaths and provides search operations. class MatchesAndOldValuesArray { public: size_t maxNeededBytes; // Maximum memory needed std::vector<MatchesAndOldValuesSwath> swaths; // Collection of swaths // Constructor MatchesAndOldValuesArray(size_t maxBytes); // Swath management void addSwath(const MatchesAndOldValuesSwath& swath); // Search operations std::optional<std::pair<MatchesAndOldValuesSwath*, size_t>> nthMatch(size_t n); // Memory range operations void deleteInAddressRange(void* start, void* end, unsigned long& numMatches); };","title":"4. MatchesAndOldValuesArray Class"},{"location":"en/target_mem/#matchesandoldvaluesarray-methods","text":"","title":"MatchesAndOldValuesArray Methods"},{"location":"en/target_mem/#constructorsize_t-maxbytes","text":"Initializes with maximum memory requirement. Parameters: maxBytes : Maximum bytes needed for all matches","title":"Constructor(size_t maxBytes)"},{"location":"en/target_mem/#addswathconst-matchesandoldvaluesswath-swath","text":"Adds a new swath to the collection.","title":"addSwath(const MatchesAndOldValuesSwath&amp; swath)"},{"location":"en/target_mem/#nthmatchsize_t-n","text":"Finds the nth valid match across all swaths. Parameters: n : Match index to find (0-based) Returns: Optional pair of (swath pointer, index within swath) or nullopt if not found","title":"nthMatch(size_t n)"},{"location":"en/target_mem/#deleteinaddressrangevoidstart-void-end-unsigned-long-nummatches","text":"Removes all matches within a specified address range. Parameters: start : Starting address of range (inclusive) end : Ending address of range (exclusive) numMatches : Output parameter counting removed matches","title":"deleteInAddressRange(voidstart, void end, unsigned long&amp; numMatches)"},{"location":"en/target_mem/#usage-examples","text":"","title":"Usage Examples"},{"location":"en/target_mem/#creating-and-populating-swaths","text":"import targetmem; MatchesAndOldValuesSwath swath; // Add memory matches void* base_addr = reinterpret_cast<void*>(0x1000); swath.addElement(base_addr, 0x41, MatchFlags::U8B); // 'A' character swath.addElement(static_cast<char*>(base_addr) + 1, 0x42, MatchFlags::U8B); // 'B' character swath.addElement(static_cast<char*>(base_addr) + 2, 0x00, MatchFlags::EMPTY); // No match","title":"Creating and Populating Swaths"},{"location":"en/target_mem/#string-representations","text":"// Get printable representation std::string printable = swath.toPrintableString(0, 3); // Result: \"AB.\" // Get hex representation std::string hex = swath.toByteArrayText(0, 3); // Result: \"41 42 0\"","title":"String Representations"},{"location":"en/target_mem/#managing-multiple-swaths","text":"MatchesAndOldValuesArray array(1024); // Max 1KB of matches // Add swaths array.addSwath(swath1); array.addSwath(swath2); // Find specific matches auto match = array.nthMatch(5); if (match) { auto [swath_ptr, index] = *match; // Process the 6th match (0-based index 5) }","title":"Managing Multiple Swaths"},{"location":"en/target_mem/#address-range-operations","text":"// Remove matches in a specific address range unsigned long removed_count = 0; void* start_range = reinterpret_cast<void*>(0x1000); void* end_range = reinterpret_cast<void*>(0x2000); array.deleteInAddressRange(start_range, end_range, removed_count); std::cout << \"Removed \" << removed_count << \" matches\\n\";","title":"Address Range Operations"},{"location":"en/target_mem/#memory-layout-and-addressing","text":"","title":"Memory Layout and Addressing"},{"location":"en/target_mem/#address-calculation","text":"The module uses pointer arithmetic to calculate actual memory addresses: // Calculate actual address from swath data void* actual_address = static_cast<char*>(swath.firstByteInChild) + index;","title":"Address Calculation"},{"location":"en/target_mem/#swath-organization","text":"Each swath represents a contiguous memory region with: Fixed starting address ( firstByteInChild ) Sequential byte values ( data vector) Match flags for each byte","title":"Swath Organization"},{"location":"en/target_mem/#performance-considerations","text":"","title":"Performance Considerations"},{"location":"en/target_mem/#memory-usage","text":"Swath overhead : Each swath has minimal overhead Data storage : Stores one byte + flags per address Vector growth : Uses std::vector with amortized growth","title":"Memory Usage"},{"location":"en/target_mem/#search-performance","text":"nthMatch : O(n) traversal across all swaths Range deletion : O(n) with efficient std::remove_if Memory locality : Good cache performance due to vector storage","title":"Search Performance"},{"location":"en/target_mem/#error-handling","text":"","title":"Error Handling"},{"location":"en/target_mem/#bounds-checking","text":"All methods include bounds checking: toPrintableString and toByteArrayText use std::min to prevent overflow nthMatch returns std::nullopt for invalid indices","title":"Bounds Checking"},{"location":"en/target_mem/#null-pointer-safety","text":"firstByteInChild is initialized to nullptr Methods verify vector sizes before access","title":"Null Pointer Safety"},{"location":"en/target_mem/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"en/target_mem/#complex-memory-analysis","text":"void analyze_memory_region(void* start, size_t size) { MatchesAndOldValuesArray matches(size); MatchesAndOldValuesSwath swath; swath.firstByteInChild = start; // Analyze each byte for (size_t i = 0; i < size; ++i) { void* addr = static_cast<char*>(start) + i; uint8_t value = read_memory_byte(addr); // Implementation specific MatchFlags flags = analyze_value(value); // Determine match type swath.addElement(addr, value, flags); } matches.addSwath(swath); // Process results auto first_match = matches.nthMatch(0); if (first_match) { // Found at least one match } }","title":"Complex Memory Analysis"},{"location":"en/target_mem/#memory-pattern-matching","text":"void find_string_patterns(const MatchesAndOldValuesArray& matches) { for (const auto& swath : matches.swaths) { for (size_t i = 0; i < swath.data.size(); ++i) { if (swath.data[i].match_info != MatchFlags::EMPTY) { // Check for ASCII string patterns std::string chars = swath.toPrintableString(i, 16); if (is_printable_string(chars)) { void* addr = static_cast<char*>(swath.firstByteInChild) + i; std::cout << \"String at \" << addr << \": \" << chars << \"\\n\"; } } } } }","title":"Memory Pattern Matching"},{"location":"en/target_mem/#integration-with-other-modules","text":"","title":"Integration with Other Modules"},{"location":"en/target_mem/#with-show-message-module","text":"import targetmem; import show_message; void report_matches(const MatchesAndOldValuesArray& matches) { MessagePrinter printer; size_t total_matches = 0; for (const auto& swath : matches.swaths) { for (const auto& [value, flags] : swath.data) { if (flags != MatchFlags::EMPTY) { total_matches++; } } } printer.info(\"Found {} total matches\", total_matches); }","title":"With Show Message Module"},{"location":"en/target_mem/#with-process-checker","text":"void scan_process_memory(pid_t pid) { if (ProcessChecker::is_process_dead(pid)) { return; } // Create memory scanner MatchesAndOldValuesArray matches(get_process_memory_size(pid)); // Perform scan... }","title":"With Process Checker"},{"location":"en/target_mem/#testing","text":"void test_target_memory() { // Test swath creation MatchesAndOldValuesSwath swath; swath.addElement(nullptr, 0x41, MatchFlags::U8B); assert(swath.data.size() == 1); assert(swath.data[0].old_value == 0x41); assert(swath.data[0].match_info == MatchFlags::U8B); // Test string representations std::string printable = swath.toPrintableString(0, 1); assert(printable == \"A\"); std::string hex = swath.toByteArrayText(0, 1); assert(hex == \"41\"); // Test array operations MatchesAndOldValuesArray array(1024); array.addSwath(swath); auto match = array.nthMatch(0); assert(match.has_value()); std::cout << \"All tests passed!\\n\"; }","title":"Testing"},{"location":"en/target_mem/#see-also","text":"Value Module - For MatchFlags definitions Process Checker Module - For process state checking Show Message Module - For logging and reporting","title":"See Also"},{"location":"en/target_mem/#future-enhancements","text":"Support for larger memory regions Compression for sparse match data Parallel processing support Memory scanning optimizations Integration with memory mapping APIs Support for different memory types (heap, stack, code) Pattern matching algorithms Memory write operations Snapshot and comparison features","title":"Future Enhancements"},{"location":"en/target_mem/#thread-safety","text":"The classes are not thread-safe by default. For concurrent access: Use external synchronization Consider immutable copies for read-only access Use separate instances for different threads","title":"Thread Safety"},{"location":"en/target_mem/#memory-management","text":"Automatic memory management via std::vector RAII principles for exception safety Efficient move semantics for large datasets Minimal heap allocations during operations","title":"Memory Management"},{"location":"en/value/","text":"Value Module Documentation Overview The value module provides comprehensive value type definitions and match flags for the NewScanmem project. It defines various data type representations, memory layouts, and utility structures for handling different numeric types, byte arrays, and wildcard patterns used in memory scanning operations. Module Structure export module value; Dependencies <cstdint> - Fixed-width integer types <cstring> - Byte copy <optional> - Optional type support <span> - Byte views <string> - String operations <type_traits> - Type utilities <vector> - Dynamic array container Core Features 1. Match Flags Enumeration enum class [[gnu::packed]] MatchFlags : uint16_t { EMPTY = 0, // Basic numeric types U8B = 1 << 0, // Unsigned 8-bit S8B = 1 << 1, // Signed 8-bit U16B = 1 << 2, // Unsigned 16-bit S16B = 1 << 3, // Signed 16-bit U32B = 1 << 4, // Unsigned 32-bit S32B = 1 << 5, // Signed 32-bit U64B = 1 << 6, // Unsigned 64-bit S64B = 1 << 7, // Signed 64-bit // Floating point types F32B = 1 << 8, // 32-bit float F64B = 1 << 9, // 64-bit float // Composite types I8B = U8B | S8B, // Any 8-bit integer I16B = U16B | S16B, // Any 16-bit integer I32B = U32B | S32B, // Any 32-bit integer I64B = U64B | S64B, // Any 64-bit integer INTEGER = I8B | I16B | I32B | I64B, // All integer types FLOAT = F32B | F64B, // All floating point types ALL = INTEGER | FLOAT, // All supported types // Byte-based groupings B8 = I8B, // 8-bit block B16 = I16B, // 16-bit block B32 = I32B | F32B, // 32-bit block B64 = I64B | F64B, // 64-bit block MAX = 0xffffU // Maximum flag value }; 2. Value Structure (byte-centric) Value stores historical (old) values as raw bytes. Type/width semantics are carried by flags . struct [[gnu::packed]] Value { std::vector<uint8_t> bytes; // Snapshot bytes MatchFlags flags = MatchFlags::EMPTY; // Type/width flag (required for numeric) constexpr static void zero(Value& val); // Views and setters std::span<const uint8_t> view() const noexcept; void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& val); void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f); void setBytesWithFlag(const std::vector<uint8_t>& val, MatchFlags f); template <typename T> void setScalar(const T& v); template <typename T> void setScalarWithFlag(const T& v, MatchFlags f); template <typename T> void setScalarTyped(const T& v); // auto-set correct flag }; Notes: - Numeric comparisons are strict: old value is decoded only if flags matches the requested type and the byte width is sufficient. - Byte array/string comparisons do not rely on flags . 3. Mem64 Structure (current bytes buffer) Mem64 represents the current bytes read at a memory location. struct [[gnu::packed]] Mem64 { std::vector<uint8_t> buffer; template <typename T> T get() const; // memcpy decode std::span<const uint8_t> bytes() const noexcept; // read-only view void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& data); void setString(const std::string& s); template <typename T> void setScalar(const T& v); }; Methods get<T>() : Decode the first sizeof(T) bytes using memcpy (throws if insufficient bytes). bytes() : Read-only span view over underlying bytes. setBytes(...) , setString(...) , setScalar<T>(...) : Write helpers. 4. Wildcard Enumeration enum class Wildcard : uint8_t { FIXED = 0xffU, // Fixed value (no wildcard) WILDCARD = 0x00U // Wildcard value (matches anything) }; 5. UserValue Structure Comprehensive user input value representation with optional fields. struct [[gnu::packed]] UserValue { // Basic numeric values int8_t int8_value = 0; uint8_t uint8_value = 0; int16_t int16_value = 0; uint16_t uint16_value = 0; int32_t int32_value = 0; uint32_t uint32_value = 0; int64_t int64_value = 0; uint64_t uint64_value = 0; float float32_value = 0.0F; double float64_value = 0.0; // Optional complex types std::optional<std::vector<uint8_t>> bytearray_value; std::optional<std::vector<uint8_t>> byteMask; // 0xFF=fixed, 0x00=wildcard std::optional<Wildcard> wildcard_value; // String and flags std::string string_value; MatchFlags flags = MatchFlags::EMPTY; }; Usage Examples Basic Value Creation (strict numeric + free-form bytes) import value; // Create values with different types Value uint8_val; uint8_val.setScalarTyped<uint8_t>(255); Value int32_val; int32_val.setScalarTyped<int32_t>(-42); Value float_val; float_val.setScalarTyped<float>(3.14f); Working with Mem64 Mem64 mem64; mem64.setScalar<int64_t>(INT64_MAX); auto int64_value = mem64.get<int64_t>(); mem64.setScalar<double>(M_PI); auto double_value = mem64.get<double>(); User Value Input UserValue user_val; // Set numeric values if needed user_val.int32_value = 42; user_val.float64_value = 1.23; // Set string value user_val.string_value = \"test_string\"; // Set byte array user_val.bytearray_value = std::vector<uint8_t>{0x01, 0x02, 0x03, 0x04}; // Optional wildcard intent (used with masked matching at higher level) user_val.wildcard_value = Wildcard::WILDCARD; Flag Operations // Check if flags include specific type bool is_integer = (flags & MatchFlags::INTEGER) != MatchFlags::EMPTY; bool is_float = (flags & MatchFlags::FLOAT) != MatchFlags::EMPTY; // Check specific bit width bool is_32bit = (flags & MatchFlags::B32) != MatchFlags::EMPTY; // Combine flags MatchFlags combined = MatchFlags::U8B | MatchFlags::U16B | MatchFlags::U32B; Byte Array Handling // Create value with byte array Value byte_val; std::vector<uint8_t> bytes{0x01, 0x02, 0x03, 0x04}; byte_val.setBytes(bytes); // Iterate bytes via view for (auto b : byte_val.view()) { std::cout << std::hex << static_cast<int>(b) << \" \"; } Memory Layout and Packing Structure Packing All structures use [[gnu::packed]] attribute to minimize memory usage: Value : bytes vector + flag Mem64 : bytes vector buffer UserValue : ~200+ bytes (including string and vectors) Alignment Structures are packed to minimize memory usage, which may impact performance on some architectures. Type Safety and Error Handling Runtime Type Checking Mem64 mem64; mem64.setScalar<int32_t>(42); // Decoding to a mismatched type or with insufficient bytes throws double val = mem64.get<double>(); Compile-time Type Checking // Static assertions ensure type safety static_assert(std::is_trivially_copyable_v<int64_t>); static_assert(sizeof(std::array<uint8_t, 8>) == 8); Integration Examples With Target Memory Module import value; import targetmem; void create_match_entry(void* addr, uint8_t byte, const Value& value) { OldValueAndMatchInfo info; info.old_value = byte; // Determine flags from context (example: 8-bit unsigned) info.match_info = MatchFlags::U8B; } With Endianness Module import value; import endianness; void handle_endianness(Value& val, bool reverse_endianness) { if (reverse_endianness) { endianness::fix_endianness(val, true); } } Testing void test_value_module() { // Test Value creation Value val; val.setScalarTyped<uint32_t>(42); // Test Mem64 Mem64 mem64; mem64.setScalar<float>(3.14f); assert(mem64.get<float>() == 3.14f); // Test flags MatchFlags flags = MatchFlags::U8B | MatchFlags::U16B; assert((flags & MatchFlags::U8B) != MatchFlags::EMPTY); // Test UserValue UserValue user_val; user_val.int32_value = 123; assert(user_val.int32_value == 123); std::cout << \"All tests passed!\\n\"; } Performance Considerations Memory Usage Value : Byte vector storage + strict flags Mem64 : Byte buffer with memcpy decode UserValue : Larger due to optional containers and string Runtime Performance Variant access : O(1) via std::visit or std::get Type checking : Compile-time with std::get_if Memory alignment : Packed structures may have alignment overhead Best Practices Use appropriate types : Choose specific numeric types over generic ones Initialize flags : Always set appropriate MatchFlags Handle type mismatches : Guard reads and check sizes for get<T>() Consider alignment : Packed structures may impact performance See Also Target Memory Module - Uses Value and MatchFlags Endianness Module - Handles byte order for values Show Message Module - For value reporting and debugging Future Enhancements Support for 128-bit types SIMD type support Custom allocator support Serialization/deserialization JSON conversion utilities Memory-mapped file support Zero-copy operations Type reflection capabilities Performance profiling utilities Cross-platform endianness detection helpers Platform Compatibility Linux : Full support macOS : Full support Windows : Full support 32-bit systems : Limited 64-bit type support Big-endian : Full support with appropriate endianness handling Migration Guide From C-style unions // Old C-style union union ValueUnion { uint8_t u8; uint16_t u16; uint32_t u32; float f32; }; // New C++23 variant Value val = uint32_t{42}; // Type-safe and extensible From raw pointers ```cpp // Old raw pointer approach void ptr = malloc(sizeof(int32_t)); (int32_t*)ptr = 42; // New type-safe approach Mem64 mem64; mem64.set (42); // Safe and automatic cleanup","title":"Value"},{"location":"en/value/#value-module-documentation","text":"","title":"Value Module Documentation"},{"location":"en/value/#overview","text":"The value module provides comprehensive value type definitions and match flags for the NewScanmem project. It defines various data type representations, memory layouts, and utility structures for handling different numeric types, byte arrays, and wildcard patterns used in memory scanning operations.","title":"Overview"},{"location":"en/value/#module-structure","text":"export module value;","title":"Module Structure"},{"location":"en/value/#dependencies","text":"<cstdint> - Fixed-width integer types <cstring> - Byte copy <optional> - Optional type support <span> - Byte views <string> - String operations <type_traits> - Type utilities <vector> - Dynamic array container","title":"Dependencies"},{"location":"en/value/#core-features","text":"","title":"Core Features"},{"location":"en/value/#1-match-flags-enumeration","text":"enum class [[gnu::packed]] MatchFlags : uint16_t { EMPTY = 0, // Basic numeric types U8B = 1 << 0, // Unsigned 8-bit S8B = 1 << 1, // Signed 8-bit U16B = 1 << 2, // Unsigned 16-bit S16B = 1 << 3, // Signed 16-bit U32B = 1 << 4, // Unsigned 32-bit S32B = 1 << 5, // Signed 32-bit U64B = 1 << 6, // Unsigned 64-bit S64B = 1 << 7, // Signed 64-bit // Floating point types F32B = 1 << 8, // 32-bit float F64B = 1 << 9, // 64-bit float // Composite types I8B = U8B | S8B, // Any 8-bit integer I16B = U16B | S16B, // Any 16-bit integer I32B = U32B | S32B, // Any 32-bit integer I64B = U64B | S64B, // Any 64-bit integer INTEGER = I8B | I16B | I32B | I64B, // All integer types FLOAT = F32B | F64B, // All floating point types ALL = INTEGER | FLOAT, // All supported types // Byte-based groupings B8 = I8B, // 8-bit block B16 = I16B, // 16-bit block B32 = I32B | F32B, // 32-bit block B64 = I64B | F64B, // 64-bit block MAX = 0xffffU // Maximum flag value };","title":"1. Match Flags Enumeration"},{"location":"en/value/#2-value-structure-byte-centric","text":"Value stores historical (old) values as raw bytes. Type/width semantics are carried by flags . struct [[gnu::packed]] Value { std::vector<uint8_t> bytes; // Snapshot bytes MatchFlags flags = MatchFlags::EMPTY; // Type/width flag (required for numeric) constexpr static void zero(Value& val); // Views and setters std::span<const uint8_t> view() const noexcept; void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& val); void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f); void setBytesWithFlag(const std::vector<uint8_t>& val, MatchFlags f); template <typename T> void setScalar(const T& v); template <typename T> void setScalarWithFlag(const T& v, MatchFlags f); template <typename T> void setScalarTyped(const T& v); // auto-set correct flag }; Notes: - Numeric comparisons are strict: old value is decoded only if flags matches the requested type and the byte width is sufficient. - Byte array/string comparisons do not rely on flags .","title":"2. Value Structure (byte-centric)"},{"location":"en/value/#3-mem64-structure-current-bytes-buffer","text":"Mem64 represents the current bytes read at a memory location. struct [[gnu::packed]] Mem64 { std::vector<uint8_t> buffer; template <typename T> T get() const; // memcpy decode std::span<const uint8_t> bytes() const noexcept; // read-only view void setBytes(const uint8_t* data, std::size_t len); void setBytes(const std::vector<uint8_t>& data); void setString(const std::string& s); template <typename T> void setScalar(const T& v); };","title":"3. Mem64 Structure (current bytes buffer)"},{"location":"en/value/#methods","text":"get<T>() : Decode the first sizeof(T) bytes using memcpy (throws if insufficient bytes). bytes() : Read-only span view over underlying bytes. setBytes(...) , setString(...) , setScalar<T>(...) : Write helpers.","title":"Methods"},{"location":"en/value/#4-wildcard-enumeration","text":"enum class Wildcard : uint8_t { FIXED = 0xffU, // Fixed value (no wildcard) WILDCARD = 0x00U // Wildcard value (matches anything) };","title":"4. Wildcard Enumeration"},{"location":"en/value/#5-uservalue-structure","text":"Comprehensive user input value representation with optional fields. struct [[gnu::packed]] UserValue { // Basic numeric values int8_t int8_value = 0; uint8_t uint8_value = 0; int16_t int16_value = 0; uint16_t uint16_value = 0; int32_t int32_value = 0; uint32_t uint32_value = 0; int64_t int64_value = 0; uint64_t uint64_value = 0; float float32_value = 0.0F; double float64_value = 0.0; // Optional complex types std::optional<std::vector<uint8_t>> bytearray_value; std::optional<std::vector<uint8_t>> byteMask; // 0xFF=fixed, 0x00=wildcard std::optional<Wildcard> wildcard_value; // String and flags std::string string_value; MatchFlags flags = MatchFlags::EMPTY; };","title":"5. UserValue Structure"},{"location":"en/value/#usage-examples","text":"","title":"Usage Examples"},{"location":"en/value/#basic-value-creation-strict-numeric-free-form-bytes","text":"import value; // Create values with different types Value uint8_val; uint8_val.setScalarTyped<uint8_t>(255); Value int32_val; int32_val.setScalarTyped<int32_t>(-42); Value float_val; float_val.setScalarTyped<float>(3.14f);","title":"Basic Value Creation (strict numeric + free-form bytes)"},{"location":"en/value/#working-with-mem64","text":"Mem64 mem64; mem64.setScalar<int64_t>(INT64_MAX); auto int64_value = mem64.get<int64_t>(); mem64.setScalar<double>(M_PI); auto double_value = mem64.get<double>();","title":"Working with Mem64"},{"location":"en/value/#user-value-input","text":"UserValue user_val; // Set numeric values if needed user_val.int32_value = 42; user_val.float64_value = 1.23; // Set string value user_val.string_value = \"test_string\"; // Set byte array user_val.bytearray_value = std::vector<uint8_t>{0x01, 0x02, 0x03, 0x04}; // Optional wildcard intent (used with masked matching at higher level) user_val.wildcard_value = Wildcard::WILDCARD;","title":"User Value Input"},{"location":"en/value/#flag-operations","text":"// Check if flags include specific type bool is_integer = (flags & MatchFlags::INTEGER) != MatchFlags::EMPTY; bool is_float = (flags & MatchFlags::FLOAT) != MatchFlags::EMPTY; // Check specific bit width bool is_32bit = (flags & MatchFlags::B32) != MatchFlags::EMPTY; // Combine flags MatchFlags combined = MatchFlags::U8B | MatchFlags::U16B | MatchFlags::U32B;","title":"Flag Operations"},{"location":"en/value/#byte-array-handling","text":"// Create value with byte array Value byte_val; std::vector<uint8_t> bytes{0x01, 0x02, 0x03, 0x04}; byte_val.setBytes(bytes); // Iterate bytes via view for (auto b : byte_val.view()) { std::cout << std::hex << static_cast<int>(b) << \" \"; }","title":"Byte Array Handling"},{"location":"en/value/#memory-layout-and-packing","text":"","title":"Memory Layout and Packing"},{"location":"en/value/#structure-packing","text":"All structures use [[gnu::packed]] attribute to minimize memory usage: Value : bytes vector + flag Mem64 : bytes vector buffer UserValue : ~200+ bytes (including string and vectors)","title":"Structure Packing"},{"location":"en/value/#alignment","text":"Structures are packed to minimize memory usage, which may impact performance on some architectures.","title":"Alignment"},{"location":"en/value/#type-safety-and-error-handling","text":"","title":"Type Safety and Error Handling"},{"location":"en/value/#runtime-type-checking","text":"Mem64 mem64; mem64.setScalar<int32_t>(42); // Decoding to a mismatched type or with insufficient bytes throws double val = mem64.get<double>();","title":"Runtime Type Checking"},{"location":"en/value/#compile-time-type-checking","text":"// Static assertions ensure type safety static_assert(std::is_trivially_copyable_v<int64_t>); static_assert(sizeof(std::array<uint8_t, 8>) == 8);","title":"Compile-time Type Checking"},{"location":"en/value/#integration-examples","text":"","title":"Integration Examples"},{"location":"en/value/#with-target-memory-module","text":"import value; import targetmem; void create_match_entry(void* addr, uint8_t byte, const Value& value) { OldValueAndMatchInfo info; info.old_value = byte; // Determine flags from context (example: 8-bit unsigned) info.match_info = MatchFlags::U8B; }","title":"With Target Memory Module"},{"location":"en/value/#with-endianness-module","text":"import value; import endianness; void handle_endianness(Value& val, bool reverse_endianness) { if (reverse_endianness) { endianness::fix_endianness(val, true); } }","title":"With Endianness Module"},{"location":"en/value/#testing","text":"void test_value_module() { // Test Value creation Value val; val.setScalarTyped<uint32_t>(42); // Test Mem64 Mem64 mem64; mem64.setScalar<float>(3.14f); assert(mem64.get<float>() == 3.14f); // Test flags MatchFlags flags = MatchFlags::U8B | MatchFlags::U16B; assert((flags & MatchFlags::U8B) != MatchFlags::EMPTY); // Test UserValue UserValue user_val; user_val.int32_value = 123; assert(user_val.int32_value == 123); std::cout << \"All tests passed!\\n\"; }","title":"Testing"},{"location":"en/value/#performance-considerations","text":"","title":"Performance Considerations"},{"location":"en/value/#memory-usage","text":"Value : Byte vector storage + strict flags Mem64 : Byte buffer with memcpy decode UserValue : Larger due to optional containers and string","title":"Memory Usage"},{"location":"en/value/#runtime-performance","text":"Variant access : O(1) via std::visit or std::get Type checking : Compile-time with std::get_if Memory alignment : Packed structures may have alignment overhead","title":"Runtime Performance"},{"location":"en/value/#best-practices","text":"Use appropriate types : Choose specific numeric types over generic ones Initialize flags : Always set appropriate MatchFlags Handle type mismatches : Guard reads and check sizes for get<T>() Consider alignment : Packed structures may impact performance","title":"Best Practices"},{"location":"en/value/#see-also","text":"Target Memory Module - Uses Value and MatchFlags Endianness Module - Handles byte order for values Show Message Module - For value reporting and debugging","title":"See Also"},{"location":"en/value/#future-enhancements","text":"Support for 128-bit types SIMD type support Custom allocator support Serialization/deserialization JSON conversion utilities Memory-mapped file support Zero-copy operations Type reflection capabilities Performance profiling utilities Cross-platform endianness detection helpers","title":"Future Enhancements"},{"location":"en/value/#platform-compatibility","text":"Linux : Full support macOS : Full support Windows : Full support 32-bit systems : Limited 64-bit type support Big-endian : Full support with appropriate endianness handling","title":"Platform Compatibility"},{"location":"en/value/#migration-guide","text":"","title":"Migration Guide"},{"location":"en/value/#from-c-style-unions","text":"// Old C-style union union ValueUnion { uint8_t u8; uint16_t u16; uint32_t u32; float f32; }; // New C++23 variant Value val = uint32_t{42}; // Type-safe and extensible","title":"From C-style unions"},{"location":"en/value/#from-raw-pointers","text":"```cpp // Old raw pointer approach void ptr = malloc(sizeof(int32_t)); (int32_t*)ptr = 42; // New type-safe approach Mem64 mem64; mem64.set (42); // Safe and automatic cleanup","title":"From raw pointers"}]}