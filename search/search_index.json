{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u5f00\u59cb","text":"<p>\u6b22\u8fce\u8bbf\u95ee NewScanmem \u6587\u6863\u7ad9\u70b9\uff01\u8fd9\u91cc\u63d0\u4f9b\u9879\u76ee\u6982\u89c8\u3001\u4f7f\u7528\u6307\u5357\u4ee5\u53ca API \u53c2\u8003\u3002</p>"},{"location":"#newscanmem","title":"\u5173\u4e8e NewScanmem","text":"<p>NewScanmem \u662f\u4e00\u4e2a\u4f7f\u7528 C++20/23 \u6784\u5efa\u7684\u5185\u5b58\u626b\u63cf\u4e0e\u8c03\u8bd5\u5de5\u5177\uff0c\u4e13\u6ce8\u4e8e Linux \u5e73\u53f0\u7684\u8fdb\u7a0b\u5185\u5b58\u626b\u63cf\u4e0e\u5206\u6790\uff0c\u652f\u6301\u591a\u79cd\u6570\u636e\u7c7b\u578b\u4e0e\u5b57\u8282\u5e8f\u5904\u7406\u3002</p>"},{"location":"API_REFERENCE/","title":"API \u53c2\u8003","text":""},{"location":"API_REFERENCE/#_1","title":"\u6a21\u5757\u7d22\u5f15","text":"<ul> <li>endianness</li> <li>maps </li> <li>process_checker</li> <li>sets</li> <li>show_message</li> <li>targetmem</li> <li>value</li> </ul>"},{"location":"API_REFERENCE/#maps","title":"maps","text":""},{"location":"API_REFERENCE/#region_type","title":"\u679a\u4e3e\uff1a<code>region_type</code>","text":"<pre><code>enum class region_type : uint8_t {\n    misc,   // \u6742\u9879\u5185\u5b58\u533a\u57df\n    exe,    // \u53ef\u6267\u884c\u6587\u4ef6\u4e8c\u8fdb\u5236\u533a\u57df\n    code,   // \u4ee3\u7801\u6bb5\uff08\u5171\u4eab\u5e93\u7b49\uff09\n    heap,   // \u5806\u5185\u5b58\u533a\u57df\n    stack   // \u6808\u5185\u5b58\u533a\u57df\n};\n\nconstexpr std::array&lt;std::string_view, 5&gt; region_type_names;\n</code></pre>"},{"location":"API_REFERENCE/#region_scan_level","title":"\u679a\u4e3e\uff1a<code>region_scan_level</code>","text":"<pre><code>enum class region_scan_level : uint8_t {\n    all,                       // \u6240\u6709\u53ef\u8bfb\u533a\u57df\n    all_rw,                    // \u6240\u6709\u53ef\u8bfb/\u53ef\u5199\u533a\u57df\n    heap_stack_executable,     // \u5806\u3001\u6808\u548c\u53ef\u6267\u884c\u533a\u57df\n    heap_stack_executable_bss  // \u4e0a\u8ff0\u52a0\u4e0a BSS \u6bb5\n};\n</code></pre>"},{"location":"API_REFERENCE/#region_flags","title":"\u7ed3\u6784\uff1a<code>region_flags</code>","text":"<pre><code>struct region_flags {\n    bool read : 1;    // \u8bfb\u6743\u9650\n    bool write : 1;   // \u5199\u6743\u9650\n    bool exec : 1;    // \u6267\u884c\u6743\u9650\n    bool shared : 1;  // \u5171\u4eab\u6620\u5c04\n    bool private_ : 1; // \u79c1\u6709\u6620\u5c04\n};\n</code></pre>"},{"location":"API_REFERENCE/#region","title":"\u7ed3\u6784\uff1a<code>region</code>","text":"<pre><code>struct region {\n    void* start;           // \u8d77\u59cb\u5730\u5740\n    std::size_t size;      // \u533a\u57df\u5927\u5c0f\uff08\u5b57\u8282\uff09\n    region_type type;      // \u533a\u57df\u5206\u7c7b\n    region_flags flags;    // \u6743\u9650\u6807\u5fd7\n    void* load_addr;       // ELF \u6587\u4ef6\u7684\u52a0\u8f7d\u5730\u5740\n    std::string filename;  // \u5173\u8054\u6587\u4ef6\u8def\u5f84\n    std::size_t id;        // \u552f\u4e00\u6807\u8bc6\u7b26\n\n    [[nodiscard]] bool is_readable() const noexcept;\n    [[nodiscard]] bool is_writable() const noexcept;\n    [[nodiscard]] bool is_executable() const noexcept;\n    [[nodiscard]] bool is_shared() const noexcept;\n    [[nodiscard]] bool is_private() const noexcept;\n    [[nodiscard]] std::pair&lt;void*, std::size_t&gt; as_span() const noexcept;\n    [[nodiscard]] bool contains(void* address) const noexcept;\n};\n</code></pre>"},{"location":"API_REFERENCE/#maps_readererror","title":"\u7ed3\u6784\uff1a<code>maps_reader::error</code>","text":"<pre><code>struct error {\n    std::string message;   // \u4eba\u7c7b\u53ef\u8bfb\u7684\u9519\u8bef\u63cf\u8ff0\n    std::error_code code;  // \u7cfb\u7edf\u9519\u8bef\u4ee3\u7801\n};\n</code></pre>"},{"location":"API_REFERENCE/#maps_reader","title":"\u7c7b\uff1a<code>maps_reader</code>","text":""},{"location":"API_REFERENCE/#_2","title":"\u9759\u6001\u65b9\u6cd5","text":"<pre><code>[[nodiscard]] static std::expected&lt;std::vector&lt;region&gt;, error&gt; \nread_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);\n</code></pre>"},{"location":"API_REFERENCE/#_3","title":"\u4fbf\u5229\u51fd\u6570","text":"<pre><code>[[nodiscard]] std::expected&lt;std::vector&lt;region&gt;, maps_reader::error&gt; \nread_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);\n</code></pre>"},{"location":"API_REFERENCE/#_4","title":"\u4f7f\u7528\u793a\u4f8b","text":"<pre><code>import maps;\n\n// \u57fa\u672c\u7528\u6cd5\nauto regions = maps::read_process_maps(1234);\n\n// \u8fc7\u6ee4\u626b\u63cf\nauto heap_regions = maps::read_process_maps(\n    pid, \n    maps::region_scan_level::heap_stack_executable\n);\n\n// \u9519\u8bef\u5904\u7406\nif (!regions) {\n    std::cerr &lt;&lt; \"\u9519\u8bef: \" &lt;&lt; regions.error().message &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"API_REFERENCE/#endianness","title":"endianness","text":""},{"location":"API_REFERENCE/#endianness_1","title":"\u547d\u540d\u7a7a\u95f4: <code>endianness</code>","text":""},{"location":"API_REFERENCE/#_5","title":"\u51fd\u6570","text":"<pre><code>// \u5b57\u8282\u5e8f\u68c0\u6d4b\nconstexpr bool is_big_endian() noexcept;\nconstexpr bool is_little_endian() noexcept;\n\n// \u5b57\u8282\u4ea4\u6362\nconstexpr uint8_t swap_bytes(uint8_t value) noexcept;\nconstexpr uint16_t swap_bytes(uint16_t value) noexcept;\nconstexpr uint32_t swap_bytes(uint32_t value) noexcept;\nconstexpr uint64_t swap_bytes(uint64_t value) noexcept;\n\ntemplate&lt;typename T&gt;\nconstexpr T swap_bytes_integral(T value) noexcept;\n\nvoid swap_bytes_inplace(void* data, size_t size);\n\n// \u5b57\u8282\u5e8f\u4fee\u6b63\nvoid fix_endianness(Value&amp; value, bool reverse_endianness) noexcept;\n\n// \u7f51\u7edc\u5b57\u8282\u5e8f\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T host_to_network(T value) noexcept;\n\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T network_to_host(T value) noexcept;\n\n// \u5c0f\u7aef\u5e8f\u8f6c\u6362\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T host_to_little_endian(T value) noexcept;\n\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T little_endian_to_host(T value) noexcept;\n</code></pre>"},{"location":"API_REFERENCE/#_6","title":"\u6982\u5ff5","text":"<pre><code>template&lt;typename T&gt;\nconcept SwappableIntegral = std::integral&lt;T&gt; &amp;&amp; \n    (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8);\n</code></pre>"},{"location":"API_REFERENCE/#process_checker","title":"process_checker","text":""},{"location":"API_REFERENCE/#processstate","title":"\u679a\u4e3e: <code>ProcessState</code>","text":"<pre><code>enum class ProcessState { RUNNING, ERROR, DEAD, ZOMBIE };\n</code></pre>"},{"location":"API_REFERENCE/#processchecker","title":"\u7c7b: <code>ProcessChecker</code>","text":""},{"location":"API_REFERENCE/#processchecker_1","title":"ProcessChecker \u9759\u6001\u65b9\u6cd5","text":"<pre><code>static ProcessState check_process(pid_t pid);\nstatic bool is_process_dead(pid_t pid);\n</code></pre>"},{"location":"API_REFERENCE/#sets","title":"sets","text":""},{"location":"API_REFERENCE/#set","title":"\u7ed3\u6784\u4f53: <code>Set</code>","text":"<pre><code>struct Set {\n    std::vector&lt;size_t&gt; buf;\n\n    size_t size() const;\n    void clear();\n    static int cmp(const size_t&amp; i1, const size_t&amp; i2);\n};\n</code></pre>"},{"location":"API_REFERENCE/#set_1","title":"Set \u51fd\u6570","text":"<pre><code>bool parse_uintset(std::string_view lptr, Set&amp; set, size_t maxSZ);\n</code></pre>"},{"location":"API_REFERENCE/#show_message","title":"show_message","text":""},{"location":"API_REFERENCE/#messagetype","title":"\u679a\u4e3e: <code>MessageType</code>","text":"<pre><code>enum class MessageType : uint8_t {\n    INFO,    // \u4fe1\u606f\u6d88\u606f\n    WARN,    // \u8b66\u544a\u6d88\u606f\n    ERROR,   // \u9519\u8bef\u6d88\u606f\n    DEBUG,   // \u8c03\u8bd5\u6d88\u606f\n    USER     // \u7528\u6237\u6d88\u606f\n};\n</code></pre>"},{"location":"API_REFERENCE/#messagecontext","title":"\u7ed3\u6784\u4f53: <code>MessageContext</code>","text":"<pre><code>struct MessageContext {\n    bool debugMode = false;    // \u8c03\u8bd5\u6a21\u5f0f\n    bool backendMode = false;  // \u540e\u7aef\u6a21\u5f0f\n};\n</code></pre>"},{"location":"API_REFERENCE/#messageprinter","title":"\u7c7b: <code>MessagePrinter</code>","text":""},{"location":"API_REFERENCE/#_7","title":"\u6784\u9020\u51fd\u6570","text":"<pre><code>MessagePrinter(MessageContext ctx = {});\n</code></pre>"},{"location":"API_REFERENCE/#_8","title":"\u65b9\u6cd5","text":"<pre><code>template&lt;typename... Args&gt;\nvoid print(MessageType type, std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid info(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid warn(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid error(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid debug(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid user(std::string_view fmt, Args&amp;&amp;... args) const;\n</code></pre>"},{"location":"API_REFERENCE/#targetmem","title":"targetmem","text":""},{"location":"API_REFERENCE/#oldvalueandmatchinfo","title":"\u7ed3\u6784\u4f53: <code>OldValueAndMatchInfo</code>","text":"<pre><code>struct OldValueAndMatchInfo {\n    uint8_t old_value;      // \u539f\u59cb\u5b57\u8282\u503c\n    MatchFlags match_info;  // \u5339\u914d\u7c7b\u578b\u548c\u72b6\u6001\u6807\u5fd7\n};\n</code></pre>"},{"location":"API_REFERENCE/#matchesandoldvaluesswath","title":"\u7c7b: <code>MatchesAndOldValuesSwath</code>","text":""},{"location":"API_REFERENCE/#_9","title":"\u6210\u5458\u53d8\u91cf","text":"<pre><code>void* firstByteInChild = nullptr;                    // \u8d77\u59cb\u5730\u5740\nstd::vector&lt;OldValueAndMatchInfo&gt; data;              // \u5339\u914d\u6570\u636e\n</code></pre>"},{"location":"API_REFERENCE/#matchesandoldvaluesswath_1","title":"MatchesAndOldValuesSwath \u65b9\u6cd5","text":"<pre><code>void addElement(void* addr, uint8_t byte, MatchFlags matchFlags);\nstd::string toPrintableString(size_t idx, size_t len) const;\nstd::string toByteArrayText(size_t idx, size_t len) const;\n</code></pre>"},{"location":"API_REFERENCE/#matchesandoldvaluesarray","title":"\u7c7b: <code>MatchesAndOldValuesArray</code>","text":""},{"location":"API_REFERENCE/#matchesandoldvaluesarray_1","title":"MatchesAndOldValuesArray \u6210\u5458\u53d8\u91cf","text":"<pre><code>std::vector&lt;MatchesAndOldValuesSwath&gt; swaths;        // \u5185\u5b58\u533a\u57df\u96c6\u5408\n</code></pre>"},{"location":"API_REFERENCE/#matchesandoldvaluesarray_2","title":"MatchesAndOldValuesArray \u65b9\u6cd5","text":"<pre><code>std::optional&lt;size_t&gt; findSwathIndex(void* addr) const;\nstd::optional&lt;size_t&gt; findElementIndex(void* addr) const;\nconst OldValueAndMatchInfo* getElement(void* addr) const;\nOldValueAndMatchInfo* getElement(void* addr);\nvoid clear();\nsize_t size() const;\n</code></pre>"},{"location":"API_REFERENCE/#value","title":"value","text":""},{"location":"API_REFERENCE/#matchflags","title":"\u679a\u4e3e: <code>MatchFlags</code>","text":"<pre><code>enum class [[gnu::packed]] MatchFlags : uint16_t {\n    EMPTY = 0,\n\n    // \u57fa\u672c\u6570\u503c\u7c7b\u578b\n    U8B = 1 &lt;&lt; 0,   // \u65e0\u7b26\u53f7 8 \u4f4d\n    S8B = 1 &lt;&lt; 1,   // \u6709\u7b26\u53f7 8 \u4f4d\n    U16B = 1 &lt;&lt; 2,  // \u65e0\u7b26\u53f7 16 \u4f4d\n    S16B = 1 &lt;&lt; 3,  // \u6709\u7b26\u53f7 16 \u4f4d\n    U32B = 1 &lt;&lt; 4,  // \u65e0\u7b26\u53f7 32 \u4f4d\n    S32B = 1 &lt;&lt; 5,  // \u6709\u7b26\u53f7 32 \u4f4d\n    U64B = 1 &lt;&lt; 6,  // \u65e0\u7b26\u53f7 64 \u4f4d\n    S64B = 1 &lt;&lt; 7,  // \u6709\u7b26\u53f7 64 \u4f4d\n\n    // \u6d6e\u70b9\u7c7b\u578b\n    F32B = 1 &lt;&lt; 8,  // 32 \u4f4d\u6d6e\u70b9\n    F64B = 1 &lt;&lt; 9,  // 64 \u4f4d\u6d6e\u70b9\n\n    // \u590d\u5408\u7c7b\u578b\n    I8B = U8B | S8B,      // \u4efb\u610f 8 \u4f4d\u6574\u6570\n    I16B = U16B | S16B,   // \u4efb\u610f 16 \u4f4d\u6574\u6570\n    I32B = U32B | S32B,   // \u4efb\u610f 32 \u4f4d\u6574\u6570\n    I64B = U64B | S64B,   // \u4efb\u610f 64 \u4f4d\u6574\u6570\n\n    INTEGER = I8B | I16B | I32B | I64B,  // \u6240\u6709\u6574\u6570\u7c7b\u578b\n    FLOAT = F32B | F64B,                  // \u6240\u6709\u6d6e\u70b9\u7c7b\u578b\n    ALL = INTEGER | FLOAT,                // \u6240\u6709\u652f\u6301\u7684\u7c7b\u578b\n\n    // \u57fa\u4e8e\u5b57\u8282\u7684\u5206\u7ec4\n    B8 = I8B,           // 8 \u4f4d\u5757\n    B16 = I16B,         // 16 \u4f4d\u5757\n    B32 = I32B | F32B,  // 32 \u4f4d\u5757\n    B64 = I64B | F64B,  // 64 \u4f4d\u5757\n\n    MAX = 0xffffU  // \u6700\u5927\u6807\u5fd7\u503c\n};\n</code></pre>"},{"location":"API_REFERENCE/#value_1","title":"\u7ed3\u6784\u4f53: <code>Value</code>","text":"<pre><code>struct [[gnu::packed]] Value {\n    std::vector&lt;uint8_t&gt; bytes;      // \u5386\u53f2\u503c\u5b57\u8282\n    MatchFlags flags = MatchFlags::EMPTY; // \u7c7b\u578b/\u5bbd\u5ea6\u6807\u5fd7\n\n    // \u590d\u4f4d\n    constexpr static void zero(Value&amp; val);\n\n    // \u89c6\u56fe\u4e0e\u8bbe\u7f6e\n    std::span&lt;const uint8_t&gt; view() const noexcept;\n    void setBytes(const uint8_t* data, std::size_t len);\n    void setBytes(const std::vector&lt;uint8_t&gt;&amp; val);\n    void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f);\n    void setBytesWithFlag(const std::vector&lt;uint8_t&gt;&amp; val, MatchFlags f);\n    template &lt;typename T&gt; void setScalar(const T&amp; v);\n    template &lt;typename T&gt; void setScalarWithFlag(const T&amp; v, MatchFlags f);\n    template &lt;typename T&gt; void setScalarTyped(const T&amp; v);\n};\n</code></pre> <p>\u6570\u503c\u4e25\u683c\uff1a\u65e7\u503c\u89e3\u7801\u65f6\u9700\u8981 <code>flags</code> \u4e0e\u7c7b\u578b\u5339\u914d\u4e14\u5b57\u8282\u6570\u8db3\u591f\uff1b\u5b57\u8282\u4e32/\u5b57\u7b26\u4e32\u4e0d\u53d7\u6b64\u9650\u5236\u3002</p>"},{"location":"API_REFERENCE/#mem64","title":"\u7ed3\u6784\u4f53: <code>Mem64</code>","text":"<pre><code>struct [[gnu::packed]] Mem64 {\n    std::vector&lt;uint8_t&gt; buffer;     // \u5f53\u524d\u503c\u5b57\u8282\n\n    template &lt;typename T&gt; T get() const;              // \u4ee5 memcpy \u89e3\u7801\n    std::span&lt;const uint8_t&gt; bytes() const noexcept;  // \u53ea\u8bfb\u5b57\u8282\u89c6\u56fe\n    void setBytes(const uint8_t* data, std::size_t len);\n    void setBytes(const std::vector&lt;uint8_t&gt;&amp; data);\n    void setString(const std::string&amp; s);\n    template &lt;typename T&gt; void setScalar(const T&amp; v);\n};\n</code></pre>"},{"location":"API_REFERENCE/#_10","title":"\u8be6\u7ec6\u51fd\u6570\u8bf4\u660e","text":""},{"location":"API_REFERENCE/#endianness_2","title":"endianness \u6a21\u5757","text":""},{"location":"API_REFERENCE/#is_big_endian","title":"<code>is_big_endian()</code>","text":"<p>\u68c0\u6d4b\u7cfb\u7edf\u662f\u5426\u4e3a\u5927\u7aef\u5e8f\u3002</p> <p>\u8fd4\u56de\u503c: <code>true</code> \u5982\u679c\u7cfb\u7edf\u4e3a\u5927\u7aef\u5e8f\uff0c\u5426\u5219 <code>false</code></p>"},{"location":"API_REFERENCE/#is_little_endian","title":"<code>is_little_endian()</code>","text":"<p>\u68c0\u6d4b\u7cfb\u7edf\u662f\u5426\u4e3a\u5c0f\u7aef\u5e8f\u3002</p> <p>\u8fd4\u56de\u503c: <code>true</code> \u5982\u679c\u7cfb\u7edf\u4e3a\u5c0f\u7aef\u5e8f\uff0c\u5426\u5219 <code>false</code></p>"},{"location":"API_REFERENCE/#swap_bytest-value","title":"<code>swap_bytes(T value)</code>","text":"<p>\u4ea4\u6362\u6307\u5b9a\u7c7b\u578b\u503c\u7684\u5b57\u8282\u5e8f\u3002</p> <p>\u6a21\u677f\u53c2\u6570: <code>T</code> - \u6574\u6570\u7c7b\u578b (uint8_t, uint16_t, uint32_t, uint64_t)</p> <p>\u53c2\u6570: <code>value</code> - \u8981\u4ea4\u6362\u5b57\u8282\u5e8f\u7684\u503c</p> <p>\u8fd4\u56de\u503c: \u4ea4\u6362\u5b57\u8282\u5e8f\u540e\u7684\u503c</p>"},{"location":"API_REFERENCE/#swap_bytes_inplacevoid-data-size_t-size","title":"<code>swap_bytes_inplace(void* data, size_t size)</code>","text":"<p>\u539f\u5730\u4ea4\u6362\u5185\u5b58\u4e2d\u6570\u636e\u7684\u5b57\u8282\u5e8f\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>data</code> - \u6307\u5411\u6570\u636e\u7684\u6307\u9488</li> <li><code>size</code> - \u6570\u636e\u5927\u5c0f\uff08\u5b57\u8282\uff09</li> </ul>"},{"location":"API_REFERENCE/#fix_endiannessvalue-value-bool-reverse_endianness","title":"<code>fix_endianness(Value&amp; value, bool reverse_endianness)</code>","text":"<p>\u4fee\u6b63 Value \u5bf9\u8c61\u7684\u5b57\u8282\u5e8f\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>value</code> - \u8981\u4fee\u6b63\u7684 Value \u5bf9\u8c61</li> <li><code>reverse_endianness</code> - \u662f\u5426\u53cd\u8f6c\u5b57\u8282\u5e8f</li> </ul>"},{"location":"API_REFERENCE/#process_checker_1","title":"process_checker \u6a21\u5757","text":""},{"location":"API_REFERENCE/#processcheckercheck_processpid_t-pid","title":"<code>ProcessChecker::check_process(pid_t pid)</code>","text":"<p>\u68c0\u67e5\u6307\u5b9a\u8fdb\u7a0b\u7684\u72b6\u6001\u3002</p> <p>\u53c2\u6570: <code>pid</code> - \u8fdb\u7a0b ID</p> <p>\u8fd4\u56de\u503c: <code>ProcessState</code> \u679a\u4e3e\u503c\u8868\u793a\u8fdb\u7a0b\u72b6\u6001</p>"},{"location":"API_REFERENCE/#processcheckeris_process_deadpid_t-pid","title":"<code>ProcessChecker::is_process_dead(pid_t pid)</code>","text":"<p>\u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u5df2\u6b7b\u4ea1\u3002</p> <p>\u53c2\u6570: <code>pid</code> - \u8fdb\u7a0b ID</p> <p>\u8fd4\u56de\u503c: <code>true</code> \u5982\u679c\u8fdb\u7a0b\u5df2\u6b7b\u4ea1\u6216\u4e0d\u5b58\u5728\uff0c\u5426\u5219 <code>false</code></p>"},{"location":"API_REFERENCE/#sets_1","title":"sets \u6a21\u5757","text":""},{"location":"API_REFERENCE/#setsize","title":"<code>Set::size()</code>","text":"<p>\u83b7\u53d6\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6570\u91cf\u3002</p> <p>\u8fd4\u56de\u503c: \u5143\u7d20\u6570\u91cf</p>"},{"location":"API_REFERENCE/#setclear","title":"<code>Set::clear()</code>","text":"<p>\u6e05\u7a7a\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20\u3002</p>"},{"location":"API_REFERENCE/#setcmpconst-size_t-i1-const-size_t-i2","title":"<code>Set::cmp(const size_t&amp; i1, const size_t&amp; i2)</code>","text":"<p>\u6bd4\u8f83\u4e24\u4e2a size_t \u503c\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>i1</code> - \u7b2c\u4e00\u4e2a\u503c</li> <li><code>i2</code> - \u7b2c\u4e8c\u4e2a\u503c</li> </ul> <p>\u8fd4\u56de\u503c: \u6bd4\u8f83\u7ed3\u679c\uff08-1, 0, 1\uff09</p>"},{"location":"API_REFERENCE/#parse_uintsetstdstring_view-lptr-set-set-size_t-maxsz","title":"<code>parse_uintset(std::string_view lptr, Set&amp; set, size_t maxSZ)</code>","text":"<p>\u89e3\u6790\u65e0\u7b26\u53f7\u6574\u6570\u96c6\u5408\u8868\u8fbe\u5f0f\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>lptr</code> - \u8981\u89e3\u6790\u7684\u5b57\u7b26\u4e32</li> <li><code>set</code> - \u7528\u4e8e\u5b58\u50a8\u7ed3\u679c\u7684 Set \u5bf9\u8c61</li> <li><code>maxSZ</code> - \u6700\u5927\u5141\u8bb8\u503c</li> </ul> <p>\u8fd4\u56de\u503c: <code>true</code> \u5982\u679c\u89e3\u6790\u6210\u529f\uff0c\u5426\u5219 <code>false</code></p>"},{"location":"API_REFERENCE/#show_message_1","title":"show_message \u6a21\u5757","text":""},{"location":"API_REFERENCE/#messageprinterprintmessagetype-type-stdstring_view-fmt-args-args","title":"<code>MessagePrinter::print(MessageType type, std::string_view fmt, Args&amp;&amp;... args)</code>","text":"<p>\u6253\u5370\u683c\u5f0f\u5316\u7684\u6d88\u606f\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>type</code> - \u6d88\u606f\u7c7b\u578b</li> <li><code>fmt</code> - \u683c\u5f0f\u5b57\u7b26\u4e32</li> <li><code>args</code> - \u683c\u5f0f\u5316\u53c2\u6570</li> </ul>"},{"location":"API_REFERENCE/#messageprinterinfowarnerrordebuguserfmt-args","title":"<code>MessagePrinter::info/warn/error/debug/user(fmt, args...)</code>","text":"<p>\u4fbf\u6377\u65b9\u6cd5\uff0c\u7528\u4e8e\u6253\u5370\u7279\u5b9a\u7c7b\u578b\u7684\u6d88\u606f\u3002</p>"},{"location":"API_REFERENCE/#targetmem_1","title":"targetmem \u6a21\u5757","text":""},{"location":"API_REFERENCE/#matchesandoldvaluesswathaddelementvoid-addr-uint8_t-byte-matchflags-matchflags","title":"<code>MatchesAndOldValuesSwath::addElement(void* addr, uint8_t byte, MatchFlags matchFlags)</code>","text":"<p>\u5411 swath \u6dfb\u52a0\u65b0\u7684\u5185\u5b58\u5339\u914d\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>addr</code> - \u5185\u5b58\u5730\u5740</li> <li><code>byte</code> - \u5b57\u8282\u503c</li> <li><code>matchFlags</code> - \u5339\u914d\u6807\u5fd7</li> </ul>"},{"location":"API_REFERENCE/#matchesandoldvaluesswathtoprintablestringsize_t-idx-size_t-len","title":"<code>MatchesAndOldValuesSwath::toPrintableString(size_t idx, size_t len)</code>","text":"<p>\u5c06\u5185\u5b58\u5b57\u8282\u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u5b57\u7b26\u4e32\u3002</p> <p>\u53c2\u6570:</p> <ul> <li><code>idx</code> - \u8d77\u59cb\u7d22\u5f15</li> <li><code>len</code> - \u957f\u5ea6</li> </ul> <p>\u8fd4\u56de\u503c: \u53ef\u6253\u5370\u5b57\u7b26\u4e32</p>"},{"location":"API_REFERENCE/#matchesandoldvaluesarrayfindswathindexvoid-addr","title":"<code>MatchesAndOldValuesArray::findSwathIndex(void* addr)</code>","text":"<p>\u67e5\u627e\u5305\u542b\u6307\u5b9a\u5730\u5740\u7684 swath \u7d22\u5f15\u3002</p> <p>\u53c2\u6570: <code>addr</code> - \u5185\u5b58\u5730\u5740</p> <p>\u8fd4\u56de\u503c: \u5305\u542b\u8be5\u5730\u5740\u7684 swath \u7d22\u5f15\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de std::nullopt</p>"},{"location":"API_REFERENCE/#matchesandoldvaluesarraygetelementvoid-addr","title":"<code>MatchesAndOldValuesArray::getElement(void* addr)</code>","text":"<p>\u83b7\u53d6\u6307\u5b9a\u5730\u5740\u7684\u5143\u7d20\u6570\u636e\u3002</p> <p>\u53c2\u6570: <code>addr</code> - \u5185\u5b58\u5730\u5740</p> <p>\u8fd4\u56de\u503c: \u6307\u5411 OldValueAndMatchInfo \u7684\u6307\u9488\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de nullptr</p>"},{"location":"API_REFERENCE/#value_2","title":"value \u6a21\u5757","text":""},{"location":"API_REFERENCE/#valuezerovalue-val","title":"<code>Value::zero(Value&amp; val)</code>","text":"<p>\u5c06 Value \u5bf9\u8c61\u6e05\u96f6\u3002</p> <p>\u53c2\u6570: <code>val</code> - \u8981\u6e05\u96f6\u7684 Value \u5bf9\u8c61</p>"},{"location":"API_REFERENCE/#api_1","title":"API \u4f7f\u7528\u793a\u4f8b","text":""},{"location":"API_REFERENCE/#_11","title":"\u57fa\u672c\u7528\u6cd5","text":"<pre><code>import endianness;\nimport process_checker;\nimport sets;\nimport show_message;\nimport targetmem;\nimport value;\n\n// \u68c0\u67e5\u5b57\u8282\u5e8f\nif (endianness::is_little_endian()) {\n    std::cout &lt;&lt; \"\u7cfb\u7edf\u4e3a\u5c0f\u7aef\u5e8f\" &lt;&lt; std::endl;\n}\n\n// \u68c0\u67e5\u8fdb\u7a0b\u72b6\u6001\npid_t pid = 1234;\nProcessState state = ProcessChecker::check_process(pid);\nif (state == ProcessState::RUNNING) {\n    std::cout &lt;&lt; \"\u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\" &lt;&lt; std::endl;\n}\n\n// \u89e3\u6790\u96c6\u5408\nSet mySet;\nparse_uintset(\"1,2,3,4,5\", mySet, 100);\n\n// \u521b\u5efa\u6d88\u606f\u6253\u5370\u673a\nMessageContext ctx;\nctx.debugMode = true;\nMessagePrinter printer(ctx);\nprinter.info(\"\u5f00\u59cb\u5904\u7406\");\n\n// \u521b\u5efa\u5185\u5b58\u5339\u914d\u6570\u7ec4\nMatchesAndOldValuesArray matches;\n\n// \u521b\u5efa\u503c\u5bf9\u8c61\nValue searchValue;\nsearchValue.value = static_cast&lt;int32_t&gt;(42);\nsearchValue.flags = MatchFlags::S32B;\n</code></pre>"},{"location":"API_REFERENCE/#_12","title":"\u9ad8\u7ea7\u7528\u6cd5","text":"<pre><code>// \u5b57\u8282\u5e8f\u8f6c\u6362\nuint32_t value = 0x12345678;\nuint32_t swapped = endianness::swap_bytes(value);\n\n// \u8fdb\u7a0b\u76d1\u63a7\u5faa\u73af\nwhile (true) {\n    if (ProcessChecker::is_process_dead(targetPid)) {\n        std::cout &lt;&lt; \"\u76ee\u6807\u8fdb\u7a0b\u5df2\u7ec8\u6b62\" &lt;&lt; std::endl;\n        break;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n}\n\n// \u590d\u6742\u96c6\u5408\u89e3\u6790\nSet complexSet;\nparse_uintset(\"1,5,10..15,0x20\", complexSet, 1000);\n\n// \u683c\u5f0f\u5316\u6d88\u606f\nprinter.info(\"\u627e\u5230 {} \u4e2a\u5339\u914d\u9879\", matchCount);\nprinter.warn(\"\u5185\u5b58\u4f7f\u7528\u7387: {:.2f}%\", memoryUsage);\nprinter.error(\"\u5728\u5730\u5740 0x{:08x} \u5904\u8bfb\u53d6\u5931\u8d25\", address);\n\n// \u5185\u5b58\u5339\u914d\u64cd\u4f5c\nvoid* targetAddr = (void*)0x1000;\nauto swathIndex = matches.findSwathIndex(targetAddr);\nif (swathIndex) {\n    const auto* element = matches.getElement(targetAddr);\n    if (element) {\n        std::cout &lt;&lt; \"\u65e7\u503c: 0x\" &lt;&lt; std::hex &lt;&lt; (int)element-&gt;old_value &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"NamingConvention/","title":"C++ \u547d\u540d\u89c4\u8303","text":""},{"location":"NamingConvention/#1","title":"1. \u7c7b\u548c\u7ed3\u6784\u4f53","text":"<ul> <li>\u7c7b\u540d\uff1a\u4f7f\u7528 <code>CamelCase</code> \u98ce\u683c\u3002</li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp class MyClassName {};</code></p> </li> <li> <p>\u7ed3\u6784\u4f53\u540d\uff1a\u4f7f\u7528 <code>CamelCase</code> \u98ce\u683c\u3002</p> </li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp struct MyStructName {};</code></p> </li> </ul>"},{"location":"NamingConvention/#2","title":"2. \u679a\u4e3e","text":"<ul> <li>\u679a\u4e3e\u7c7b\u578b\u540d\uff1a\u4f7f\u7528 <code>CamelCase</code> \u98ce\u683c\u3002</li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp enum MyEnumType {};</code></p> </li> <li> <p>\u679a\u4e3e\u5e38\u91cf\u540d\uff1a\u4f7f\u7528 <code>UPPER_CASE</code> \u98ce\u683c\u3002</p> </li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp enum MyEnumType {     ENUM_CONSTANT_ONE,     ENUM_CONSTANT_TWO };</code></p> </li> </ul>"},{"location":"NamingConvention/#3","title":"3. \u51fd\u6570","text":"<ul> <li>\u51fd\u6570\u540d\uff1a\u4f7f\u7528 <code>camelBack</code> \u98ce\u683c\u3002</li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp void myFunctionName();</code></p> </li> </ul>"},{"location":"NamingConvention/#4","title":"4. \u53d8\u91cf","text":"<ul> <li>\u666e\u901a\u53d8\u91cf\u540d\uff1a\u4f7f\u7528 <code>camelBack</code> \u98ce\u683c\u3002</li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp int myVariableName;</code></p> </li> <li> <p>\u5168\u5c40\u53d8\u91cf\u540d\uff1a\u4f7f\u7528 <code>UPPER_CASE</code> \u98ce\u683c\u3002</p> </li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp int GLOBAL_VARIABLE_NAME;</code></p> </li> <li> <p>\u5e38\u91cf\u540d\uff1a\u4f7f\u7528 <code>UPPER_CASE</code> \u98ce\u683c\u3002</p> </li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp const int MAX_BUFFER_SIZE = 1024;</code></p> </li> </ul>"},{"location":"NamingConvention/#5","title":"5. \u53c2\u6570","text":"<ul> <li>\u51fd\u6570\u53c2\u6570\u540d\uff1a\u4f7f\u7528 <code>camelBack</code> \u98ce\u683c\u3002</li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp void myFunction(int parameterName);</code></p> </li> </ul>"},{"location":"NamingConvention/#6","title":"6. \u547d\u540d\u7a7a\u95f4","text":"<ul> <li>\u547d\u540d\u7a7a\u95f4\u540d\uff1a\u4f7f\u7528 <code>lower_case</code> \u98ce\u683c\u3002</li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp namespace my_namespace {     void myFunction(); }</code></p> </li> </ul>"},{"location":"NamingConvention/#7","title":"7. \u5b8f","text":"<ul> <li>\u5b8f\u5b9a\u4e49\u540d\uff1a\u4f7f\u7528 <code>UPPER_CASE</code> \u98ce\u683c\u3002</li> <li> <p>\u793a\u4f8b\uff1a</p> <p>```cpp</p> </li> </ul>"},{"location":"NamingConvention/#define-max_buffer_size-1024","title":"define MAX_BUFFER_SIZE 1024","text":"<p>```</p>"},{"location":"NamingConvention/#8","title":"8. \u6210\u5458\u53d8\u91cf","text":"<ul> <li>\u79c1\u6709\u6210\u5458\u53d8\u91cf\uff1a\u4ee5 <code>m_</code> \u4e3a\u524d\u7f00\uff0c\u4f7f\u7528 <code>camelBack</code> \u98ce\u683c\u3002</li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp class MyClass { private:     int m_privateMember; };</code></p> </li> <li> <p>\u53d7\u4fdd\u62a4\u6210\u5458\u53d8\u91cf\uff1a\u4ee5 <code>m_</code> \u4e3a\u524d\u7f00\uff0c\u4f7f\u7528 <code>camelBack</code> \u98ce\u683c\u3002</p> </li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp class MyClass { protected:     int m_protectedMember; };</code></p> </li> <li> <p>\u9759\u6001\u6210\u5458\u53d8\u91cf\uff1a\u4ee5 <code>s_</code> \u4e3a\u524d\u7f00\uff0c\u4f7f\u7528 <code>camelBack</code> \u98ce\u683c\u3002</p> </li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp class MyClass { private:     static int s_staticMember; };</code></p> </li> <li> <p>\u516c\u5171\u6210\u5458\u53d8\u91cf\uff1a\u4f7f\u7528 <code>camelBack</code> \u98ce\u683c\u3002</p> </li> <li> <p>\u793a\u4f8b\uff1a</p> <p><code>cpp class MyClass { public:     int publicMemberVariable; };</code></p> </li> </ul>"},{"location":"NamingConvention/#9","title":"9. \u7279\u6b8a\u89c4\u5219","text":"<ul> <li>\u7981\u7528\u7684\u89c4\u5219\uff1a</li> <li>\u7981\u7528 <code>modernize-use-trailing-return-type</code>\u3002</li> <li>\u7981\u7528 <code>modernize-avoid-c-arrays</code>\u3002</li> </ul>"},{"location":"endianness/","title":"\u5b57\u8282\u5e8f\u6a21\u5757\u6587\u6863","text":""},{"location":"endianness/#_2","title":"\u6982\u8ff0","text":"<p><code>endianness</code> \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5168\u9762\u7684\u5b57\u8282\u5e8f\u5904\u7406\u5de5\u5177\u3002\u5b83\u652f\u6301\u7f16\u8bd1\u65f6\u548c\u8fd0\u884c\u65f6\u5b57\u8282\u5e8f\u68c0\u6d4b\u3001\u5b57\u8282\u4ea4\u6362\u64cd\u4f5c\uff0c\u4ee5\u53ca\u5404\u79cd\u6570\u636e\u7c7b\u578b\u7684\u81ea\u52a8\u5b57\u8282\u5e8f\u6821\u6b63\u3002</p>"},{"location":"endianness/#_3","title":"\u6a21\u5757\u7ed3\u6784","text":"<pre><code>export module endianness;\n</code></pre>"},{"location":"endianness/#_4","title":"\u4f9d\u8d56\u9879","text":"<ul> <li><code>&lt;cstdint&gt;</code> - \u5b9a\u5bbd\u6574\u6570\u7c7b\u578b</li> <li><code>&lt;cstring&gt;</code> - C\u5b57\u7b26\u4e32\u64cd\u4f5c</li> <li><code>&lt;bit&gt;</code> - \u4f4d\u64cd\u4f5c\u548c\u5b57\u8282\u5e8f\u68c0\u6d4b</li> <li><code>&lt;type_traits&gt;</code> - \u6a21\u677f\u5143\u7f16\u7a0b\u7684\u7c7b\u578b\u7279\u5f81</li> <li><code>&lt;concepts&gt;</code> - C++20\u6982\u5ff5</li> <li><code>value</code> \u6a21\u5757 - \u503c\u7c7b\u578b\u5b9a\u4e49</li> </ul>"},{"location":"endianness/#_5","title":"\u6838\u5fc3\u529f\u80fd","text":""},{"location":"endianness/#1","title":"1. \u5b57\u8282\u5e8f\u68c0\u6d4b","text":""},{"location":"endianness/#_6","title":"\u7f16\u8bd1\u65f6\u68c0\u6d4b","text":"<pre><code>constexpr bool isBigEndian() noexcept;\nconstexpr bool isLittleEndian() noexcept;\n</code></pre> <p>\u4f7f\u7528 <code>std::endian::native</code> \u5728\u7f16\u8bd1\u65f6\u786e\u5b9a\u4e3b\u673a\u5b57\u8282\u5e8f\u3002</p>"},{"location":"endianness/#2","title":"2. \u5b57\u8282\u4ea4\u6362\u51fd\u6570","text":""},{"location":"endianness/#_7","title":"\u57fa\u672c\u5b57\u8282\u4ea4\u6362\u51fd\u6570","text":"<pre><code>constexpr uint8_t swapBytes(uint8_t value) noexcept;\nconstexpr uint16_t swapBytes(uint16_t value) noexcept;\nconstexpr uint32_t swapBytes(uint32_t value) noexcept;\nconstexpr uint64_t swapBytes(uint64_t value) noexcept;\n</code></pre>"},{"location":"endianness/#_8","title":"\u901a\u7528\u5b57\u8282\u4ea4\u6362\u51fd\u6570","text":"<pre><code>template&lt;typename T&gt;\nconstexpr T swapBytesIntegral(T value) noexcept;\n</code></pre> <p>\u652f\u6301\u5927\u5c0f\u4e3a1\u30012\u30014\u548c8\u5b57\u8282\u7684\u6574\u6570\u7c7b\u578b\u3002</p>"},{"location":"endianness/#3","title":"3. \u503c\u7c7b\u578b\u5b57\u8282\u5e8f\u6821\u6b63\u51fd\u6570","text":"<pre><code>void fixEndianness(Value&amp; value, bool reverseEndianness) noexcept;\n</code></pre> <p>\u5bf9 <code>Value</code> \u7684 <code>bytes</code> \u8fdb\u884c\u5c31\u5730\u5b57\u8282\u5e8f\u6821\u6b63\uff08\u6839\u636e <code>flags</code> \u63a8\u65ad\u5bbd\u5ea6 2/4/8\uff09\u3002</p>"},{"location":"endianness/#4","title":"4. \u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u6362\u51fd\u6570","text":"<pre><code>template&lt;SwappableIntegral T&gt;\nconstexpr T hostToNetwork(T value) noexcept;\n\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T networkToHost(T value) noexcept;\n</code></pre> <p>\u5728\u4e3b\u673a\u548c\u7f51\u7edc\u5b57\u8282\u5e8f\uff08\u5927\u7aef\uff09\u4e4b\u95f4\u8f6c\u6362\u3002</p>"},{"location":"endianness/#5","title":"5. \u5c0f\u7aef\u8f6c\u6362\u51fd\u6570","text":"<pre><code>template&lt;SwappableIntegral T&gt;\nconstexpr T hostToLittleEndian(T value) noexcept;\n\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T littleEndianToHost(T value) noexcept;\n</code></pre>"},{"location":"endianness/#_9","title":"\u4f7f\u7528\u793a\u4f8b","text":""},{"location":"endianness/#_10","title":"\u57fa\u672c\u5b57\u8282\u4ea4\u6362","text":"<pre><code>import endianness;\n\nuint32_t value = 0x12345678;\nuint32_t swapped = endianness::swapBytes(value);\n// \u5728\u5c0f\u7aef\u7cfb\u7edf\u4e0a swapped = 0x78563412\n</code></pre>"},{"location":"endianness/#_11","title":"\u5b57\u8282\u5e8f\u6821\u6b63","text":"<pre><code>import endianness;\nimport value;\n\nValue val = uint32_t{0x12345678};\nendianness::fixEndianness(val, true);  // \u53cd\u8f6c\u5b57\u8282\u5e8f\n</code></pre>"},{"location":"endianness/#_12","title":"\u7f51\u7edc\u901a\u4fe1","text":"<pre><code>uint16_t port = 8080;\nuint16_t networkPort = endianness::hostToNetwork(port);\n</code></pre>"},{"location":"endianness/#_13","title":"\u6982\u5ff5\u548c\u7ea6\u675f","text":""},{"location":"endianness/#swappableintegral","title":"SwappableIntegral \u6982\u5ff5","text":"<pre><code>template&lt;typename T&gt;\nconcept SwappableIntegral = std::integral&lt;T&gt; &amp;&amp; \n    (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8);\n</code></pre> <p>\u5c06\u5b57\u8282\u4ea4\u6362\u64cd\u4f5c\u9650\u5236\u4e3a\u7279\u5b9a\u5927\u5c0f\u7684\u6574\u6570\u7c7b\u578b\u3002</p>"},{"location":"endianness/#_14","title":"\u5b9e\u73b0\u7ec6\u8282","text":""},{"location":"endianness/#_15","title":"\u5b57\u8282\u4ea4\u6362\u7b97\u6cd5","text":"<ul> <li>16\u4f4d\uff1a\u4f7f\u7528\u4f4d\u65cb\u8f6c\uff1a<code>(value &lt;&lt; 8) | (value &gt;&gt; 8)</code></li> <li>32\u4f4d\uff1a\u4f7f\u7528\u4f4d\u63a9\u7801\u548c\u79fb\u4f4d\u4ee5\u83b7\u5f97\u6700\u4f73\u6027\u80fd</li> <li>64\u4f4d\uff1a\u8de88\u5b57\u8282\u4f7f\u7528\u4f4d\u63a9\u7801\u548c\u79fb\u4f4d</li> </ul>"},{"location":"endianness/#_16","title":"\u7f16\u8bd1\u65f6\u4f18\u5316","text":"<p>\u6240\u6709\u5b57\u8282\u4ea4\u6362\u64cd\u4f5c\u90fd\u6807\u8bb0\u4e3a <code>constexpr</code>\uff0c\u4ee5\u4fbf\u5728\u53ef\u80fd\u7684\u60c5\u51b5\u4e0b\u8fdb\u884c\u7f16\u8bd1\u65f6\u6c42\u503c\u3002</p>"},{"location":"endianness/#_17","title":"\u7c7b\u578b\u5b89\u5168","text":"<p>\u4f7f\u7528C++20\u6982\u5ff5\u786e\u4fdd\u7c7b\u578b\u5b89\u5168\uff0c\u5e76\u4e3a\u4e0d\u652f\u6301\u7684\u7c7b\u578b\u63d0\u4f9b\u6e05\u6670\u7684\u9519\u8bef\u6d88\u606f\u3002</p>"},{"location":"endianness/#_18","title":"\u9519\u8bef\u5904\u7406","text":"<ul> <li><code>swapBytesIntegral</code> \u4f7f\u7528 <code>static_assert</code> \u8fdb\u884c\u7f16\u8bd1\u65f6\u7c7b\u578b\u68c0\u67e5</li> <li><code>swapBytesInPlace</code> \u9759\u9ed8\u5ffd\u7565\u4e0d\u652f\u6301\u7684\u5c3a\u5bf8</li> <li><code>fixEndianness</code> \u6309 <code>flags</code> \u63a8\u65ad\u5bbd\u5ea6\uff08B16/B32/B64\uff09\u5bf9 <code>Value.bytes</code> \u539f\u5730\u4ea4\u6362</li> </ul>"},{"location":"endianness/#_19","title":"\u6027\u80fd\u8003\u8651","text":"<ul> <li>\u6240\u6709\u64cd\u4f5c\u90fd\u662f constexpr \u7528\u4e8e\u7f16\u8bd1\u65f6\u4f18\u5316</li> <li>\u5b57\u8282\u4ea4\u6362\u4f7f\u7528\u9ad8\u6548\u7684\u4f4d\u64cd\u4f5c</li> <li>\u65e0\u52a8\u6001\u5185\u5b58\u5206\u914d</li> <li>\u5bf9\u652f\u6301\u7c7b\u578b\u7684\u6700\u5c0f\u8fd0\u884c\u65f6\u5f00\u9500</li> </ul>"},{"location":"endianness/#_20","title":"\u53c2\u89c1","text":"<ul> <li>\u503c\u7c7b\u578b\u6a21\u5757 - \u503c\u7c7b\u578b\u5b9a\u4e49</li> <li>\u76ee\u6807\u5185\u5b58\u6a21\u5757 - \u5185\u5b58\u5206\u6790\u64cd\u4f5c</li> </ul>"},{"location":"endianness/#cli","title":"\u4e0e CLI \u7684\u96c6\u6210","text":"<p><code>endianness</code> \u6a21\u5757\u5728 CLI \u4e2d\u7528\u4e8e\u5185\u5b58\u626b\u63cf\u64cd\u4f5c\u671f\u95f4\u7684\u81ea\u52a8\u5b57\u8282\u5e8f\u5904\u7406\u3002\u4f8b\u5982\uff0c<code>scan</code> \u547d\u4ee4\u5229\u7528\u6b64\u6a21\u5757\u786e\u4fdd\u76ee\u6807\u503c\u7684\u5b57\u8282\u5e8f\u6b63\u786e\u3002</p>"},{"location":"main/","title":"\u4e3b\u5e94\u7528\u6587\u6863","text":""},{"location":"main/#_2","title":"\u6982\u8ff0","text":"<p><code>main.cpp</code> \u6587\u4ef6\u4f5c\u4e3a NewScanmem \u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\u5b83\u6f14\u793a\u4e86\u57fa\u672c\u7684\u6a21\u5757\u96c6\u6210\uff0c\u5e76\u4e3a\u5185\u5b58\u626b\u63cf\u5de5\u5177\u63d0\u4f9b\u4e86\u57fa\u7840\u6846\u67b6\u3002</p>"},{"location":"main/#_3","title":"\u6587\u4ef6\u7ed3\u6784","text":"<pre><code>import sets;\n\nint main() {\n    Set val;\n    return 0;\n}\n</code></pre>"},{"location":"main/#_4","title":"\u5f53\u524d\u5b9e\u73b0","text":"<p>\u5f53\u524d\u7684\u4e3b\u51fd\u6570\u662f\u6700\u5c0f\u5316\u7684\uff0c\u4f5c\u4e3a\u4ee5\u4e0b\u529f\u80fd\u7684\u5360\u4f4d\u7b26\uff1a</p> <ol> <li>\u6a21\u5757\u96c6\u6210\u6d4b\u8bd5: \u6f14\u793a <code>sets</code> \u6a21\u5757\u53ef\u4ee5\u6210\u529f\u5bfc\u5165\u548c\u4f7f\u7528</li> <li>\u57fa\u672c\u6846\u67b6: \u4e3a\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u63d0\u4f9b\u8d77\u70b9</li> <li>\u7f16\u8bd1\u9a8c\u8bc1: \u786e\u4fdd\u6240\u6709\u6a21\u5757\u80fd\u591f\u6b63\u786e\u7f16\u8bd1\u5728\u4e00\u8d77</li> </ol>"},{"location":"main/#_5","title":"\u8ba1\u5212\u529f\u80fd","text":""},{"location":"main/#_6","title":"\u547d\u4ee4\u884c\u754c\u9762","text":"<pre><code>// \u672a\u6765\u5b9e\u73b0\nint main(int argc, char* argv[]) {\n    // \u89e3\u6790\u547d\u4ee4\u884c\u53c2\u6570\n    // \u521d\u59cb\u5316\u6a21\u5757\n    // \u5f00\u59cb\u5185\u5b58\u626b\u63cf\n    // \u663e\u793a\u7ed3\u679c\n}\n</code></pre>"},{"location":"main/#_7","title":"\u96c6\u6210\u70b9","text":"<p>\u4e3b\u5e94\u7528\u7a0b\u5e8f\u5c06\u96c6\u6210\u6240\u6709\u6a21\u5757\uff1a</p> <ol> <li>\u8fdb\u7a0b\u7ba1\u7406 (process_checker)</li> <li>\u76ee\u6807\u8fdb\u7a0b\u9009\u62e9</li> <li>\u8fdb\u7a0b\u72b6\u6001\u76d1\u63a7</li> <li> <p>\u6743\u9650\u68c0\u67e5</p> </li> <li> <p>\u5185\u5b58\u5206\u6790 (targetmem)</p> </li> <li>\u5185\u5b58\u533a\u57df\u626b\u63cf</li> <li>\u503c\u5339\u914d</li> <li> <p>\u6a21\u5f0f\u68c0\u6d4b</p> </li> <li> <p>\u6570\u636e\u7c7b\u578b (value)</p> </li> <li>\u591a\u7c7b\u578b\u503c\u652f\u6301</li> <li>\u5b57\u8282\u5e8f\u5904\u7406</li> <li> <p>\u5b57\u8282\u6570\u7ec4\u64cd\u4f5c</p> </li> <li> <p>\u5b9e\u7528\u5de5\u5177 (sets, endianness, show_message)</p> </li> <li>\u7ed3\u679c\u96c6\u5408\u64cd\u4f5c</li> <li>\u5b57\u8282\u5e8f\u8f6c\u6362</li> <li>\u7528\u6237\u6d88\u606f\u548c\u65e5\u5fd7</li> </ol>"},{"location":"main/#_8","title":"\u4f7f\u7528\u793a\u4f8b","text":""},{"location":"main/#_9","title":"\u57fa\u672c\u6267\u884c","text":"<pre><code># \u5f53\u524d\u7528\u6cd5\n./newscanmem\n\n# \u672a\u6765\u7528\u6cd5\u793a\u4f8b\n./newscanmem --pid 1234 --type int32 --value 42\n./newscanmem --pid 1234 --range 0x1000-0x2000 --string \"hello\"\n./newscanmem --pid 1234 --float --tolerance 0.001\n</code></pre>"},{"location":"main/#_10","title":"\u5f00\u53d1\u8def\u7ebf\u56fe","text":""},{"location":"main/#_11","title":"\u7b2c\u4e00\u9636\u6bb5\uff1a\u57fa\u672c\u6846\u67b6","text":"<ul> <li>[ ] \u547d\u4ee4\u884c\u53c2\u6570\u89e3\u6790</li> <li>[ ] \u8fdb\u7a0b\u9009\u62e9\u548c\u9a8c\u8bc1</li> <li>[ ] \u57fa\u672c\u5185\u5b58\u626b\u63cf</li> <li>[ ] \u7ed3\u679c\u663e\u793a</li> </ul>"},{"location":"main/#_12","title":"\u7b2c\u4e8c\u9636\u6bb5\uff1a\u9ad8\u7ea7\u529f\u80fd","text":"<ul> <li>[ ] \u591a\u503c\u7c7b\u578b\u652f\u6301</li> <li>[ ] \u5185\u5b58\u533a\u57df\u8fc7\u6ee4</li> <li>[ ] \u6a21\u5f0f\u5339\u914d</li> <li>[ ] \u4ea4\u4e92\u6a21\u5f0f</li> </ul>"},{"location":"main/#_13","title":"\u7b2c\u4e09\u9636\u6bb5\uff1a\u4f18\u5316","text":"<ul> <li>[ ] \u6027\u80fd\u8c03\u4f18</li> <li>[ ] \u5185\u5b58\u4f7f\u7528\u4f18\u5316</li> <li>[ ] \u5e76\u884c\u5904\u7406</li> <li>[ ] \u7ed3\u679c\u7f13\u5b58</li> </ul>"},{"location":"main/#_14","title":"\u7b2c\u56db\u9636\u6bb5\uff1a\u7528\u6237\u754c\u9762/\u7528\u6237\u4f53\u9a8c","text":"<ul> <li>[ ] \u8fdb\u5ea6\u6307\u793a\u5668</li> <li>[ ] \u5f69\u8272\u8f93\u51fa</li> <li>[ ] \u4ea4\u4e92\u5f0f\u754c\u9762</li> <li>[ ] \u914d\u7f6e\u6587\u4ef6\u652f\u6301</li> </ul>"},{"location":"main/#_15","title":"\u6a21\u5757\u96c6\u6210","text":""},{"location":"main/#_16","title":"\u8fdb\u7a0b\u68c0\u67e5\u5668\u96c6\u6210","text":"<pre><code>import process_checker;\n\n// \u68c0\u67e5\u76ee\u6807\u8fdb\u7a0b\u72b6\u6001\npid_t targetPid = 1234;\nProcessState state = ProcessChecker::check_process(targetPid);\n\nif (state == ProcessState::RUNNING) {\n    std::cout &lt;&lt; \"\u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"\u8fdb\u7a0b\u672a\u8fd0\u884c\u6216\u65e0\u6cd5\u8bbf\u95ee\" &lt;&lt; std::endl;\n    return 1;\n}\n</code></pre>"},{"location":"main/#_17","title":"\u5185\u5b58\u626b\u63cf\u96c6\u6210","text":"<pre><code>import targetmem;\n\n// \u521b\u5efa\u5185\u5b58\u5339\u914d\u6570\u7ec4\nMatchesAndOldValuesArray matches;\n\n// \u6267\u884c\u5185\u5b58\u626b\u63cf\n// ... \u626b\u63cf\u903b\u8f91 ...\n\n// \u663e\u793a\u7ed3\u679c\nfor (const auto&amp; swath : matches.swaths) {\n    std::cout &lt;&lt; \"\u627e\u5230\u5339\u914d\u7684\u5185\u5b58\u533a\u57df\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"main/#_18","title":"\u503c\u7c7b\u578b\u5904\u7406","text":"<pre><code>import value;\n\n// \u521b\u5efa\u641c\u7d22\u503c\nValue searchValue;\nsearchValue.setScalarTyped&lt;int32_t&gt;(42);\nsearchValue.flags = MatchFlags::S32B;\n\n// \u6267\u884c\u503c\u5339\u914d\n// ... \u5339\u914d\u903b\u8f91 ...\n</code></pre>"},{"location":"main/#_19","title":"\u6d88\u606f\u7cfb\u7edf\u96c6\u6210","text":"<pre><code>import show_message;\n\n// \u521b\u5efa\u6d88\u606f\u6253\u5370\u673a\nMessageContext ctx;\nctx.debugMode = true;\nMessagePrinter printer(ctx);\n\nprinter.info(\"\u5f00\u59cb\u5185\u5b58\u626b\u63cf\");\nprinter.debug(\"\u8c03\u8bd5\u4fe1\u606f: \u626b\u63cf\u53c2\u6570\");\nprinter.warn(\"\u8b66\u544a: \u5185\u5b58\u4f7f\u7528\u7387\u8f83\u9ad8\");\n</code></pre>"},{"location":"main/#_20","title":"\u547d\u4ee4\u884c\u53c2\u6570\u8bbe\u8ba1","text":""},{"location":"main/#_21","title":"\u57fa\u672c\u53c2\u6570","text":"<pre><code>struct CommandLineArgs {\n    pid_t targetPid = 0;           // \u76ee\u6807\u8fdb\u7a0b ID\n    std::string valueType = \"int32\"; // \u503c\u7c7b\u578b\n    std::string searchValue;       // \u641c\u7d22\u503c\n    std::string memoryRange;       // \u5185\u5b58\u8303\u56f4\n    bool debugMode = false;        // \u8c03\u8bd5\u6a21\u5f0f\n    bool verbose = false;          // \u8be6\u7ec6\u8f93\u51fa\n};\n</code></pre>"},{"location":"main/#_22","title":"\u53c2\u6570\u89e3\u6790","text":"<pre><code>// \u89e3\u6790\u547d\u4ee4\u884c\u53c2\u6570\nCommandLineArgs parseArgs(int argc, char* argv[]) {\n    CommandLineArgs args;\n\n    for (int i = 1; i &lt; argc; ++i) {\n        std::string arg = argv[i];\n\n        if (arg == \"--pid\" &amp;&amp; i + 1 &lt; argc) {\n            args.targetPid = std::stoi(argv[++i]);\n        } else if (arg == \"--type\" &amp;&amp; i + 1 &lt; argc) {\n            args.valueType = argv[++i];\n        } else if (arg == \"--value\" &amp;&amp; i + 1 &lt; argc) {\n            args.searchValue = argv[++i];\n        } else if (arg == \"--range\" &amp;&amp; i + 1 &lt; argc) {\n            args.memoryRange = argv[++i];\n        } else if (arg == \"--debug\") {\n            args.debugMode = true;\n        } else if (arg == \"--verbose\") {\n            args.verbose = true;\n        }\n    }\n\n    return args;\n}\n</code></pre>"},{"location":"main/#_23","title":"\u9519\u8bef\u5904\u7406","text":""},{"location":"main/#_24","title":"\u53c2\u6570\u9a8c\u8bc1","text":"<pre><code>bool validateArgs(const CommandLineArgs&amp; args) {\n    if (args.targetPid &lt;= 0) {\n        std::cerr &lt;&lt; \"\u9519\u8bef: \u65e0\u6548\u7684\u8fdb\u7a0b ID\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    if (args.searchValue.empty()) {\n        std::cerr &lt;&lt; \"\u9519\u8bef: \u672a\u6307\u5b9a\u641c\u7d22\u503c\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"main/#_25","title":"\u8fdb\u7a0b\u9a8c\u8bc1","text":"<pre><code>bool validateProcess(pid_t pid) {\n    ProcessState state = ProcessChecker::check_process(pid);\n\n    if (state == ProcessState::DEAD) {\n        std::cerr &lt;&lt; \"\u9519\u8bef: \u8fdb\u7a0b\u4e0d\u5b58\u5728\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    if (state == ProcessState::ERROR) {\n        std::cerr &lt;&lt; \"\u9519\u8bef: \u65e0\u6cd5\u8bbf\u95ee\u8fdb\u7a0b\" &lt;&lt; std::endl;\n        return false;\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"main/#_26","title":"\u6027\u80fd\u8003\u8651","text":""},{"location":"main/#_27","title":"\u5185\u5b58\u4f7f\u7528","text":"<ol> <li>\u6d41\u5f0f\u5904\u7406: \u907f\u514d\u4e00\u6b21\u6027\u52a0\u8f7d\u5927\u91cf\u6570\u636e</li> <li>\u5185\u5b58\u6620\u5c04: \u4f7f\u7528\u5185\u5b58\u6620\u5c04\u6587\u4ef6\u5904\u7406\u5927\u6587\u4ef6</li> <li>\u7f13\u5b58\u7b56\u7565: \u5b9e\u73b0\u667a\u80fd\u7f13\u5b58\u51cf\u5c11\u91cd\u590d\u8ba1\u7b97</li> </ol>"},{"location":"main/#_28","title":"\u5e76\u884c\u5904\u7406","text":"<pre><code>// \u5e76\u884c\u626b\u63cf\u591a\u4e2a\u5185\u5b58\u533a\u57df\nvoid parallelScan(const std::vector&lt;MemoryRegion&gt;&amp; regions) {\n    std::vector&lt;std::thread&gt; threads;\n\n    for (const auto&amp; region : regions) {\n        threads.emplace_back([region]() {\n            scanRegion(region);\n        });\n    }\n\n    for (auto&amp; thread : threads) {\n        thread.join();\n    }\n}\n</code></pre>"},{"location":"main/#_29","title":"\u8fdb\u5ea6\u62a5\u544a","text":"<pre><code>class ProgressReporter {\nprivate:\n    size_t m_total;\n    size_t m_current;\n    std::chrono::steady_clock::time_point m_start;\n\npublic:\n    ProgressReporter(size_t total) : m_total(total), m_current(0) {\n        m_start = std::chrono::steady_clock::now();\n    }\n\n    void update(size_t increment = 1) {\n        m_current += increment;\n\n        auto now = std::chrono::steady_clock::now();\n        auto elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - m_start);\n\n        float progress = static_cast&lt;float&gt;(m_current) / m_total * 100.0f;\n        std::cout &lt;&lt; \"\\r\u8fdb\u5ea6: \" &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) \n                  &lt;&lt; progress &lt;&lt; \"% (\" &lt;&lt; m_current &lt;&lt; \"/\" &lt;&lt; m_total &lt;&lt; \")\" \n                  &lt;&lt; std::flush;\n    }\n};\n</code></pre>"},{"location":"main/#_30","title":"\u914d\u7f6e\u7ba1\u7406","text":""},{"location":"main/#_31","title":"\u914d\u7f6e\u6587\u4ef6\u652f\u6301","text":"<pre><code>struct Config {\n    bool debugMode = false;\n    bool verbose = false;\n    size_t maxResults = 1000;\n    std::string logFile;\n    std::map&lt;std::string, std::string&gt; customSettings;\n};\n\nConfig loadConfig(const std::string&amp; configFile) {\n    Config config;\n    // \u4ece\u6587\u4ef6\u52a0\u8f7d\u914d\u7f6e\n    return config;\n}\n</code></pre>"},{"location":"main/#_32","title":"\u73af\u5883\u53d8\u91cf","text":"<pre><code>void loadEnvironmentConfig() {\n    if (const char* debug = std::getenv(\"NEWSCANMEM_DEBUG\")) {\n        if (std::string(debug) == \"1\") {\n            // \u542f\u7528\u8c03\u8bd5\u6a21\u5f0f\n        }\n    }\n}\n</code></pre>"},{"location":"main/#_33","title":"\u6d4b\u8bd5\u548c\u8c03\u8bd5","text":""},{"location":"main/#_34","title":"\u5355\u5143\u6d4b\u8bd5","text":"<pre><code>// \u6d4b\u8bd5\u6a21\u5757\u96c6\u6210\nvoid testModuleIntegration() {\n    // \u6d4b\u8bd5 sets \u6a21\u5757\n    Set testSet;\n    assert(testSet.size() == 0);\n\n    // \u6d4b\u8bd5 value \u6a21\u5757\n    Value testValue;\n    testValue.value = static_cast&lt;int32_t&gt;(42);\n    assert(std::holds_alternative&lt;int32_t&gt;(testValue.value));\n}\n</code></pre>"},{"location":"main/#_35","title":"\u8c03\u8bd5\u5de5\u5177","text":"<pre><code>class DebugHelper {\npublic:\n    static void dumpMemory(const void* addr, size_t size) {\n        const uint8_t* bytes = static_cast&lt;const uint8_t*&gt;(addr);\n\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (i % 16 == 0) {\n                std::cout &lt;&lt; std::endl &lt;&lt; std::hex &lt;&lt; std::setw(8) \n                          &lt;&lt; std::setfill('0') &lt;&lt; i &lt;&lt; \": \";\n            }\n            std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') \n                      &lt;&lt; static_cast&lt;int&gt;(bytes[i]) &lt;&lt; \" \";\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n};\n</code></pre>"},{"location":"main/#_36","title":"\u672a\u6765\u6269\u5c55","text":""},{"location":"main/#_37","title":"\u63d2\u4ef6\u7cfb\u7edf","text":"<pre><code>// \u63d2\u4ef6\u63a5\u53e3\nclass ScanPlugin {\npublic:\n    virtual bool initialize() = 0;\n    virtual bool scan(const MemoryRegion&amp; region) = 0;\n    virtual void cleanup() = 0;\n    virtual std::string getName() const = 0;\n};\n\n// \u63d2\u4ef6\u7ba1\u7406\u5668\nclass PluginManager {\nprivate:\n    std::vector&lt;std::unique_ptr&lt;ScanPlugin&gt;&gt; m_plugins;\n\npublic:\n    void registerPlugin(std::unique_ptr&lt;ScanPlugin&gt; plugin);\n    void runPlugins(const MemoryRegion&amp; region);\n};\n</code></pre>"},{"location":"main/#_38","title":"\u7f51\u7edc\u652f\u6301","text":"<pre><code>// \u8fdc\u7a0b\u626b\u63cf\u652f\u6301\nclass RemoteScanner {\npublic:\n    bool connect(const std::string&amp; host, int port);\n    bool scanRemoteProcess(pid_t pid);\n    std::vector&lt;MemoryMatch&gt; getResults();\n};\n</code></pre>"},{"location":"main/#gui","title":"GUI \u754c\u9762","text":"<pre><code>// \u56fe\u5f62\u7528\u6237\u754c\u9762\uff08\u672a\u6765\u8ba1\u5212\uff09\nclass MainWindow {\npublic:\n    void showProcessList();\n    void showScanResults();\n    void showMemoryMap();\n};\n</code></pre>"},{"location":"main/#cli-repl","title":"CLI \u548c REPL \u96c6\u6210","text":"<p>\u4e3b\u5e94\u7528\u7a0b\u5e8f\u73b0\u5df2\u96c6\u6210\u547d\u4ee4\u884c\u754c\u9762 (CLI) \u548c REPL \u5faa\u73af\u3002\u8fd9\u5141\u8bb8\u7528\u6237\u4ea4\u4e92\u5f0f\u5730\u6267\u884c\u5185\u5b58\u626b\u63cf\u548c\u5206\u6790\u547d\u4ee4\u3002<code>main.cpp</code> \u6587\u4ef6\u521d\u59cb\u5316 REPL \u5e76\u6ce8\u518c\u4e86 <code>help</code>\u3001<code>quit</code> \u548c <code>pid</code> \u7b49\u547d\u4ee4\u3002</p>"},{"location":"maps/","title":"Maps \u6a21\u5757\u6587\u6863","text":""},{"location":"maps/#_1","title":"\u6982\u8ff0","text":"<p>Maps \u6a21\u5757\u63d0\u4f9b\u8bfb\u53d6\u548c\u89e3\u6790 Linux <code>/proc/[pid]/maps</code> \u6587\u4ef6\u7684\u529f\u80fd\uff0c\u7528\u4e8e\u63d0\u53d6\u8fdb\u7a0b\u5185\u5b58\u533a\u57df\u4fe1\u606f\u3002\u8fd9\u662f\u4e00\u4e2a\u73b0\u4ee3\u5316\u7684 C++20 \u5b9e\u73b0\uff0c\u7528\u7c7b\u578b\u5b89\u5168\u3001\u7b26\u5408 RAII \u7684\u63a5\u53e3\u66ff\u4ee3\u4e86\u4f20\u7edf\u7684 C \u4ee3\u7801\u3002</p>"},{"location":"maps/#_2","title":"\u6a21\u5757\u7ed3\u6784","text":"<pre><code>import maps;\n</code></pre>"},{"location":"maps/#_3","title":"\u6838\u5fc3\u7ec4\u4ef6","text":""},{"location":"maps/#1","title":"1. \u533a\u57df\u7c7b\u578b","text":""},{"location":"maps/#region_type","title":"<code>region_type</code> \u679a\u4e3e","text":"<p>\u8868\u793a\u5185\u5b58\u533a\u57df\u7684\u5206\u7c7b\uff1a</p> <pre><code>enum class RegionType : uint8_t {\n    MISC,   // \u6742\u9879\u5185\u5b58\u533a\u57df\n    EXE,    // \u53ef\u6267\u884c\u6587\u4ef6\u4e8c\u8fdb\u5236\u533a\u57df\n    CODE,   // \u4ee3\u7801\u6bb5\uff08\u5171\u4eab\u5e93\u7b49\uff09\n    HEAP,   // \u5806\u5185\u5b58\u533a\u57df\n    STACK   // \u6808\u5185\u5b58\u533a\u57df\n};\n\nconstexpr std::array&lt;std::string_view, 5&gt; REGION_TYPE_NAMES = {\n    \"misc\", \"exe\", \"code\", \"heap\", \"stack\"\n};\n</code></pre>"},{"location":"maps/#2","title":"2. \u626b\u63cf\u7ea7\u522b","text":""},{"location":"maps/#regionscanlevel","title":"<code>RegionScanLevel</code> \u679a\u4e3e","text":"<p>\u63a7\u5236\u5305\u542b\u54ea\u4e9b\u5185\u5b58\u533a\u57df\u7684\u626b\u63cf\uff1a</p> <pre><code>enum class RegionScanLevel : uint8_t {\n    ALL,                       // \u6240\u6709\u53ef\u8bfb\u533a\u57df\n    ALL_RW,                    // \u6240\u6709\u53ef\u8bfb/\u53ef\u5199\u533a\u57df\n    HEAP_STACK_EXECUTABLE,     // \u5806\u3001\u6808\u548c\u53ef\u6267\u884c\u533a\u57df\n    HEAP_STACK_EXECUTABLE_BSS  // \u4e0a\u8ff0\u52a0\u4e0a BSS \u6bb5\n};\n</code></pre>"},{"location":"maps/#3","title":"3. \u533a\u57df\u5143\u6570\u636e","text":""},{"location":"maps/#regionflags","title":"<code>RegionFlags</code> \u7ed3\u6784","text":"<p>\u5305\u542b\u5185\u5b58\u533a\u57df\u7684\u6743\u9650\u548c\u72b6\u6001\u6807\u5fd7\uff1a</p> <pre><code>struct RegionFlags {\n    bool read : 1;    // \u8bfb\u6743\u9650\n    bool write : 1;   // \u5199\u6743\u9650\n    bool exec : 1;    // \u6267\u884c\u6743\u9650\n    bool shared : 1;  // \u5171\u4eab\u6620\u5c04\n    bool private_ : 1; // \u79c1\u6709\u6620\u5c04\n};\n</code></pre>"},{"location":"maps/#region","title":"<code>Region</code> \u7ed3\u6784","text":"<p>\u5173\u4e8e\u5185\u5b58\u533a\u57df\u7684\u5b8c\u6574\u4fe1\u606f\uff1a</p> <pre><code>struct Region {\n    void* start;           // \u8d77\u59cb\u5730\u5740\n    std::size_t size;      // \u533a\u57df\u5927\u5c0f\uff08\u5b57\u8282\uff09\n    RegionType type;       // \u533a\u57df\u5206\u7c7b\n    RegionFlags flags;     // \u6743\u9650\u6807\u5fd7\n    void* loadAddr;        // ELF \u6587\u4ef6\u7684\u52a0\u8f7d\u5730\u5740\n    std::string filename;  // \u5173\u8054\u6587\u4ef6\u8def\u5f84\n    std::size_t id;        // \u552f\u4e00\u6807\u8bc6\u7b26\n\n    // \u8f85\u52a9\u65b9\u6cd5\n    [[nodiscard]] bool isReadable() const noexcept;\n    [[nodiscard]] bool isWritable() const noexcept;\n    [[nodiscard]] bool isExecutable() const noexcept;\n    [[nodiscard]] bool isShared() const noexcept;\n    [[nodiscard]] bool isPrivate() const noexcept;\n\n    [[nodiscard]] std::pair&lt;void*, std::size_t&gt; asSpan() const noexcept;\n    [[nodiscard]] bool contains(void* address) const noexcept;\n};\n</code></pre>"},{"location":"maps/#_4","title":"\u4f7f\u7528\u793a\u4f8b","text":""},{"location":"maps/#_5","title":"\u57fa\u672c\u7528\u6cd5","text":"<pre><code>import maps;\n\n// \u8bfb\u53d6\u8fdb\u7a0b\u7684\u6240\u6709\u5185\u5b58\u533a\u57df\nauto result = maps::readProcessMaps(1234);\nif (result) {\n    for (const auto&amp; region : *result) {\n        std::cout &lt;&lt; std::format(\"\u533a\u57df: {}-{} ({})\\n\", \n                               region.start, \n                               static_cast&lt;char*&gt;(region.start) + region.size,\n                               REGION_TYPE_NAMES[static_cast&lt;size_t&gt;(region.type)]);\n    }\n}\n</code></pre>"},{"location":"maps/#_6","title":"\u8fc7\u6ee4\u626b\u63cf","text":"<pre><code>// \u53ea\u626b\u63cf\u5806\u548c\u6808\u533a\u57df\nauto regions = maps::readProcessMaps(\n    pid, \n    maps::RegionScanLevel::HEAP_STACK_EXECUTABLE\n);\n\nif (regions) {\n    for (const auto&amp; region : *regions) {\n        if (region.type == maps::region_type::heap) {\n            std::cout &lt;&lt; \"\u627e\u5230\u5806\u533a\u57df: \" &lt;&lt; region.filename &lt;&lt; \"\\n\";\n        }\n    }\n}\n</code></pre>"},{"location":"maps/#_7","title":"\u9519\u8bef\u5904\u7406","text":"<pre><code>auto result = maps::read_process_maps(pid);\nif (!result) {\n    std::cerr &lt;&lt; \"\u9519\u8bef: \" &lt;&lt; result.error().message &lt;&lt; \"\\n\";\n    return;\n}\n</code></pre>"},{"location":"maps/#maps_reader","title":"\u7c7b\uff1a<code>maps_reader</code>","text":""},{"location":"maps/#_8","title":"\u9759\u6001\u65b9\u6cd5","text":""},{"location":"maps/#read_process_maps","title":"<code>read_process_maps</code>","text":"<p>\u4ece\u8fdb\u7a0b\u8bfb\u53d6\u5185\u5b58\u533a\u57df\uff1a</p> <pre><code>[[nodiscard]] static std::expected&lt;std::vector&lt;region&gt;, error&gt; \nread_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);\n</code></pre> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>pid</code>: \u76ee\u6807\u8fdb\u7a0b ID</li> <li><code>level</code>: \u626b\u63cf\u7ea7\u522b\u8fc7\u6ee4\u5668\uff08\u9ed8\u8ba4\uff1a<code>all</code>\uff09</li> </ul> <p>\u8fd4\u56de\u503c\uff1a</p> <ul> <li><code>std::expected</code> \u5305\u542b\u533a\u57df\u5411\u91cf\u6216\u9519\u8bef\u4fe1\u606f</li> </ul> <p>\u9519\u8bef\u5904\u7406\uff1a</p> <ul> <li>\u8fd4\u56de <code>std::error_code</code> \u548c\u9002\u5f53\u7684\u9519\u8bef\u6d88\u606f</li> <li>\u5e38\u89c1\u9519\u8bef\uff1a\u6587\u4ef6\u672a\u627e\u5230\u3001\u6743\u9650\u88ab\u62d2\u7edd\u3001\u683c\u5f0f\u65e0\u6548</li> </ul>"},{"location":"maps/#_9","title":"\u9519\u8bef\u5904\u7406\u6a21\u5757","text":""},{"location":"maps/#maps_readererror","title":"<code>maps_reader::error</code> \u7ed3\u6784","text":"<pre><code>struct error {\n    std::string message;   // \u4eba\u7c7b\u53ef\u8bfb\u7684\u9519\u8bef\u63cf\u8ff0\n    std::error_code code;  // \u7cfb\u7edf\u9519\u8bef\u4ee3\u7801\n};\n</code></pre>"},{"location":"maps/#_10","title":"\u5e38\u89c1\u9519\u8bef\u573a\u666f","text":"<ol> <li>\u8fdb\u7a0b\u4e0d\u5b58\u5728\uff1a<code>no_such_file_or_directory</code></li> <li>\u6743\u9650\u88ab\u62d2\u7edd\uff1a<code>permission_denied</code></li> <li>\u683c\u5f0f\u65e0\u6548\uff1a<code>invalid_argument</code></li> </ol>"},{"location":"maps/#_11","title":"\u9ad8\u7ea7\u529f\u80fd","text":""},{"location":"maps/#_12","title":"\u533a\u57df\u5206\u6790","text":"<pre><code>// \u68c0\u67e5\u5730\u5740\u662f\u5426\u5728\u4efb\u610f\u533a\u57df\u5185\nauto regions = maps::read_process_maps(pid);\nvoid* address = /* \u67d0\u4e2a\u5730\u5740 */;\n\nfor (const auto&amp; region : *regions) {\n    if (region.contains(address)) {\n        std::cout &lt;&lt; \"\u5730\u5740\u5728: \" &lt;&lt; region.filename &lt;&lt; \"\u4e2d\u627e\u5230\\n\";\n        break;\n    }\n}\n</code></pre>"},{"location":"maps/#_13","title":"\u6743\u9650\u68c0\u67e5","text":"<pre><code>// \u67e5\u627e\u53ef\u5199\u53ef\u6267\u884c\u533a\u57df\uff08\u6f5c\u5728\u7684 shellcode \u76ee\u6807\uff09\nfor (const auto&amp; region : *regions) {\n    if (region.isWritable() &amp;&amp; region.isExecutable()) {\n        std::cout &lt;&lt; \"WX \u533a\u57df: \" &lt;&lt; region.filename &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>"},{"location":"maps/#_14","title":"\u6027\u80fd\u8bf4\u660e","text":"<ul> <li>\u5185\u5b58\u9ad8\u6548\uff1a\u5bf9\u5c0f\u6587\u4ef6\u540d\u4f7f\u7528\u5e26\u6709 SSO \u7684 <code>std::string</code></li> <li>\u96f6\u62f7\u8d1d\uff1a\u76f4\u63a5\u4ece\u6620\u5c04\u884c\u63d0\u53d6\u5b57\u7b26\u4e32</li> <li>\u63d0\u524d\u8fc7\u6ee4\uff1a\u6839\u636e\u626b\u63cf\u7ea7\u522b\u5728\u89e3\u6790\u671f\u95f4\u8fc7\u6ee4\u533a\u57df</li> <li>RAII\uff1a\u901a\u8fc7 <code>std::ifstream</code> \u81ea\u52a8\u6e05\u7406\u8d44\u6e90</li> </ul>"},{"location":"maps/#_15","title":"\u7ebf\u7a0b\u5b89\u5168","text":"<ul> <li>\u7ebf\u7a0b\u5b89\u5168\uff1a\u6240\u6709\u65b9\u6cd5\u5bf9\u5e76\u53d1\u8bbf\u95ee\u90fd\u662f\u7ebf\u7a0b\u5b89\u5168\u7684</li> <li>\u65e0\u5171\u4eab\u72b6\u6001\uff1a\u6bcf\u6b21\u8c03\u7528\u521b\u5efa\u72ec\u7acb\u72b6\u6001</li> <li>\u4e0d\u53ef\u53d8\u7ed3\u679c\uff1a\u8fd4\u56de\u7684\u5411\u91cf\u5305\u542b\u4e0d\u53ef\u53d8\u6570\u636e</li> </ul>"},{"location":"maps/#_16","title":"\u5e73\u53f0\u517c\u5bb9\u6027","text":"<ul> <li>\u4ec5 Linux\uff1a\u9700\u8981 <code>/proc/[pid]/maps</code> \u6587\u4ef6\u7cfb\u7edf</li> <li>\u9700\u8981 C++23\uff1a\u4f7f\u7528 <code>std::expected</code> \u548c\u5176\u4ed6 C++23 \u7279\u6027</li> <li>\u652f\u6301 64 \u4f4d\uff1a\u5904\u7406 32 \u4f4d\u548c 64 \u4f4d\u5730\u5740\u7a7a\u95f4</li> </ul>"},{"location":"maps/#c","title":"\u4ece\u4f20\u7edf C \u4ee3\u7801\u8fc1\u79fb","text":""},{"location":"maps/#c-c","title":"\u4f20\u7edf C \u2192 \u73b0\u4ee3 C++","text":"\u4f20\u7edf C \u73b0\u4ee3 C++ <code>region_t*</code> <code>maps::region</code> <code>list_t</code> <code>std::vector&lt;region&gt;</code> <code>bool return</code> <code>std::expected</code> <code>char*</code> \u6587\u4ef6\u540d <code>std::string</code> \u624b\u52a8\u5185\u5b58\u7ba1\u7406 RAII \u9519\u8bef\u4ee3\u7801 \u5f02\u5e38\u5b89\u5168\u7684\u9519\u8bef\u5904\u7406"},{"location":"maps/#_17","title":"\u793a\u4f8b","text":""},{"location":"maps/#_18","title":"\u5b8c\u6574\u5de5\u4f5c\u793a\u4f8b","text":"<pre><code>#include &lt;iostream&gt;\nimport maps;\n\nint main() {\n    pid_t target_pid = 1234; // \u66ff\u6362\u4e3a\u5b9e\u9645 PID\n\n    auto regions = maps::readProcessMaps(target_pid);\n    if (!regions) {\n        std::cerr &lt;&lt; \"\u8bfb\u53d6\u6620\u5c04\u5931\u8d25: \" &lt;&lt; regions.error().message &lt;&lt; \"\\n\";\n        return 1;\n    }\n\n    std::cout &lt;&lt; \"\u627e\u5230 \" &lt;&lt; regions-&gt;size() &lt;&lt; \" \u4e2a\u5185\u5b58\u533a\u57df:\\n\";\n\n    for (const auto&amp; region : *regions) {\n        std::cout &lt;&lt; std::format(\n            \"0x{:x}-0x{:x} {} {} {}\\n\",\n            reinterpret_cast&lt;uintptr_t&gt;(region.start),\n            reinterpret_cast&lt;uintptr_t&gt;(region.start) + region.size,\n            region.isReadable() ? 'r' : '-',\n            region.isWritable() ? 'w' : '-',\n            region.isExecutable() ? 'x' : '-',\n            region.filename.empty() ? \"[\u533f\u540d]\" : region.filename\n        );\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"maps/#cli","title":"\u4e0e CLI \u7684\u96c6\u6210","text":"<p><code>maps</code> \u6a21\u5757\u5728 CLI \u4e2d\u7528\u4e8e\u68c0\u7d22\u548c\u663e\u793a\u76ee\u6807\u8fdb\u7a0b\u7684\u5185\u5b58\u533a\u57df\u4fe1\u606f\u3002\u4f8b\u5982\uff0c<code>list</code> \u547d\u4ee4\u5229\u7528\u6b64\u6a21\u5757\u89e3\u6790\u5e76\u8f93\u51fa <code>/proc/[pid]/maps</code> \u6570\u636e\u3002</p>"},{"location":"process_checker/","title":"\u8fdb\u7a0b\u68c0\u67e5\u6a21\u5757\u6587\u6863","text":""},{"location":"process_checker/#_2","title":"\u6982\u8ff0","text":"<p><code>process_checker</code> \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u8fdb\u7a0b\u72b6\u6001\u76d1\u63a7\u548c\u68c0\u67e5\u529f\u80fd\u3002\u5b83\u901a\u8fc7\u68c0\u67e5 Linux <code>/proc</code> \u6587\u4ef6\u7cfb\u7edf\u6765\u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u6b63\u5728\u8fd0\u884c\u3001\u5df2\u6b7b\u4ea1\u6216\u5904\u4e8e\u50f5\u5c38\u72b6\u6001\u3002</p>"},{"location":"process_checker/#_3","title":"\u6a21\u5757\u7ed3\u6784","text":"<pre><code>export module process_checker;\n</code></pre>"},{"location":"process_checker/#_4","title":"\u4f9d\u8d56\u9879","text":"<ul> <li><code>&lt;unistd.h&gt;</code> - POSIX \u64cd\u4f5c\u7cfb\u7edf API</li> <li><code>&lt;filesystem&gt;</code> - C++17 \u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c</li> <li><code>&lt;fstream&gt;</code> - \u6587\u4ef6\u6d41\u64cd\u4f5c</li> <li><code>&lt;string&gt;</code> - \u5b57\u7b26\u4e32\u64cd\u4f5c</li> </ul>"},{"location":"process_checker/#_5","title":"\u6838\u5fc3\u529f\u80fd","text":""},{"location":"process_checker/#1","title":"1. \u8fdb\u7a0b\u72b6\u6001\u679a\u4e3e","text":"<pre><code>enum class ProcessState { \n    RUNNING,  // \u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\n    ERROR,    // \u68c0\u67e5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef\n    DEAD,     // \u8fdb\u7a0b\u4e0d\u5b58\u5728\n    ZOMBIE    // \u8fdb\u7a0b\u5904\u4e8e\u50f5\u5c38\u72b6\u6001\n};\n</code></pre>"},{"location":"process_checker/#2-processchecker","title":"2. ProcessChecker \u7c7b","text":""},{"location":"process_checker/#_6","title":"\u516c\u5171\u63a5\u53e3","text":"<pre><code>class ProcessChecker {\npublic:\n    static ProcessState checkProcess(pid_t pid);\n    static bool isProcessDead(pid_t pid);\n};\n</code></pre>"},{"location":"process_checker/#_7","title":"\u65b9\u6cd5","text":""},{"location":"process_checker/#checkprocesspid_t-pid","title":"checkProcess(pid_t pid)","text":"<p>\u68c0\u67e5\u6307\u5b9a PID \u7684\u8fdb\u7a0b\u72b6\u6001\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>pid</code>: \u8981\u68c0\u67e5\u7684\u8fdb\u7a0b ID</li> </ul> <p>\u8fd4\u56de\u503c\uff1a</p> <ul> <li><code>ProcessState::RUNNING</code>: \u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\uff08\u5305\u62ec\u7761\u7720\u3001\u7b49\u5f85\u3001\u505c\u6b62\u72b6\u6001\uff09</li> <li><code>ProcessState::ERROR</code>: \u68c0\u67e5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u9519\u8bef\uff08\u65e0\u6548 PID\u3001\u6587\u4ef6\u8bbf\u95ee\u95ee\u9898\uff09</li> <li><code>ProcessState::DEAD</code>: \u8fdb\u7a0b\u4e0d\u5b58\u5728\uff08/proc/[pid] \u76ee\u5f55\u7f3a\u5931\uff09</li> <li><code>ProcessState::ZOMBIE</code>: \u8fdb\u7a0b\u5904\u4e8e\u50f5\u5c38\u6216\u6b7b\u4ea1\u72b6\u6001</li> </ul>"},{"location":"process_checker/#isprocessdeadpid_t-pid","title":"isProcessDead(pid_t pid)","text":"<p>\u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u672a\u8fd0\u884c\u7684\u4fbf\u6377\u65b9\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>pid</code>: \u8981\u68c0\u67e5\u7684\u8fdb\u7a0b ID</li> </ul> <p>\u8fd4\u56de\u503c\uff1a</p> <ul> <li><code>true</code>: \u8fdb\u7a0b\u5df2\u6b7b\u4ea1\u3001\u50f5\u5c38\u72b6\u6001\u6216\u53d1\u751f\u9519\u8bef</li> <li><code>false</code>: \u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c</li> </ul>"},{"location":"process_checker/#_8","title":"\u5b9e\u73b0\u7ec6\u8282","text":""},{"location":"process_checker/#_9","title":"\u8fdb\u7a0b\u72b6\u6001\u68c0\u6d4b","text":"<p>\u6a21\u5757\u8bfb\u53d6 <code>/proc/[pid]/status</code> \u5e76\u68c0\u67e5 \"State:\" \u5b57\u6bb5\uff1a</p> <ul> <li>\u8fd0\u884c\u72b6\u6001: 'R' (\u8fd0\u884c\u4e2d), 'S' (\u7761\u7720), 'D' (\u7b49\u5f85), 'T' (\u505c\u6b62)</li> <li>\u50f5\u5c38\u72b6\u6001: 'Z' (\u50f5\u5c38), 'X' (\u6b7b\u4ea1)</li> <li>\u9519\u8bef\u5904\u7406: \u65e0\u6548\u72b6\u6001\u5b57\u7b26\u3001\u6587\u4ef6\u8bbf\u95ee\u9519\u8bef</li> </ul>"},{"location":"process_checker/#_10","title":"\u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c","text":"<ol> <li>\u9a8c\u8bc1: \u68c0\u67e5 PID \u662f\u5426\u4e3a\u6b63\u6570</li> <li>\u5b58\u5728\u6027: \u9a8c\u8bc1 <code>/proc/[pid]</code> \u76ee\u5f55\u662f\u5426\u5b58\u5728</li> <li>\u8bbf\u95ee: \u6253\u5f00 <code>/proc/[pid]/status</code> \u6587\u4ef6</li> <li>\u89e3\u6790: \u4ece\u6587\u4ef6\u5185\u5bb9\u4e2d\u8bfb\u53d6\u72b6\u6001\u4fe1\u606f</li> </ol>"},{"location":"process_checker/#_11","title":"\u4f7f\u7528\u793a\u4f8b","text":""},{"location":"process_checker/#_12","title":"\u57fa\u672c\u8fdb\u7a0b\u68c0\u67e5","text":"<pre><code>import process_checker;\n\npid_t pid = 1234;\nProcessState state = ProcessChecker::checkProcess(pid);\n</code></pre>"},{"location":"process_checker/#_13","title":"\u68c0\u67e5\u8fdb\u7a0b\u662f\u5426\u6b7b\u4ea1","text":"<pre><code>import process_checker;\n\npid_t pid = 1234;\nif (ProcessChecker::isProcessDead(pid)) {\n    std::cout &lt;&lt; \"\u8fdb\u7a0b \" &lt;&lt; pid &lt;&lt; \" \u5df2\u6b7b\u4ea1\u6216\u4e0d\u5b58\u5728\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"process_checker/#_14","title":"\u8be6\u7ec6\u72b6\u6001\u68c0\u67e5","text":"<pre><code>import process_checker;\n\npid_t pid = 1234;\nProcessState state = ProcessChecker::checkProcess(pid);\n\nswitch (state) {\n    case ProcessState::RUNNING:\n        std::cout &lt;&lt; \"\u8fdb\u7a0b\u6b63\u5728\u8fd0\u884c\" &lt;&lt; std::endl;\n        break;\n    case ProcessState::DEAD:\n        std::cout &lt;&lt; \"\u8fdb\u7a0b\u4e0d\u5b58\u5728\" &lt;&lt; std::endl;\n        break;\n    case ProcessState::ZOMBIE:\n        std::cout &lt;&lt; \"\u8fdb\u7a0b\u5904\u4e8e\u50f5\u5c38\u72b6\u6001\" &lt;&lt; std::endl;\n        break;\n    case ProcessState::ERROR:\n        std::cout &lt;&lt; \"\u68c0\u67e5\u8fdb\u7a0b\u65f6\u53d1\u751f\u9519\u8bef\" &lt;&lt; std::endl;\n        break;\n}\n</code></pre>"},{"location":"process_checker/#_15","title":"\u9519\u8bef\u5904\u7406","text":""},{"location":"process_checker/#_16","title":"\u5e38\u89c1\u9519\u8bef\u60c5\u51b5","text":"<ol> <li>\u65e0\u6548 PID: \u8d1f\u6570\u6216\u96f6\u503c PID</li> <li>\u6743\u9650\u4e0d\u8db3: \u65e0\u6cd5\u8bbf\u95ee <code>/proc/[pid]</code> \u76ee\u5f55</li> <li>\u6587\u4ef6\u7cfb\u7edf\u9519\u8bef: <code>/proc</code> \u6587\u4ef6\u7cfb\u7edf\u4e0d\u53ef\u7528</li> <li>\u8fdb\u7a0b\u4e0d\u5b58\u5728: \u6307\u5b9a\u7684 PID \u5bf9\u5e94\u7684\u8fdb\u7a0b\u4e0d\u5b58\u5728</li> </ol>"},{"location":"process_checker/#_17","title":"\u9519\u8bef\u5904\u7406\u7b56\u7565","text":"<ul> <li>\u8fd4\u56de <code>ProcessState::ERROR</code> \u800c\u4e0d\u662f\u629b\u51fa\u5f02\u5e38</li> <li>\u8bb0\u5f55\u8be6\u7ec6\u7684\u9519\u8bef\u4fe1\u606f\u7528\u4e8e\u8c03\u8bd5</li> <li>\u63d0\u4f9b\u4fbf\u6377\u65b9\u6cd5 <code>is_process_dead()</code> \u8fdb\u884c\u7b80\u5355\u68c0\u67e5</li> </ul>"},{"location":"process_checker/#_18","title":"\u6027\u80fd\u8003\u8651","text":""},{"location":"process_checker/#_19","title":"\u4f18\u5316\u7b56\u7565","text":"<ol> <li>\u6700\u5c0f\u5316\u6587\u4ef6 I/O: \u53ea\u8bfb\u53d6\u5fc5\u8981\u7684\u72b6\u6001\u4fe1\u606f</li> <li>\u7f13\u5b58\u673a\u5236: \u907f\u514d\u91cd\u590d\u68c0\u67e5\u540c\u4e00\u8fdb\u7a0b</li> <li>\u6279\u91cf\u68c0\u67e5: \u652f\u6301\u540c\u65f6\u68c0\u67e5\u591a\u4e2a\u8fdb\u7a0b</li> </ol>"},{"location":"process_checker/#_20","title":"\u8d44\u6e90\u4f7f\u7528","text":"<ul> <li>\u5185\u5b58\u4f7f\u7528: \u6700\u5c0f\u5316\u5185\u5b58\u5206\u914d</li> <li>\u6587\u4ef6\u63cf\u8ff0\u7b26: \u53ca\u65f6\u5173\u95ed\u6587\u4ef6\u53e5\u67c4</li> <li>CPU \u4f7f\u7528: \u9ad8\u6548\u7684\u5b57\u7b26\u4e32\u89e3\u6790</li> </ul>"},{"location":"process_checker/#_21","title":"\u7ebf\u7a0b\u5b89\u5168","text":""},{"location":"process_checker/#_22","title":"\u5e76\u53d1\u8bbf\u95ee","text":"<ul> <li>\u6240\u6709\u65b9\u6cd5\u90fd\u662f\u9759\u6001\u7684\uff0c\u4e0d\u7ef4\u62a4\u72b6\u6001</li> <li>\u652f\u6301\u591a\u7ebf\u7a0b\u5e76\u53d1\u8c03\u7528</li> <li>\u65e0\u5171\u4eab\u72b6\u6001\uff0c\u65e0\u9700\u540c\u6b65\u673a\u5236</li> </ul>"},{"location":"process_checker/#_23","title":"\u6ce8\u610f\u4e8b\u9879","text":"<ul> <li>\u8fdb\u7a0b\u72b6\u6001\u53ef\u80fd\u5728\u68c0\u67e5\u8fc7\u7a0b\u4e2d\u53d1\u751f\u53d8\u5316</li> <li>\u5efa\u8bae\u5728\u5173\u952e\u64cd\u4f5c\u524d\u91cd\u65b0\u68c0\u67e5\u72b6\u6001</li> <li>\u8003\u8651\u4f7f\u7528\u9002\u5f53\u7684\u91cd\u8bd5\u673a\u5236</li> </ul>"},{"location":"process_checker/#_24","title":"\u6269\u5c55\u6027","text":""},{"location":"process_checker/#_25","title":"\u672a\u6765\u589e\u5f3a","text":"<ol> <li>\u66f4\u591a\u72b6\u6001\u7c7b\u578b: \u652f\u6301\u66f4\u8be6\u7ec6\u7684\u8fdb\u7a0b\u72b6\u6001</li> <li>\u6027\u80fd\u76d1\u63a7: \u6dfb\u52a0\u8fdb\u7a0b\u8d44\u6e90\u4f7f\u7528\u7edf\u8ba1</li> <li>\u4e8b\u4ef6\u901a\u77e5: \u652f\u6301\u8fdb\u7a0b\u72b6\u6001\u53d8\u5316\u901a\u77e5</li> <li>\u6279\u91cf\u64cd\u4f5c: \u4f18\u5316\u591a\u8fdb\u7a0b\u68c0\u67e5\u6027\u80fd</li> </ol>"},{"location":"process_checker/#cli","title":"\u4e0e CLI \u7684\u96c6\u6210","text":"<p><code>process_checker</code> \u6a21\u5757\u76f4\u63a5\u7528\u4e8e CLI \u4e2d\u7684 <code>pid</code> \u7b49\u547d\u4ee4\uff0c\u8fd9\u4e9b\u547d\u4ee4\u68c0\u67e5\u5e76\u663e\u793a\u76ee\u6807\u8fdb\u7a0b\u7684\u72b6\u6001\u3002\u8fd9\u786e\u4fdd\u7528\u6237\u53ef\u4ee5\u4ea4\u4e92\u5f0f\u5730\u9a8c\u8bc1\u8fdb\u7a0b\u72b6\u6001\u3002</p>"},{"location":"sets/","title":"\u96c6\u5408\u6a21\u5757\u6587\u6863","text":""},{"location":"sets/#_2","title":"\u6982\u8ff0","text":"<p><code>sets</code> \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u96c6\u5408\u64cd\u4f5c\u548c\u89e3\u6790\u5de5\u5177\u3002\u5b83\u5305\u62ec\u4e00\u4e2a\u7528\u4e8e\u7ba1\u7406\u6574\u6570\u96c6\u5408\u7684 <code>Set</code> \u7c7b\uff0c\u4ee5\u53ca\u4e00\u4e2a\u5f3a\u5927\u7684\u96c6\u5408\u8868\u8fbe\u5f0f\u89e3\u6790\u5668\uff0c\u652f\u6301\u8303\u56f4\u3001\u5341\u516d\u8fdb\u5236/\u5341\u8fdb\u5236\u6570\u5b57\u548c\u53d6\u53cd\u64cd\u4f5c\u3002</p>"},{"location":"sets/#_3","title":"\u6a21\u5757\u7ed3\u6784","text":"<pre><code>export module sets;\n</code></pre>"},{"location":"sets/#_4","title":"\u4f9d\u8d56\u9879","text":"<ul> <li><code>&lt;algorithm&gt;</code> - \u6807\u51c6\u7b97\u6cd5</li> <li><code>&lt;boost/regex.hpp&gt;</code> - \u6b63\u5219\u8868\u8fbe\u5f0f\u652f\u6301</li> <li><code>&lt;boost/spirit/include/phoenix.hpp&gt;</code> - Boost Spirit Phoenix \u8bed\u4e49\u52a8\u4f5c</li> <li><code>&lt;boost/spirit/include/qi.hpp&gt;</code> - Boost Spirit Qi \u89e3\u6790</li> <li><code>&lt;cctype&gt;</code> - \u5b57\u7b26\u5206\u7c7b</li> <li><code>&lt;compare&gt;</code> - \u4e09\u8def\u6bd4\u8f83</li> <li><code>&lt;cstdlib&gt;</code> - C \u6807\u51c6\u5e93</li> <li><code>&lt;stdexcept&gt;</code> - \u6807\u51c6\u5f02\u5e38</li> <li><code>&lt;string&gt;</code> - \u5b57\u7b26\u4e32\u64cd\u4f5c</li> <li><code>&lt;vector&gt;</code> - \u52a8\u6001\u6570\u7ec4\u5bb9\u5668</li> </ul>"},{"location":"sets/#_5","title":"\u6838\u5fc3\u529f\u80fd","text":""},{"location":"sets/#1-set","title":"1. Set \u7ed3\u6784","text":"<pre><code>export struct Set {\n    std::vector&lt;size_t&gt; buf;\n\n    size_t size() const;\n    void clear();\n    static int cmp(const size_t&amp; i1, const size_t&amp; i2);\n};\n</code></pre>"},{"location":"sets/#_6","title":"\u65b9\u6cd5","text":"<ul> <li>size(): \u8fd4\u56de\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6570\u91cf</li> <li>clear(): \u79fb\u9664\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20</li> <li>cmp(): \u4f7f\u7528\u4e09\u8def\u6bd4\u8f83\u5bf9\u4e24\u4e2a size_t \u503c\u8fdb\u884c\u9759\u6001\u6bd4\u8f83\u51fd\u6570</li> </ul>"},{"location":"sets/#2","title":"2. \u96c6\u5408\u8868\u8fbe\u5f0f\u89e3\u6790\u5668","text":"<pre><code>export bool parse_uintset(std::string_view lptr, Set&amp; set, size_t maxSZ);\n</code></pre>"},{"location":"sets/#_7","title":"\u652f\u6301\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f","text":"<ul> <li>\u5355\u4e2a\u6570\u5b57: <code>42</code>, <code>0x2A</code></li> <li>\u8303\u56f4: <code>10..20</code>, <code>0x10..0xFF</code></li> <li>\u591a\u4e2a\u503c: <code>1,2,3,4,5</code></li> <li>\u6df7\u5408\u683c\u5f0f: <code>1,5,10..15,0x20</code></li> <li>\u53d6\u53cd: <code>!1,2,3</code> (\u9664\u4e86 1,2,3 \u4e4b\u5916\u7684\u6240\u6709\u6570\u5b57)</li> <li>\u5341\u516d\u8fdb\u5236: <code>0x10</code>, <code>0xFF</code>, <code>0xdeadbeef</code></li> </ul>"},{"location":"sets/#_8","title":"\u53c2\u6570","text":"<ul> <li>lptr: \u8981\u89e3\u6790\u7684\u96c6\u5408\u8868\u8fbe\u5f0f\u5b57\u7b26\u4e32</li> <li>set: \u7528\u4e8e\u5b58\u50a8\u7ed3\u679c\u7684 Set \u5bf9\u8c61</li> <li>maxSZ: \u6700\u5927\u5141\u8bb8\u503c\uff08\u72ec\u5360\u4e0a\u754c\uff09</li> </ul>"},{"location":"sets/#_9","title":"\u8fd4\u56de\u503c","text":"<ul> <li><code>true</code>: \u89e3\u6790\u6210\u529f</li> <li><code>false</code>: \u89e3\u6790\u5931\u8d25\uff08\u8bed\u6cd5\u65e0\u6548\u3001\u8d85\u51fa\u8303\u56f4\u7b49\uff09</li> </ul>"},{"location":"sets/#3","title":"3. \u5df2\u5f03\u7528\u7684\u5185\u5b58\u7ba1\u7406","text":"<pre><code>[[deprecated(\"This interface is deprecated...\")]]\nconstexpr auto inc_arr_sz = [](size_t** valarr, size_t* arr_maxsz, size_t maxsz) -&gt; bool;\n</code></pre> <p>\u4e00\u4e2a\u5df2\u5f03\u7528\u7684 C \u98ce\u683c\u5185\u5b58\u7ba1\u7406\u5de5\u5177\uff0c\u7528\u4e8e\u52a8\u6001\u6570\u7ec4\u5927\u5c0f\u8c03\u6574\u3002</p>"},{"location":"sets/#_10","title":"\u4f7f\u7528\u793a\u4f8b","text":""},{"location":"sets/#_11","title":"\u57fa\u672c\u96c6\u5408\u89e3\u6790","text":"<pre><code>import sets;\n\nSet mySet;\nbool success = parse_uintset(\"1,2,3,4,5\", mySet, 100);\nif (success) {\n    std::cout &lt;&lt; \"\u96c6\u5408\u5305\u542b \" &lt;&lt; mySet.size() &lt;&lt; \" \u4e2a\u5143\u7d20\\n\";\n}\n</code></pre>"},{"location":"sets/#_12","title":"\u8303\u56f4\u89e3\u6790","text":"<pre><code>Set rangeSet;\nparse_uintset(\"10..20\", rangeSet, 100);\n// \u7ed3\u679c: {10, 11, 12, ..., 20}\n</code></pre>"},{"location":"sets/#_13","title":"\u5341\u516d\u8fdb\u5236\u89e3\u6790","text":"<pre><code>Set hexSet;\nparse_uintset(\"0x10..0x20\", hexSet, 100);\n// \u7ed3\u679c: {16, 17, 18, ..., 32}\n</code></pre>"},{"location":"sets/#_14","title":"\u6df7\u5408\u683c\u5f0f\u89e3\u6790","text":"<pre><code>Set mixedSet;\nparse_uintset(\"1,5,10..15,0x20\", mixedSet, 100);\n// \u7ed3\u679c: {1, 5, 10, 11, 12, 13, 14, 15, 32}\n</code></pre>"},{"location":"sets/#_15","title":"\u53d6\u53cd\u64cd\u4f5c\u793a\u4f8b","text":"<pre><code>Set invertedSet;\nparse_uintset(\"!1,2,3\", invertedSet, 10);\n// \u7ed3\u679c: {0, 4, 5, 6, 7, 8, 9} (\u9664\u4e86 1,2,3 \u4e4b\u5916\u7684\u6240\u6709\u6570\u5b57)\n</code></pre>"},{"location":"sets/#_16","title":"\u8868\u8fbe\u5f0f\u8bed\u6cd5","text":""},{"location":"sets/#_17","title":"\u6570\u5b57\u683c\u5f0f","text":"<ul> <li>\u5341\u8fdb\u5236: <code>123</code>, <code>456</code>, <code>789</code></li> <li>\u5341\u516d\u8fdb\u5236: <code>0x7B</code>, <code>0x1C8</code>, <code>0x315</code></li> <li>\u6df7\u5408: \u5728\u540c\u4e00\u8868\u8fbe\u5f0f\u4e2d\u53ef\u4ee5\u6df7\u5408\u4f7f\u7528</li> </ul>"},{"location":"sets/#_18","title":"\u8303\u56f4\u8bed\u6cd5","text":"<ul> <li>\u57fa\u672c\u8303\u56f4: <code>start..end</code></li> <li>\u5341\u516d\u8fdb\u5236\u8303\u56f4: <code>0xstart..0xend</code></li> <li>\u5305\u542b\u8fb9\u754c: \u8303\u56f4\u5305\u542b\u8d77\u59cb\u503c\u548c\u7ed3\u675f\u503c</li> </ul>"},{"location":"sets/#_19","title":"\u5206\u9694\u7b26","text":"<ul> <li>\u9017\u53f7\u5206\u9694: <code>1,2,3,4,5</code></li> <li>\u7a7a\u683c\u5206\u9694: <code>1 2 3 4 5</code> (\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b)</li> <li>\u6df7\u5408\u5206\u9694: <code>1, 2, 3, 4, 5</code></li> </ul>"},{"location":"sets/#_20","title":"\u53d6\u53cd\u64cd\u4f5c","text":"<ul> <li>\u8bed\u6cd5: <code>!expression</code></li> <li>\u6548\u679c: \u5305\u542b\u6307\u5b9a\u8303\u56f4\u5185\u9664\u4e86\u8868\u8fbe\u5f0f\u6307\u5b9a\u503c\u4e4b\u5916\u7684\u6240\u6709\u6570\u5b57</li> <li>\u793a\u4f8b: <code>!1,2,3</code> \u5728\u8303\u56f4 0..10 \u4e2d\u8868\u793a <code>{0,4,5,6,7,8,9,10}</code></li> </ul>"},{"location":"sets/#_21","title":"\u9519\u8bef\u5904\u7406","text":""},{"location":"sets/#_22","title":"\u5e38\u89c1\u9519\u8bef","text":"<ol> <li>\u8bed\u6cd5\u9519\u8bef: \u65e0\u6548\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f</li> <li>\u8d85\u51fa\u8303\u56f4: \u6570\u5b57\u8d85\u51fa\u6307\u5b9a\u7684\u6700\u5927\u503c</li> <li>\u7a7a\u8868\u8fbe\u5f0f: \u7a7a\u5b57\u7b26\u4e32\u6216\u65e0\u6548\u8f93\u5165</li> <li>\u89e3\u6790\u5931\u8d25: Boost Spirit \u89e3\u6790\u5668\u9519\u8bef</li> </ol>"},{"location":"sets/#_23","title":"\u9519\u8bef\u5904\u7406\u7b56\u7565","text":"<ul> <li>\u8fd4\u56de <code>false</code> \u8868\u793a\u89e3\u6790\u5931\u8d25</li> <li>\u4e0d\u4fee\u6539\u76ee\u6807 Set \u5bf9\u8c61</li> <li>\u63d0\u4f9b\u8be6\u7ec6\u7684\u9519\u8bef\u4fe1\u606f\u7528\u4e8e\u8c03\u8bd5</li> </ul>"},{"location":"sets/#_24","title":"\u6027\u80fd\u8003\u8651","text":""},{"location":"sets/#_25","title":"\u4f18\u5316\u7b56\u7565","text":"<ol> <li>\u5185\u5b58\u9884\u5206\u914d: \u6839\u636e\u8868\u8fbe\u5f0f\u590d\u6742\u5ea6\u9884\u5206\u914d\u5185\u5b58</li> <li>\u89e3\u6790\u4f18\u5316: \u4f7f\u7528\u9ad8\u6548\u7684 Boost Spirit \u89e3\u6790\u5668</li> <li>\u8303\u56f4\u4f18\u5316: \u5bf9\u8fde\u7eed\u8303\u56f4\u8fdb\u884c\u7279\u6b8a\u5904\u7406</li> </ol>"},{"location":"sets/#_26","title":"\u5185\u5b58\u4f7f\u7528","text":"<ul> <li>\u52a8\u6001\u589e\u957f: \u6839\u636e\u89e3\u6790\u7ed3\u679c\u52a8\u6001\u8c03\u6574\u5185\u5b58</li> <li>\u6700\u5c0f\u5316\u5206\u914d: \u51cf\u5c11\u4e0d\u5fc5\u8981\u7684\u5185\u5b58\u5206\u914d</li> <li>\u7f13\u5b58\u53cb\u597d: \u4f7f\u7528\u8fde\u7eed\u5185\u5b58\u5e03\u5c40</li> </ul>"},{"location":"sets/#_27","title":"\u6269\u5c55\u6027","text":""},{"location":"sets/#_28","title":"\u672a\u6765\u589e\u5f3a","text":"<ol> <li>\u66f4\u591a\u6570\u5b57\u683c\u5f0f: \u652f\u6301\u516b\u8fdb\u5236\u3001\u4e8c\u8fdb\u5236\u7b49</li> <li>\u590d\u6742\u8868\u8fbe\u5f0f: \u652f\u6301\u6570\u5b66\u8fd0\u7b97\u548c\u51fd\u6570</li> <li>\u6027\u80fd\u4f18\u5316: \u8fdb\u4e00\u6b65\u4f18\u5316\u89e3\u6790\u6027\u80fd</li> <li>\u9519\u8bef\u6062\u590d: \u66f4\u597d\u7684\u9519\u8bef\u6062\u590d\u673a\u5236</li> </ol>"},{"location":"sets/#_29","title":"\u517c\u5bb9\u6027","text":""},{"location":"sets/#_30","title":"\u5411\u540e\u517c\u5bb9","text":"<ul> <li>\u4fdd\u6301\u4e0e\u73b0\u6709\u4ee3\u7801\u7684\u517c\u5bb9\u6027</li> <li>\u652f\u6301\u65e7\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f</li> <li>\u6e10\u8fdb\u5f0f\u5f03\u7528\u8fc7\u65f6\u529f\u80fd</li> </ul>"},{"location":"sets/#_31","title":"\u6807\u51c6\u517c\u5bb9","text":"<ul> <li>\u9075\u5faa C++23 \u6807\u51c6</li> <li>\u4f7f\u7528\u73b0\u4ee3 C++ \u7279\u6027</li> <li>\u4fdd\u6301\u8de8\u5e73\u53f0\u517c\u5bb9\u6027</li> </ul>"},{"location":"sets/#cli","title":"\u4e0e CLI \u7684\u96c6\u6210","text":"<p><code>sets</code> \u6a21\u5757\u5728 CLI \u4e2d\u7528\u4e8e\u89e3\u6790\u548c\u7ba1\u7406\u5185\u5b58\u626b\u63cf\u671f\u95f4\u7684\u7ed3\u679c\u96c6\u3002<code>scan</code> \u548c <code>reset</code> \u7b49\u547d\u4ee4\u4f9d\u8d56\u6b64\u6a21\u5757\u9ad8\u6548\u5730\u5904\u7406\u96c6\u5408\u64cd\u4f5c\u3002</p>"},{"location":"show_message/","title":"\u6d88\u606f\u663e\u793a\u6a21\u5757\u6587\u6863","text":""},{"location":"show_message/#_2","title":"\u6982\u8ff0","text":"<p><code>show_message</code> \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5168\u9762\u7684\u6d88\u606f\u6253\u5370\u548c\u65e5\u5fd7\u7cfb\u7edf\u3002\u5b83\u652f\u6301\u591a\u79cd\u6d88\u606f\u7c7b\u578b\u3001\u57fa\u4e8e\u8c03\u8bd5/\u540e\u7aef\u6a21\u5f0f\u7684\u6761\u4ef6\u8f93\u51fa\uff0c\u4ee5\u53ca\u4f7f\u7528 C++20 \u683c\u5f0f\u5b57\u7b26\u4e32\u7684\u683c\u5f0f\u5316\u8f93\u51fa\u3002</p>"},{"location":"show_message/#_3","title":"\u6a21\u5757\u7ed3\u6784","text":"<pre><code>export module show_message;\n</code></pre>"},{"location":"show_message/#_4","title":"\u4f9d\u8d56\u9879","text":"<ul> <li><code>&lt;boost/process.hpp&gt;</code> - Boost \u8fdb\u7a0b\u5e93</li> <li><code>&lt;cstdint&gt;</code> - \u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b</li> <li><code>&lt;format&gt;</code> - C++20 \u683c\u5f0f\u5e93</li> <li><code>&lt;iostream&gt;</code> - \u6807\u51c6 I/O \u6d41</li> <li><code>&lt;string_view&gt;</code> - \u7528\u4e8e\u9ad8\u6548\u5b57\u7b26\u4e32\u5904\u7406\u7684\u5b57\u7b26\u4e32\u89c6\u56fe</li> </ul>"},{"location":"show_message/#_5","title":"\u6838\u5fc3\u529f\u80fd","text":""},{"location":"show_message/#1","title":"1. \u6d88\u606f\u7c7b\u578b\u7cfb\u7edf","text":"<pre><code>enum class MessageType : uint8_t {\n    INFO,    // \u4fe1\u606f\u6d88\u606f\n    WARN,    // \u8b66\u544a\u6d88\u606f\n    ERROR,   // \u9519\u8bef\u6d88\u606f\n    DEBUG,   // \u8c03\u8bd5\u6d88\u606f\uff08\u6761\u4ef6\u6027\uff09\n    USER     // \u9762\u5411\u7528\u6237\u7684\u6d88\u606f\uff08\u6761\u4ef6\u6027\uff09\n};\n</code></pre>"},{"location":"show_message/#2","title":"2. \u6d88\u606f\u4e0a\u4e0b\u6587","text":"<pre><code>struct MessageContext {\n    bool debugMode = false;    // \u542f\u7528\u8c03\u8bd5\u8f93\u51fa\n    bool backendMode = false;  // \u6291\u5236\u7528\u6237\u8f93\u51fa\n};\n</code></pre>"},{"location":"show_message/#3-messageprinter","title":"3. MessagePrinter \u7c7b","text":""},{"location":"show_message/#_6","title":"\u6784\u9020\u51fd\u6570","text":"<pre><code>MessagePrinter(MessageContext ctx = {});\n</code></pre>"},{"location":"show_message/#_7","title":"\u4e3b\u8981\u6253\u5370\u65b9\u6cd5","text":"<pre><code>template&lt;typename... Args&gt;\nvoid print(MessageType type, std::string_view fmt, Args&amp;&amp;... args) const;\n</code></pre>"},{"location":"show_message/#_8","title":"\u4fbf\u6377\u65b9\u6cd5","text":"<pre><code>template&lt;typename... Args&gt;\nvoid info(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid warn(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid error(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid debug(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid user(std::string_view fmt, Args&amp;&amp;... args) const;\n</code></pre>"},{"location":"show_message/#_9","title":"\u4f7f\u7528\u793a\u4f8b","text":""},{"location":"show_message/#_10","title":"\u57fa\u672c\u4f7f\u7528","text":"<pre><code>import show_message;\n\nMessagePrinter printer;\nprinter.info(\"\u5f00\u59cb\u5185\u5b58\u626b\u63cf\");\nprinter.warn(\"\u68c0\u6d4b\u5230\u5185\u5b58\u4e0d\u8db3\");\nprinter.error(\"\u65e0\u6cd5\u6253\u5f00\u8fdb\u7a0b\");\n</code></pre>"},{"location":"show_message/#_11","title":"\u4f7f\u7528\u683c\u5f0f\u5b57\u7b26\u4e32","text":"<pre><code>printer.info(\"\u6b63\u5728\u626b\u63cf PID \u4e3a {} \u7684\u8fdb\u7a0b\", pid);\nprinter.warn(\"\u53d1\u73b0 {} \u4e2a\u53ef\u7591\u5185\u5b58\u533a\u57df\", suspicious_count);\nprinter.error(\"\u5728\u5730\u5740 0x{:08x} \u5904\u5185\u5b58\u8bfb\u53d6\u5931\u8d25\", address);\n</code></pre>"},{"location":"show_message/#_12","title":"\u8c03\u8bd5\u6a21\u5f0f\u4f7f\u7528","text":"<pre><code>MessageContext ctx;\nctx.debugMode = true;\nMessagePrinter debugPrinter(ctx);\n\ndebugPrinter.debug(\"\u8c03\u8bd5\u4fe1\u606f: \u5185\u5b58\u5730\u5740 0x{:x}\", address);\ndebugPrinter.debug(\"\u5185\u90e8\u72b6\u6001: {}\", internal_state);\n</code></pre>"},{"location":"show_message/#_13","title":"\u540e\u7aef\u6a21\u5f0f\u4f7f\u7528","text":"<pre><code>MessageContext ctx;\nctx.backendMode = true;\nMessagePrinter backendPrinter(ctx);\n\n// \u7528\u6237\u6d88\u606f\u5c06\u88ab\u6291\u5236\nbackendPrinter.user(\"\u8fd9\u6761\u6d88\u606f\u4e0d\u4f1a\u663e\u793a\");\n// \u4f46\u9519\u8bef\u6d88\u606f\u4ecd\u7136\u4f1a\u663e\u793a\nbackendPrinter.error(\"\u9519\u8bef\u6d88\u606f\u4ecd\u7136\u4f1a\u663e\u793a\");\n</code></pre>"},{"location":"show_message/#_14","title":"\u6d88\u606f\u7c7b\u578b\u8be6\u89e3","text":""},{"location":"show_message/#info","title":"INFO \u6d88\u606f","text":"<ul> <li>\u7528\u9014: \u4e00\u822c\u4fe1\u606f\u6027\u6d88\u606f</li> <li>\u663e\u793a\u6761\u4ef6: \u59cb\u7ec8\u663e\u793a</li> <li>\u793a\u4f8b: \u7a0b\u5e8f\u542f\u52a8\u3001\u626b\u63cf\u5b8c\u6210\u3001\u72b6\u6001\u66f4\u65b0</li> </ul> <pre><code>printer.info(\"\u5185\u5b58\u626b\u63cf\u5b8c\u6210\");\nprinter.info(\"\u627e\u5230 {} \u4e2a\u5339\u914d\u9879\", match_count);\n</code></pre>"},{"location":"show_message/#warn","title":"WARN \u6d88\u606f","text":"<ul> <li>\u7528\u9014: \u8b66\u544a\u4fe1\u606f\uff0c\u9700\u8981\u6ce8\u610f\u4f46\u4e0d\u81f4\u547d</li> <li>\u663e\u793a\u6761\u4ef6: \u59cb\u7ec8\u663e\u793a</li> <li>\u793a\u4f8b: \u6027\u80fd\u8b66\u544a\u3001\u914d\u7f6e\u95ee\u9898\u3001\u975e\u5173\u952e\u9519\u8bef</li> </ul> <pre><code>printer.warn(\"\u5185\u5b58\u4f7f\u7528\u7387\u8f83\u9ad8: {}%\", memory_usage);\nprinter.warn(\"\u67d0\u4e9b\u533a\u57df\u65e0\u6cd5\u8bbf\u95ee\");\n</code></pre>"},{"location":"show_message/#error","title":"ERROR \u6d88\u606f","text":"<ul> <li>\u7528\u9014: \u9519\u8bef\u4fe1\u606f\uff0c\u8868\u793a\u64cd\u4f5c\u5931\u8d25</li> <li>\u663e\u793a\u6761\u4ef6: \u59cb\u7ec8\u663e\u793a</li> <li>\u793a\u4f8b: \u6587\u4ef6\u6253\u5f00\u5931\u8d25\u3001\u6743\u9650\u9519\u8bef\u3001\u7cfb\u7edf\u9519\u8bef</li> </ul> <pre><code>printer.error(\"\u65e0\u6cd5\u6253\u5f00\u8fdb\u7a0b: {}\", error_message);\nprinter.error(\"\u5185\u5b58\u8bfb\u53d6\u5931\u8d25: {}\", strerror(errno));\n</code></pre>"},{"location":"show_message/#debug","title":"DEBUG \u6d88\u606f","text":"<ul> <li>\u7528\u9014: \u8c03\u8bd5\u4fe1\u606f\uff0c\u7528\u4e8e\u5f00\u53d1\u8c03\u8bd5</li> <li>\u663e\u793a\u6761\u4ef6: \u4ec5\u5728 debugMode = true \u65f6\u663e\u793a</li> <li>\u793a\u4f8b: \u5185\u90e8\u72b6\u6001\u3001\u8be6\u7ec6\u6267\u884c\u6d41\u7a0b\u3001\u6027\u80fd\u6570\u636e</li> </ul> <pre><code>printer.debug(\"\u5185\u90e8\u72b6\u6001: {}\", internal_state);\nprinter.debug(\"\u6267\u884c\u65f6\u95f4: {} ms\", execution_time);\n</code></pre>"},{"location":"show_message/#user","title":"USER \u6d88\u606f","text":"<ul> <li>\u7528\u9014: \u9762\u5411\u7528\u6237\u7684\u6d88\u606f</li> <li>\u663e\u793a\u6761\u4ef6: \u4ec5\u5728 backendMode = false \u65f6\u663e\u793a</li> <li>\u793a\u4f8b: \u7528\u6237\u63d0\u793a\u3001\u8fdb\u5ea6\u4fe1\u606f\u3001\u4ea4\u4e92\u6d88\u606f</li> </ul> <pre><code>printer.user(\"\u8bf7\u8f93\u5165\u76ee\u6807\u8fdb\u7a0b ID:\");\nprinter.user(\"\u626b\u63cf\u8fdb\u5ea6: {}%\", progress);\n</code></pre>"},{"location":"show_message/#_15","title":"\u683c\u5f0f\u5316\u529f\u80fd","text":""},{"location":"show_message/#c20","title":"C++20 \u683c\u5f0f\u5b57\u7b26\u4e32","text":"<p>\u652f\u6301\u5b8c\u6574\u7684 C++20 \u683c\u5f0f\u5b57\u7b26\u4e32\u529f\u80fd\uff1a</p> <pre><code>// \u6574\u6570\u683c\u5f0f\u5316\nprinter.info(\"\u8fdb\u7a0b ID: {}\", pid);\nprinter.info(\"\u5730\u5740: 0x{:08x}\", address);\n\n// \u6d6e\u70b9\u6570\u683c\u5f0f\u5316\nprinter.info(\"\u5185\u5b58\u4f7f\u7528\u7387: {:.2f}%\", memory_usage);\n\n// \u5b57\u7b26\u4e32\u683c\u5f0f\u5316\nprinter.info(\"\u6587\u4ef6\u540d: {}\", filename);\n\n// \u590d\u6742\u683c\u5f0f\u5316\nprinter.info(\"\u626b\u63cf\u7ed3\u679c: {} \u4e2a\u5339\u914d\u9879\uff0c\u8017\u65f6 {:.3f} \u79d2\", \n            match_count, elapsed_time);\n</code></pre>"},{"location":"show_message/#_16","title":"\u7c7b\u578b\u5b89\u5168","text":"<ul> <li>\u7f16\u8bd1\u65f6\u7c7b\u578b\u68c0\u67e5</li> <li>\u81ea\u52a8\u7c7b\u578b\u63a8\u5bfc</li> <li>\u9632\u6b62\u683c\u5f0f\u5316\u9519\u8bef</li> </ul>"},{"location":"show_message/#_17","title":"\u4e0a\u4e0b\u6587\u7ba1\u7406","text":""},{"location":"show_message/#_18","title":"\u5168\u5c40\u4e0a\u4e0b\u6587","text":"<pre><code>// \u521b\u5efa\u5168\u5c40\u6d88\u606f\u6253\u5370\u673a\nMessageContext globalContext;\nglobalContext.debugMode = true;\nMessagePrinter globalPrinter(globalContext);\n</code></pre>"},{"location":"show_message/#_19","title":"\u5c40\u90e8\u4e0a\u4e0b\u6587","text":"<pre><code>void someFunction() {\n    MessageContext localContext;\n    localContext.backendMode = true;\n    MessagePrinter localPrinter(localContext);\n\n    // \u4f7f\u7528\u5c40\u90e8\u6253\u5370\u673a\n    localPrinter.info(\"\u5c40\u90e8\u6d88\u606f\");\n}\n</code></pre>"},{"location":"show_message/#_20","title":"\u4e0a\u4e0b\u6587\u7ee7\u627f","text":"<pre><code>class MyClass {\nprivate:\n    MessagePrinter m_printer;\n\npublic:\n    MyClass(MessageContext ctx) : m_printer(ctx) {}\n\n    void doSomething() {\n        m_printer.info(\"\u7c7b\u5185\u90e8\u6d88\u606f\");\n    }\n};\n</code></pre>"},{"location":"show_message/#_21","title":"\u6027\u80fd\u8003\u8651","text":""},{"location":"show_message/#_22","title":"\u7f16\u8bd1\u65f6\u4f18\u5316","text":"<ul> <li>\u6a21\u677f\u5b9e\u4f8b\u5316\u4f18\u5316</li> <li>\u5185\u8054\u51fd\u6570\u8c03\u7528</li> <li>\u6761\u4ef6\u7f16\u8bd1</li> </ul>"},{"location":"show_message/#_23","title":"\u8fd0\u884c\u65f6\u4f18\u5316","text":"<ul> <li>\u5b57\u7b26\u4e32\u89c6\u56fe\u907f\u514d\u62f7\u8d1d</li> <li>\u683c\u5f0f\u5316\u53c2\u6570\u5b8c\u7f8e\u8f6c\u53d1</li> <li>\u6700\u5c0f\u5316\u5185\u5b58\u5206\u914d</li> </ul>"},{"location":"show_message/#_24","title":"\u8f93\u51fa\u63a7\u5236","text":"<ul> <li>\u6761\u4ef6\u8f93\u51fa\u51cf\u5c11 I/O \u5f00\u9500</li> <li>\u8c03\u8bd5\u6a21\u5f0f\u53ef\u5b8c\u5168\u7981\u7528</li> <li>\u540e\u7aef\u6a21\u5f0f\u6291\u5236\u7528\u6237\u8f93\u51fa</li> </ul>"},{"location":"show_message/#_25","title":"\u9519\u8bef\u5904\u7406","text":""},{"location":"show_message/#_26","title":"\u683c\u5f0f\u5316\u9519\u8bef","text":"<ul> <li>\u7f16\u8bd1\u65f6\u68c0\u67e5\u683c\u5f0f\u5b57\u7b26\u4e32</li> <li>\u8fd0\u884c\u65f6\u9a8c\u8bc1\u53c2\u6570\u7c7b\u578b</li> <li>\u4f18\u96c5\u7684\u9519\u8bef\u5904\u7406</li> </ul>"},{"location":"show_message/#_27","title":"\u8f93\u51fa\u9519\u8bef","text":"<ul> <li>\u68c0\u67e5\u8f93\u51fa\u6d41\u72b6\u6001</li> <li>\u5904\u7406\u5199\u5165\u5931\u8d25</li> <li>\u63d0\u4f9b\u9519\u8bef\u53cd\u9988</li> </ul>"},{"location":"show_message/#_28","title":"\u6269\u5c55\u6027","text":""},{"location":"show_message/#_29","title":"\u81ea\u5b9a\u4e49\u6d88\u606f\u7c7b\u578b","text":"<pre><code>enum class CustomMessageType : uint8_t {\n    VERBOSE,  // \u8be6\u7ec6\u8f93\u51fa\n    TRACE,    // \u8ddf\u8e2a\u4fe1\u606f\n    // ... \u5176\u4ed6\u7c7b\u578b\n};\n</code></pre>"},{"location":"show_message/#_30","title":"\u81ea\u5b9a\u4e49\u8f93\u51fa\u76ee\u6807","text":"<pre><code>class CustomPrinter : public MessagePrinter {\npublic:\n    void print(MessageType type, std::string_view fmt, auto&amp;&amp;... args) const override {\n        // \u81ea\u5b9a\u4e49\u8f93\u51fa\u903b\u8f91\n    }\n};\n</code></pre>"},{"location":"show_message/#_31","title":"\u65e5\u5fd7\u6587\u4ef6\u652f\u6301","text":"<pre><code>class FileLogger {\nprivate:\n    std::ofstream m_logFile;\n    MessagePrinter m_printer;\n\npublic:\n    FileLogger(const std::string&amp; filename) : m_logFile(filename) {\n        // \u914d\u7f6e\u6587\u4ef6\u8f93\u51fa\n    }\n\n    void log(MessageType type, std::string_view fmt, auto&amp;&amp;... args) {\n        // \u5199\u5165\u6587\u4ef6\n        m_printer.print(type, fmt, std::forward&lt;decltype(args)&gt;(args)...);\n    }\n};\n</code></pre>"},{"location":"target_mem/","title":"\u76ee\u6807\u5185\u5b58\u6a21\u5757\u6587\u6863","text":""},{"location":"target_mem/#_2","title":"\u6982\u8ff0","text":"<p><code>targetmem</code> \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5185\u5b58\u5339\u914d\u548c\u5206\u6790\u7ed3\u6784\u3002\u5b83\u5305\u62ec\u7528\u4e8e\u7ba1\u7406\u5185\u5b58\u5339\u914d\u3001\u5b58\u50a8\u65e7\u503c\u4ee5\u53ca\u6267\u884c\u5185\u5b58\u533a\u57df\u64cd\u4f5c\u7684\u7c7b\uff0c\u652f\u6301\u9ad8\u6548\u7684\u641c\u7d22\u548c\u64cd\u4f5c\u3002</p>"},{"location":"target_mem/#_3","title":"\u6a21\u5757\u7ed3\u6784","text":"<pre><code>export module targetmem;\n</code></pre>"},{"location":"target_mem/#_4","title":"\u4f9d\u8d56\u9879","text":"<ul> <li><code>&lt;algorithm&gt;</code> - \u6807\u51c6\u7b97\u6cd5</li> <li><code>&lt;cassert&gt;</code> - \u65ad\u8a00\u5b8f</li> <li><code>&lt;cctype&gt;</code> - \u5b57\u7b26\u5206\u7c7b</li> <li><code>&lt;cstddef&gt;</code> - \u5927\u5c0f\u7c7b\u578b\u5b9a\u4e49</li> <li><code>&lt;cstdint&gt;</code> - \u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b</li> <li><code>&lt;cstdio&gt;</code> - C \u6807\u51c6 I/O</li> <li><code>&lt;cstdlib&gt;</code> - C \u6807\u51c6\u5e93</li> <li><code>&lt;cstring&gt;</code> - C \u5b57\u7b26\u4e32\u64cd\u4f5c</li> <li><code>&lt;optional&gt;</code> - \u53ef\u9009\u7c7b\u578b\u652f\u6301</li> <li><code>&lt;sstream&gt;</code> - \u5b57\u7b26\u4e32\u6d41\u64cd\u4f5c</li> <li><code>&lt;string&gt;</code> - \u5b57\u7b26\u4e32\u64cd\u4f5c</li> <li><code>&lt;vector&gt;</code> - \u52a8\u6001\u6570\u7ec4\u5bb9\u5668</li> <li><code>value</code> \u6a21\u5757 - \u503c\u7c7b\u578b\u5b9a\u4e49</li> <li><code>show_message</code> \u6a21\u5757 - \u6d88\u606f\u6253\u5370\u7cfb\u7edf</li> </ul>"},{"location":"target_mem/#_5","title":"\u6838\u5fc3\u529f\u80fd","text":""},{"location":"target_mem/#1","title":"1. \u5185\u5b58\u5339\u914d\u6807\u5fd7","text":"<p>\u4f7f\u7528\u6765\u81ea <code>value</code> \u6a21\u5757\u7684 <code>MatchFlags</code> \u6765\u6307\u793a\u5185\u5b58\u5339\u914d\u7684\u7c7b\u578b\u548c\u72b6\u6001\u3002</p>"},{"location":"target_mem/#2-oldvalueandmatchinfo","title":"2. OldValueAndMatchInfo \u7ed3\u6784","text":"<pre><code>struct OldValueAndMatchInfo {\n    uint8_t old_value;      // \u539f\u59cb\u5b57\u8282\u503c\n    MatchFlags match_info;  // \u5339\u914d\u7c7b\u578b\u548c\u72b6\u6001\u6807\u5fd7\n};\n</code></pre>"},{"location":"target_mem/#3-matchesandoldvaluesswath","title":"3. MatchesAndOldValuesSwath \u7c7b","text":"<p>\u8868\u793a\u5177\u6709\u5339\u914d\u4fe1\u606f\u7684\u8fde\u7eed\u5185\u5b58\u533a\u57df\u3002</p> <pre><code>class MatchesAndOldValuesSwath {\npublic:\n    void* firstByteInChild = nullptr;                    // \u8d77\u59cb\u5730\u5740\n    std::vector&lt;OldValueAndMatchInfo&gt; data;              // \u5339\u914d\u6570\u636e\n\n    // \u6784\u9020\u51fd\u6570\n    MatchesAndOldValuesSwath() = default;\n\n    // \u5143\u7d20\u7ba1\u7406\n    void addElement(void* addr, uint8_t byte, MatchFlags matchFlags);\n\n    // \u5b57\u7b26\u4e32\u8868\u793a\u5de5\u5177\n    std::string toPrintableString(size_t idx, size_t len) const;\n    std::string toByteArrayText(size_t idx, size_t len) const;\n};\n</code></pre>"},{"location":"target_mem/#_6","title":"\u65b9\u6cd5","text":""},{"location":"target_mem/#addelementvoid-addr-uint8_t-byte-matchflags-matchflags","title":"addElement(void* addr, uint8_t byte, MatchFlags matchFlags)","text":"<p>\u5411 swath \u6dfb\u52a0\u65b0\u7684\u5185\u5b58\u5339\u914d\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>addr</code>: \u5339\u914d\u7684\u5185\u5b58\u5730\u5740</li> <li><code>byte</code>: \u6b64\u5730\u5740\u7684\u5b57\u8282\u503c</li> <li><code>matchFlags</code>: \u5339\u914d\u7c7b\u578b\u548c\u6807\u5fd7</li> </ul>"},{"location":"target_mem/#toprintablestringsize_t-idx-size_t-len","title":"toPrintableString(size_t idx, size_t len)","text":"<p>\u5c06\u5185\u5b58\u5b57\u8282\u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u7684 ASCII \u5b57\u7b26\u4e32\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>idx</code>: \u6570\u636e\u5411\u91cf\u4e2d\u7684\u8d77\u59cb\u7d22\u5f15</li> <li><code>len</code>: \u8981\u8f6c\u6362\u7684\u5b57\u8282\u6570</li> </ul> <p>\u8fd4\u56de\uff1a \u53ef\u6253\u5370\u5b57\u7b26\u4e32\uff0c\u4e0d\u53ef\u6253\u5370\u5b57\u7b26\u663e\u793a\u4e3a '.'</p>"},{"location":"target_mem/#tobytearraytextsize_t-idx-size_t-len","title":"toByteArrayText(size_t idx, size_t len)","text":"<p>\u5c06\u5185\u5b58\u5b57\u8282\u8f6c\u6362\u4e3a\u5341\u516d\u8fdb\u5236\u6587\u672c\u8868\u793a\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>idx</code>: \u6570\u636e\u5411\u91cf\u4e2d\u7684\u8d77\u59cb\u7d22\u5f15</li> <li><code>len</code>: \u8981\u8f6c\u6362\u7684\u5b57\u8282\u6570</li> </ul> <p>\u8fd4\u56de\uff1a \u7a7a\u683c\u5206\u9694\u7684\u5341\u516d\u8fdb\u5236\u503c</p>"},{"location":"target_mem/#4-matchesandoldvaluesarray","title":"4. MatchesAndOldValuesArray \u7c7b","text":"<p>\u7ba1\u7406\u591a\u4e2a swath \u5e76\u63d0\u4f9b\u641c\u7d22\u64cd\u4f5c\u3002</p> <pre><code>class MatchesAndOldValuesArray {\npublic:\n    std::vector&lt;MatchesAndOldValuesSwath&gt; swaths;        // \u5185\u5b58\u533a\u57df\u96c6\u5408\n\n    // \u6784\u9020\u51fd\u6570\n    MatchesAndOldValuesArray() = default;\n\n    // \u641c\u7d22\u64cd\u4f5c\n    std::optional&lt;size_t&gt; findSwathIndex(void* addr) const;\n    std::optional&lt;size_t&gt; findElementIndex(void* addr) const;\n\n    // \u6570\u636e\u8bbf\u95ee\n    const OldValueAndMatchInfo* getElement(void* addr) const;\n    OldValueAndMatchInfo* getElement(void* addr);\n\n    // \u5185\u5b58\u7ba1\u7406\n    void clear();\n    size_t size() const;\n};\n</code></pre>"},{"location":"target_mem/#matchesandoldvaluesarray","title":"MatchesAndOldValuesArray\u65b9\u6cd5","text":""},{"location":"target_mem/#findswathindexvoid-addr-const","title":"findSwathIndex(void* addr) const","text":"<p>\u67e5\u627e\u5305\u542b\u6307\u5b9a\u5730\u5740\u7684 swath \u7d22\u5f15\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>addr</code>: \u8981\u67e5\u627e\u7684\u5185\u5b58\u5730\u5740</li> </ul> <p>\u8fd4\u56de\uff1a \u5305\u542b\u8be5\u5730\u5740\u7684 swath \u7d22\u5f15\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de std::nullopt</p>"},{"location":"target_mem/#findelementindexvoid-addr-const","title":"findElementIndex(void* addr) const","text":"<p>\u67e5\u627e\u6307\u5b9a\u5730\u5740\u5728 swath \u4e2d\u7684\u5143\u7d20\u7d22\u5f15\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>addr</code>: \u8981\u67e5\u627e\u7684\u5185\u5b58\u5730\u5740</li> </ul> <p>\u8fd4\u56de\uff1a \u5143\u7d20\u5728 swath \u4e2d\u7684\u7d22\u5f15\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de std::nullopt</p>"},{"location":"target_mem/#getelementvoid-addr","title":"getElement(void* addr)","text":"<p>\u83b7\u53d6\u6307\u5b9a\u5730\u5740\u7684\u5143\u7d20\u6570\u636e\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>addr</code>: \u5185\u5b58\u5730\u5740</li> </ul> <p>\u8fd4\u56de\uff1a \u6307\u5411 OldValueAndMatchInfo \u7684\u6307\u9488\uff0c\u5982\u679c\u672a\u627e\u5230\u5219\u8fd4\u56de nullptr</p>"},{"location":"target_mem/#_7","title":"\u4f7f\u7528\u793a\u4f8b","text":""},{"location":"target_mem/#_8","title":"\u57fa\u672c\u4f7f\u7528","text":"<pre><code>import targetmem;\n\n// \u521b\u5efa\u5185\u5b58\u5339\u914d\u6570\u7ec4\nMatchesAndOldValuesArray matches;\n\n// \u6dfb\u52a0\u5185\u5b58\u5339\u914d\nvoid* addr1 = (void*)0x1000;\nvoid* addr2 = (void*)0x1001;\n\nMatchesAndOldValuesSwath swath;\nswath.addElement(addr1, 0x42, MatchFlags::EXACT_MATCH);\nswath.addElement(addr2, 0x7F, MatchFlags::GREATER_THAN);\n\nmatches.swaths.push_back(swath);\n</code></pre>"},{"location":"target_mem/#_9","title":"\u641c\u7d22\u64cd\u4f5c","text":"<pre><code>// \u67e5\u627e\u5305\u542b\u5730\u5740\u7684 swath\nauto swathIndex = matches.findSwathIndex(addr1);\nif (swathIndex) {\n    std::cout &lt;&lt; \"\u627e\u5230 swath \u7d22\u5f15: \" &lt;&lt; *swathIndex &lt;&lt; std::endl;\n}\n\n// \u67e5\u627e\u5143\u7d20\u7d22\u5f15\nauto elementIndex = matches.findElementIndex(addr1);\nif (elementIndex) {\n    std::cout &lt;&lt; \"\u627e\u5230\u5143\u7d20\u7d22\u5f15: \" &lt;&lt; *elementIndex &lt;&lt; std::endl;\n}\n\n// \u83b7\u53d6\u5143\u7d20\u6570\u636e\nconst auto* element = matches.getElement(addr1);\nif (element) {\n    std::cout &lt;&lt; \"\u65e7\u503c: 0x\" &lt;&lt; std::hex &lt;&lt; (int)element-&gt;old_value &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"target_mem/#_10","title":"\u5b57\u7b26\u4e32\u8868\u793a","text":"<pre><code>// \u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u5b57\u7b26\u4e32\nstd::string printable = swath.toPrintableString(0, 10);\nstd::cout &lt;&lt; \"\u53ef\u6253\u5370\u5b57\u7b26\u4e32: \" &lt;&lt; printable &lt;&lt; std::endl;\n\n// \u8f6c\u6362\u4e3a\u5b57\u8282\u6570\u7ec4\u6587\u672c\nstd::string byteArray = swath.toByteArrayText(0, 10);\nstd::cout &lt;&lt; \"\u5b57\u8282\u6570\u7ec4: \" &lt;&lt; byteArray &lt;&lt; std::endl;\n</code></pre>"},{"location":"target_mem/#_11","title":"\u5185\u5b58\u7ba1\u7406","text":""},{"location":"target_mem/#_12","title":"\u5185\u5b58\u5e03\u5c40","text":"<p>\u6bcf\u4e2a <code>MatchesAndOldValuesSwath</code> \u8868\u793a\u4e00\u4e2a\u8fde\u7eed\u7684\u5185\u5b58\u533a\u57df\uff1a</p> <pre><code>+----------------+----------------+----------------+\n| \u5730\u5740 0x1000    | \u5730\u5740 0x1001    | \u5730\u5740 0x1002    |\n| \u65e7\u503c: 0x42     | \u65e7\u503c: 0x7F     | \u65e7\u503c: 0xAA     |\n| \u6807\u5fd7: EXACT    | \u6807\u5fd7: GREATER  | \u6807\u5fd7: LESS     |\n+----------------+----------------+----------------+\n</code></pre>"},{"location":"target_mem/#_13","title":"\u5185\u5b58\u5bf9\u9f50","text":"<ul> <li>\u5730\u5740\u6309\u5b57\u8282\u5bf9\u9f50</li> <li>\u6570\u636e\u7ed3\u6784\u7d27\u51d1\u5b58\u50a8</li> <li>\u652f\u6301\u8de8\u5e73\u53f0\u5185\u5b58\u5e03\u5c40</li> </ul>"},{"location":"target_mem/#_14","title":"\u5185\u5b58\u5b89\u5168","text":"<ul> <li>\u8fb9\u754c\u68c0\u67e5\u9632\u6b62\u8d8a\u754c\u8bbf\u95ee</li> <li>\u7a7a\u6307\u9488\u68c0\u67e5</li> <li>\u5f02\u5e38\u5b89\u5168\u4fdd\u8bc1</li> </ul>"},{"location":"target_mem/#_15","title":"\u6027\u80fd\u4f18\u5316","text":""},{"location":"target_mem/#_16","title":"\u641c\u7d22\u4f18\u5316","text":"<ol> <li>\u4e8c\u5206\u641c\u7d22: \u5728\u6709\u5e8f swath \u4e2d\u4f7f\u7528\u4e8c\u5206\u641c\u7d22</li> <li>\u5730\u5740\u8303\u56f4\u68c0\u67e5: \u5feb\u901f\u8fc7\u6ee4\u4e0d\u76f8\u5173\u7684 swath</li> <li>\u7f13\u5b58\u53cb\u597d: \u8fde\u7eed\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f</li> </ol>"},{"location":"target_mem/#_17","title":"\u5185\u5b58\u4f7f\u7528","text":"<ol> <li>\u7d27\u51d1\u5b58\u50a8: \u6700\u5c0f\u5316\u5185\u5b58\u5360\u7528</li> <li>\u52a8\u6001\u589e\u957f: \u6309\u9700\u5206\u914d\u5185\u5b58</li> <li>\u5185\u5b58\u6c60: \u51cf\u5c11\u5206\u914d\u5f00\u9500</li> </ol>"},{"location":"target_mem/#_18","title":"\u7b97\u6cd5\u590d\u6742\u5ea6","text":"<ul> <li>\u67e5\u627e swath: O(log n) \u5176\u4e2d n \u662f swath \u6570\u91cf</li> <li>\u67e5\u627e\u5143\u7d20: O(log m) \u5176\u4e2d m \u662f swath \u4e2d\u7684\u5143\u7d20\u6570\u91cf</li> <li>\u6dfb\u52a0\u5143\u7d20: O(1) \u5e73\u5747\u60c5\u51b5</li> </ul>"},{"location":"target_mem/#_19","title":"\u9519\u8bef\u5904\u7406","text":""},{"location":"target_mem/#_20","title":"\u5e38\u89c1\u9519\u8bef","text":"<ol> <li>\u65e0\u6548\u5730\u5740: \u7a7a\u6307\u9488\u6216\u65e0\u6548\u5185\u5b58\u5730\u5740</li> <li>\u8d8a\u754c\u8bbf\u95ee: \u8bbf\u95ee\u8d85\u51fa\u8303\u56f4\u7684\u7d22\u5f15</li> <li>\u5185\u5b58\u4e0d\u8db3: \u5206\u914d\u5931\u8d25</li> </ol>"},{"location":"target_mem/#_21","title":"\u9519\u8bef\u5904\u7406\u7b56\u7565","text":"<ul> <li>\u4f7f\u7528 std::optional \u8868\u793a\u67e5\u627e\u5931\u8d25</li> <li>\u8fd4\u56de nullptr \u8868\u793a\u65e0\u6548\u8bbf\u95ee</li> <li>\u629b\u51fa\u5f02\u5e38\u5904\u7406\u4e25\u91cd\u9519\u8bef</li> </ul>"},{"location":"target_mem/#_22","title":"\u6269\u5c55\u6027","text":""},{"location":"target_mem/#_23","title":"\u81ea\u5b9a\u4e49\u5339\u914d\u7c7b\u578b","text":"<pre><code>enum class CustomMatchFlags : uint8_t {\n    CUSTOM_MATCH_1,\n    CUSTOM_MATCH_2,\n    // ... \u5176\u4ed6\u7c7b\u578b\n};\n</code></pre>"},{"location":"target_mem/#_24","title":"\u81ea\u5b9a\u4e49\u6570\u636e\u7ed3\u6784","text":"<pre><code>struct CustomMatchInfo {\n    uint8_t old_value;\n    CustomMatchFlags flags;\n    std::string additional_info;\n};\n</code></pre>"},{"location":"target_mem/#_25","title":"\u63d2\u4ef6\u652f\u6301","text":"<pre><code>class MatchPlugin {\npublic:\n    virtual bool processMatch(void* addr, uint8_t value) = 0;\n    virtual std::string getDescription() const = 0;\n};\n</code></pre>"},{"location":"value/","title":"\u503c\u7c7b\u578b\u6a21\u5757\u6587\u6863","text":""},{"location":"value/#_2","title":"\u6982\u8ff0","text":"<p><code>value</code> \u6a21\u5757\u4e3a NewScanmem \u9879\u76ee\u63d0\u4f9b\u5168\u9762\u7684\u503c\u7c7b\u578b\u5b9a\u4e49\u548c\u5339\u914d\u6807\u5fd7\u3002\u5b83\u5b9a\u4e49\u4e86\u5404\u79cd\u6570\u636e\u7c7b\u578b\u8868\u793a\u3001\u5185\u5b58\u5e03\u5c40\u548c\u5b9e\u7528\u7ed3\u6784\uff0c\u7528\u4e8e\u5904\u7406\u5185\u5b58\u626b\u63cf\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u4e0d\u540c\u6570\u503c\u7c7b\u578b\u3001\u5b57\u8282\u6570\u7ec4\u548c\u901a\u914d\u7b26\u6a21\u5f0f\u3002</p>"},{"location":"value/#_3","title":"\u6a21\u5757\u7ed3\u6784","text":"<pre><code>export module value;\n</code></pre>"},{"location":"value/#_4","title":"\u4f9d\u8d56\u9879","text":"<ul> <li><code>&lt;cstdint&gt;</code> - \u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b</li> <li><code>&lt;cstring&gt;</code> - \u5b57\u8282\u62f7\u8d1d</li> <li><code>&lt;optional&gt;</code> - \u53ef\u9009\u7c7b\u578b\u652f\u6301</li> <li><code>&lt;span&gt;</code> - \u53ea\u8bfb/\u53ef\u5199\u5b57\u8282\u89c6\u56fe</li> <li><code>&lt;string&gt;</code> - \u5b57\u7b26\u4e32\u64cd\u4f5c</li> <li><code>&lt;type_traits&gt;</code> - \u7c7b\u578b\u5de5\u5177</li> <li><code>&lt;vector&gt;</code> - \u52a8\u6001\u6570\u7ec4\u5bb9\u5668</li> </ul>"},{"location":"value/#_5","title":"\u6838\u5fc3\u529f\u80fd","text":""},{"location":"value/#1","title":"1. \u5339\u914d\u6807\u5fd7\u679a\u4e3e","text":"<pre><code>enum class [[gnu::packed]] MatchFlags : uint16_t {\n    EMPTY = 0,\n\n    // \u57fa\u672c\u6570\u503c\u7c7b\u578b\n    U8B = 1 &lt;&lt; 0,   // \u65e0\u7b26\u53f7 8 \u4f4d\n    S8B = 1 &lt;&lt; 1,   // \u6709\u7b26\u53f7 8 \u4f4d\n    U16B = 1 &lt;&lt; 2,  // \u65e0\u7b26\u53f7 16 \u4f4d\n    S16B = 1 &lt;&lt; 3,  // \u6709\u7b26\u53f7 16 \u4f4d\n    U32B = 1 &lt;&lt; 4,  // \u65e0\u7b26\u53f7 32 \u4f4d\n    S32B = 1 &lt;&lt; 5,  // \u6709\u7b26\u53f7 32 \u4f4d\n    U64B = 1 &lt;&lt; 6,  // \u65e0\u7b26\u53f7 64 \u4f4d\n    S64B = 1 &lt;&lt; 7,  // \u6709\u7b26\u53f7 64 \u4f4d\n\n    // \u6d6e\u70b9\u7c7b\u578b\n    F32B = 1 &lt;&lt; 8,  // 32 \u4f4d\u6d6e\u70b9\n    F64B = 1 &lt;&lt; 9,  // 64 \u4f4d\u6d6e\u70b9\n\n    // \u590d\u5408\u7c7b\u578b\n    I8B = U8B | S8B,      // \u4efb\u610f 8 \u4f4d\u6574\u6570\n    I16B = U16B | S16B,   // \u4efb\u610f 16 \u4f4d\u6574\u6570\n    I32B = U32B | S32B,   // \u4efb\u610f 32 \u4f4d\u6574\u6570\n    I64B = U64B | S64B,   // \u4efb\u610f 64 \u4f4d\u6574\u6570\n\n    INTEGER = I8B | I16B | I32B | I64B,  // \u6240\u6709\u6574\u6570\u7c7b\u578b\n    FLOAT = F32B | F64B,                  // \u6240\u6709\u6d6e\u70b9\u7c7b\u578b\n    ALL = INTEGER | FLOAT,                // \u6240\u6709\u652f\u6301\u7684\u7c7b\u578b\n\n    // \u57fa\u4e8e\u5b57\u8282\u7684\u5206\u7ec4\n    B8 = I8B,           // 8 \u4f4d\u5757\n    B16 = I16B,         // 16 \u4f4d\u5757\n    B32 = I32B | F32B,  // 32 \u4f4d\u5757\n    B64 = I64B | F64B,  // 64 \u4f4d\u5757\n\n    MAX = 0xffffU  // \u6700\u5927\u6807\u5fd7\u503c\n};\n</code></pre>"},{"location":"value/#2-value","title":"2. Value \u7ed3\u6784\uff08\u7edf\u4e00\u4e3a\u5b57\u8282\u5b58\u50a8\uff09","text":"<p>Value \u4f5c\u4e3a\u201c\u5386\u53f2\u503c\uff08\u65e7\u503c\uff09\u201d\u5bb9\u5668\uff0c\u5e95\u5c42\u4ec5\u5b58\u50a8\u8fde\u7eed\u5b57\u8282\uff0c\u7c7b\u578b/\u5bbd\u5ea6\u8bed\u4e49\u7531 <code>flags</code> \u8868\u793a\u3002</p> <pre><code>struct [[gnu::packed]] Value {\n    std::vector&lt;uint8_t&gt; bytes;    // \u5386\u53f2\u503c\u5b57\u8282\n    MatchFlags flags = MatchFlags::EMPTY; // \u7c7b\u578b/\u5bbd\u5ea6\u6807\u5fd7\uff08\u4e25\u683c\u6570\u503c\u8def\u5f84\u9700\u8981\uff09\n\n    // \u590d\u4f4d\u4e3a\u96f6\u72b6\u6001\n    constexpr static void zero(Value&amp; val);\n\n    // \u83b7\u53d6\u53ea\u8bfb\u5b57\u8282\u89c6\u56fe\n    std::span&lt;const uint8_t&gt; view() const noexcept;\n\n    // \u6309\u5b57\u8282\u8bbe\u7f6e\uff08\u53ef\u9644\u5e26 flag\uff09\n    void setBytes(const uint8_t* data, std::size_t len);\n    void setBytes(const std::vector&lt;uint8_t&gt;&amp; val);\n    void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f);\n    void setBytesWithFlag(const std::vector&lt;uint8_t&gt;&amp; val, MatchFlags f);\n\n    // \u6309\u6807\u91cf\u8bbe\u7f6e\uff08\u62f7\u8d1d\u5176\u5185\u5b58\u8868\u793a\uff09\uff1bTyped \u7248\u672c\u81ea\u52a8\u8bbe\u7f6e\u6b63\u786e flag\n    template &lt;typename T&gt; void setScalar(const T&amp; v);\n    template &lt;typename T&gt; void setScalarWithFlag(const T&amp; v, MatchFlags f);\n    template &lt;typename T&gt; void setScalarTyped(const T&amp; v);\n};\n</code></pre> <p>\u8981\u70b9\uff1a - \u6570\u503c\u6bd4\u8f83\u8def\u5f84\u201c\u4e25\u683c\u6821\u9a8c\u201d\uff1a\u53ea\u6709\u5f53 <code>flags</code> \u4e0e\u671f\u671b\u7c7b\u578b\u76f8\u7b26\u4e14 <code>bytes.size() &gt;= sizeof(T)</code> \u65f6\uff0c\u65e7\u503c\u624d\u4f1a\u88ab\u89e3\u7801\u53c2\u4e0e\u6bd4\u8f83\u3002 - \u5b57\u8282\u4e32/\u5b57\u7b26\u4e32\u5339\u914d\u4e0d\u4f9d\u8d56 <code>flags</code>\uff0c\u4e0d\u53d7\u4e25\u683c\u7b56\u7565\u9650\u5236\u3002</p>"},{"location":"value/#3-mem64","title":"3. Mem64 \u7ed3\u6784\uff08\u5f53\u524d\u503c\u8bfb\u53d6\u7f13\u51b2\uff09","text":"<p>Mem64 \u8868\u793a\u201c\u5f53\u524d\u4f4d\u7f6e\u8bfb\u53d6\u5230\u7684\u5b57\u8282\u201d\u3002</p> <pre><code>struct [[gnu::packed]] Mem64 {\n    std::vector&lt;uint8_t&gt; buffer;   // \u5f53\u524d\u503c\u5b57\u8282\n\n    // \u8bfb\u53d6/\u5199\u5165\n    template &lt;typename T&gt; T get() const;  // \u7528 memcpy \u89e3\u7801 T\n    std::span&lt;const uint8_t&gt; bytes() const noexcept; // \u53ea\u8bfb\u89c6\u56fe\n    void setBytes(const uint8_t* data, std::size_t len);\n    void setBytes(const std::vector&lt;uint8_t&gt;&amp; data);\n    void setString(const std::string&amp; s);\n    template &lt;typename T&gt; void setScalar(const T&amp; v);\n};\n</code></pre> <p>\u7aef\u5e8f\u5904\u7406\uff1a\u5bf9\u4e8e\u6570\u503c\u7c7b\u578b\uff0c\u901a\u8fc7 <code>swapIfReverse</code>\uff08\u5728\u626b\u63cf\u6a21\u5757\u5185\uff09\u6216\u5bf9 <code>Value</code> \u4f7f\u7528 <code>fixEndianness</code> \u5c06\u65e7\u503c\u4e0e\u5f53\u524d\u503c\u7aef\u5e8f\u5bf9\u9f50\u3002</p>"},{"location":"value/#_6","title":"\u4f7f\u7528\u793a\u4f8b","text":""},{"location":"value/#_7","title":"\u57fa\u672c\u4f7f\u7528\uff08\u6570\u503c\u4e25\u683c + \u5b57\u8282\u81ea\u7531\uff09","text":"<pre><code>import value;\n\n// \u4fdd\u5b58\u65e7\u503c\uff08\u6570\u503c\uff0c\u81ea\u52a8\u8bbe\u7f6e\u6b63\u786e flag\uff09\nValue intValue;\nintValue.setScalarTyped&lt;int32_t&gt;(42);\n\n// \u521b\u5efa\u6d6e\u70b9\u7c7b\u578b\u7684 Value\nValue floatValue;\nfloatValue.setScalarTyped&lt;float&gt;(3.14159f);\n\n// \u4fdd\u5b58\u65e7\u503c\uff08\u539f\u59cb\u5b57\u8282\uff0c\u4e0d\u8bbe flag \u4e5f\u53ef\uff09\nValue byteArrayValue;\nstd::vector&lt;uint8_t&gt; bytes = {0x01,0x02,0x03,0x04};\nbyteArrayValue.setBytes(bytes);\n</code></pre>"},{"location":"value/#_8","title":"\u7c7b\u578b/\u6807\u5fd7\u68c0\u67e5","text":"<pre><code>// \u68c0\u67e5\u6807\u5fd7\nif (intValue.flags &amp; MatchFlags::INTEGER) {\n    std::cout &lt;&lt; \"\u8fd9\u662f\u4e00\u4e2a\u6574\u6570\u7c7b\u578b\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"value/#_9","title":"\u5b57\u8282\u6570\u7ec4\u64cd\u4f5c","text":"<pre><code>Value patternValue;\nstd::vector&lt;uint8_t&gt; pattern = {0xDE,0xAD,0xBE,0xEF};\npatternValue.setBytes(pattern);\nfor (auto b : patternValue.view()) { /* \u904d\u5386\u5b57\u8282 */ }\n</code></pre>"},{"location":"value/#_10","title":"\u5339\u914d\u64cd\u4f5c","text":"<p>\u5339\u914d\u903b\u8f91\u5728 <code>scanroutines</code> \u6a21\u5757\u4e2d\u5b9e\u73b0\uff1a - \u6570\u503c\uff1a\u4e25\u683c\u6309\u7167 <code>flags</code> \u4e0e\u7c7b\u578b\u5339\u914d\uff08\u89e3\u7801\u65e7\u503c\u65f6\u8981\u6c42\u7c7b\u578b\u4e00\u81f4\uff09\u3002 - \u5b57\u8282\u4e32/\u5b57\u7b26\u4e32\uff1a\u6ed1\u52a8\u641c\u7d22\uff1b\u53ef\u9009\u63a9\u7801\uff080xFF=\u7cbe\u786e\uff0c0x00=\u901a\u914d\uff09\uff1b\u5b57\u7b26\u4e32\u652f\u6301 Boost.Regex\u3002</p> <p>\u66f4\u591a\u5339\u914d\u793a\u4f8b\uff08\u8303\u56f4\u3001\u63a9\u7801\u3001\u6b63\u5219\uff09\u8bf7\u53c2\u8003 <code>scanroutines</code> \u6a21\u5757\u6587\u6863\u4e0e\u5b9e\u73b0\u3002</p>"},{"location":"value/#_11","title":"\u6027\u80fd\u4f18\u5316","text":""},{"location":"value/#_12","title":"\u5185\u5b58\u5e03\u5c40\u4f18\u5316","text":"<ol> <li>\u7d27\u51d1\u5b58\u50a8: \u4f7f\u7528 packed \u5c5e\u6027\u51cf\u5c11\u5185\u5b58\u5360\u7528</li> <li>\u7f13\u5b58\u53cb\u597d: \u8fde\u7eed\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f</li> <li>\u5bf9\u9f50\u4f18\u5316: \u9488\u5bf9\u76ee\u6807\u67b6\u6784\u4f18\u5316\u5bf9\u9f50</li> </ol>"},{"location":"value/#_13","title":"\u7c7b\u578b\u68c0\u67e5\u4f18\u5316","text":"<ol> <li>\u7f16\u8bd1\u65f6\u68c0\u67e5: \u4f7f\u7528 static_assert \u8fdb\u884c\u7f16\u8bd1\u65f6\u9a8c\u8bc1</li> <li>\u8fd0\u884c\u65f6\u4f18\u5316: \u9ad8\u6548\u7684\u7c7b\u578b\u68c0\u67e5\u7b97\u6cd5</li> <li>\u7f13\u5b58\u7ed3\u679c: \u7f13\u5b58\u9891\u7e41\u7684\u7c7b\u578b\u68c0\u67e5\u7ed3\u679c</li> </ol>"},{"location":"value/#_14","title":"\u8f6c\u6362\u4f18\u5316","text":"<ol> <li>\u96f6\u62f7\u8d1d: \u5c3d\u53ef\u80fd\u907f\u514d\u6570\u636e\u62f7\u8d1d</li> <li>\u5185\u8054\u51fd\u6570: \u4f7f\u7528\u5185\u8054\u51fd\u6570\u51cf\u5c11\u51fd\u6570\u8c03\u7528\u5f00\u9500</li> <li>SIMD \u4f18\u5316: \u5bf9\u5b57\u8282\u6570\u7ec4\u64cd\u4f5c\u4f7f\u7528 SIMD \u6307\u4ee4</li> </ol>"},{"location":"value/#_15","title":"\u9519\u8bef\u5904\u7406","text":""},{"location":"value/#_16","title":"\u7c7b\u578b\u9519\u8bef","text":"<p>\u6570\u503c\u8def\u5f84\u4e0b\uff0c\u65e7\u503c\u89e3\u7801\u65f6\u8981\u6c42 <code>flags</code> \u4e0e\u671f\u671b\u7c7b\u578b\u4e00\u81f4\u4e14\u957f\u5ea6\u8db3\u591f\uff0c\u5426\u5219\u4e0a\u5c42\u5e94\u5f53\u653e\u5f03\u89e3\u7801\u3002</p>"},{"location":"value/#_17","title":"\u8303\u56f4\u9519\u8bef","text":"<p>\u4e0a\u5c42\u5e94\u6839\u636e <code>flags</code> \u63a8\u65ad\u5bbd\u5ea6\u5e76\u8fdb\u884c\u8fb9\u754c\u68c0\u67e5\uff0c<code>Value</code> \u672c\u8eab\u4ec5\u63d0\u4f9b\u5b57\u8282\u89c6\u56fe\u4e0e\u6807\u5fd7\uff0c\u4e0d\u76f4\u63a5\u8fdb\u884c\u8303\u56f4\u5224\u65ad\u3002</p>"},{"location":"value/#_18","title":"\u6269\u5c55\u6027","text":""},{"location":"value/#_19","title":"\u81ea\u5b9a\u4e49\u7c7b\u578b","text":"<pre><code>// \u6dfb\u52a0\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b\nenum class CustomMatchFlags : uint16_t {\n    CUSTOM_TYPE_1 = 1 &lt;&lt; 10,\n    CUSTOM_TYPE_2 = 1 &lt;&lt; 11,\n};\n\n// \u6269\u5c55 Value \u7ed3\u6784\nstruct ExtendedValue : public Value {\n    CustomMatchFlags customFlags = CustomMatchFlags::CUSTOM_TYPE_1;\n    std::string additionalData;\n};\n</code></pre>"},{"location":"value/#_20","title":"\u63d2\u4ef6\u7cfb\u7edf","text":"<pre><code>// \u503c\u5904\u7406\u63d2\u4ef6\u63a5\u53e3\nclass ValueProcessor {\npublic:\n    virtual bool process(Value&amp; val) = 0;\n    virtual std::string getDescription() const = 0;\n};\n\n// \u5177\u4f53\u5b9e\u73b0\nclass CustomValueProcessor : public ValueProcessor {\npublic:\n    bool process(Value&amp; val) override {\n        // \u81ea\u5b9a\u4e49\u5904\u7406\u903b\u8f91\n        return true;\n    }\n\n    std::string getDescription() const override {\n        return \"\u81ea\u5b9a\u4e49\u503c\u5904\u7406\u5668\";\n    }\n};\n</code></pre>"},{"location":"en/","title":"Start","text":"<p>Welcome to the NewScanmem documentation site! This site provides detailed information about the project, including its features, usage, and API references.</p>"},{"location":"en/#about-newscanmem","title":"About NewScanmem","text":"<p>NewScanmem is a modernized version of the <code>scanmem</code> tool, rebuilt using C++20 modules. It is designed for memory scanning and debugging processes on Linux systems.</p>"},{"location":"en/#key-features","title":"Key Features","text":"<ul> <li>C++20 Modules: Improved code organization and compilation speed.</li> <li>Boost Integration: Enhanced file and string handling.</li> <li>High Performance: Optimized memory scanning algorithms.</li> </ul>"},{"location":"en/API_REFERENCE/","title":"API Reference","text":""},{"location":"en/API_REFERENCE/#module-index","title":"Module Index","text":"<ul> <li>endianness</li> <li>maps</li> <li>process_checker</li> <li>sets</li> <li>show_message</li> <li>targetmem</li> <li>value</li> </ul>"},{"location":"en/API_REFERENCE/#enum-region_type","title":"Enum: <code>region_type</code>","text":"<pre><code>enum class region_type : uint8_t {\n    misc,   // Miscellaneous memory regions\n    exe,    // Executable binary regions\n    code,   // Code segments (shared libraries, etc.)\n    heap,   // Heap memory regions\n    stack   // Stack memory regions\n};\n\nconstexpr std::array&lt;std::string_view, 5&gt; region_type_names;\n</code></pre>"},{"location":"en/API_REFERENCE/#enum-region_scan_level","title":"Enum: <code>region_scan_level</code>","text":"<pre><code>enum class region_scan_level : uint8_t {\n    all,                       // All readable regions\n    all_rw,                    // All readable/writable regions\n    heap_stack_executable,     // Heap, stack, and executable regions\n    heap_stack_executable_bss  // Above plus BSS segments\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#struct-region_flags","title":"Struct: <code>region_flags</code>","text":"<pre><code>struct region_flags {\n    bool read : 1;    // Read permission\n    bool write : 1;   // Write permission\n    bool exec : 1;    // Execute permission\n    bool shared : 1;  // Shared mapping\n    bool private_ : 1; // Private mapping\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#struct-region","title":"Struct: <code>region</code>","text":"<pre><code>struct region {\n    void* start;           // Starting address\n    std::size_t size;      // Region size in bytes\n    region_type type;      // Region classification\n    region_flags flags;    // Permission flags\n    void* load_addr;       // Load address for ELF files\n    std::string filename;  // Associated file path\n    std::size_t id;        // Unique identifier\n\n    [[nodiscard]] bool is_readable() const noexcept;\n    [[nodiscard]] bool is_writable() const noexcept;\n    [[nodiscard]] bool is_executable() const noexcept;\n    [[nodiscard]] bool is_shared() const noexcept;\n    [[nodiscard]] bool is_private() const noexcept;\n    [[nodiscard]] std::pair&lt;void*, std::size_t&gt; as_span() const noexcept;\n    [[nodiscard]] bool contains(void* address) const noexcept;\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#struct-maps_readererror","title":"Struct: <code>maps_reader::error</code>","text":"<pre><code>struct error {\n    std::string message;   // Human-readable error description\n    std::error_code code;  // System error code\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#class-maps_reader","title":"Class: <code>maps_reader</code>","text":""},{"location":"en/API_REFERENCE/#static-methods","title":"Static Methods","text":"<pre><code>[[nodiscard]] static std::expected&lt;std::vector&lt;region&gt;, error&gt; \nread_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);\n</code></pre>"},{"location":"en/API_REFERENCE/#convenience-functions","title":"Convenience Functions","text":"<pre><code>[[nodiscard]] std::expected&lt;std::vector&lt;region&gt;, maps_reader::error&gt; \nread_process_maps(pid_t pid, region_scan_level level = region_scan_level::all);\n</code></pre>"},{"location":"en/API_REFERENCE/#usage-examples","title":"Usage Examples","text":"<pre><code>import maps;\n\n// Basic usage\nauto regions = maps::read_process_maps(1234);\n\n// Filtered scanning\nauto heap_regions = maps::read_process_maps(\n    pid, \n    maps::region_scan_level::heap_stack_executable\n);\n\n// Error handling\nif (!regions) {\n    std::cerr &lt;&lt; \"Error: \" &lt;&lt; regions.error().message &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"en/API_REFERENCE/#namespace-endianness","title":"Namespace: <code>endianness</code>","text":""},{"location":"en/API_REFERENCE/#functions","title":"Functions","text":"<pre><code>// Endianness detection\nconstexpr bool is_big_endian() noexcept;\nconstexpr bool is_little_endian() noexcept;\n\n// Byte swapping\nconstexpr uint8_t swap_bytes(uint8_t value) noexcept;\nconstexpr uint16_t swap_bytes(uint16_t value) noexcept;\nconstexpr uint32_t swap_bytes(uint32_t value) noexcept;\nconstexpr uint64_t swap_bytes(uint64_t value) noexcept;\n\ntemplate&lt;typename T&gt;\nconstexpr T swap_bytes_integral(T value) noexcept;\n\nvoid swap_bytes_inplace(void* data, size_t size);\n\n// Endianness correction\nvoid fix_endianness(Value&amp; value, bool reverse_endianness) noexcept;\n\n// Network byte order\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T host_to_network(T value) noexcept;\n\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T network_to_host(T value) noexcept;\n\n// Little-endian conversion\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T host_to_little_endian(T value) noexcept;\n\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T little_endian_to_host(T value) noexcept;\n</code></pre>"},{"location":"en/API_REFERENCE/#concept","title":"Concept","text":"<pre><code>template&lt;typename T&gt;\nconcept SwappableIntegral = std::integral&lt;T&gt; &amp;&amp; \n    (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8);\n</code></pre>"},{"location":"en/API_REFERENCE/#enum-processstate","title":"Enum: <code>ProcessState</code>","text":"<pre><code>enum class ProcessState { RUNNING, ERROR, DEAD, ZOMBIE };\n</code></pre>"},{"location":"en/API_REFERENCE/#class-processchecker","title":"Class: <code>ProcessChecker</code>","text":""},{"location":"en/API_REFERENCE/#processchecker-static-methods","title":"ProcessChecker Static Methods","text":"<pre><code>static ProcessState check_process(pid_t pid);\nstatic bool is_process_dead(pid_t pid);\n</code></pre>"},{"location":"en/API_REFERENCE/#struct-set","title":"Struct: <code>Set</code>","text":"<pre><code>struct Set {\n    std::vector&lt;size_t&gt; buf;\n\n    size_t size() const;\n    void clear();\n    static int cmp(const size_t&amp; i1, const size_t&amp; i2);\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#set-functions","title":"Set Functions","text":"<pre><code>bool parse_uintset(std::string_view lptr, Set&amp; set, size_t maxSZ);\n</code></pre>"},{"location":"en/API_REFERENCE/#deprecated","title":"Deprecated","text":"<pre><code>[[deprecated]] constexpr auto inc_arr_sz = \n    [](size_t** valarr, size_t* arr_maxsz, size_t maxsz) -&gt; bool;\n</code></pre>"},{"location":"en/API_REFERENCE/#enum-messagetype","title":"Enum: <code>MessageType</code>","text":"<pre><code>enum class MessageType : uint8_t { INFO, WARN, ERROR, DEBUG, USER };\n</code></pre>"},{"location":"en/API_REFERENCE/#struct-messagecontext","title":"Struct: <code>MessageContext</code>","text":"<pre><code>struct MessageContext {\n    bool debugMode = false;\n    bool backendMode = false;\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#class-messageprinter","title":"Class: <code>MessagePrinter</code>","text":""},{"location":"en/API_REFERENCE/#constructor","title":"Constructor","text":"<pre><code>MessagePrinter(MessageContext ctx = {});\n</code></pre>"},{"location":"en/API_REFERENCE/#methods","title":"Methods","text":"<pre><code>template&lt;typename... Args&gt;\nvoid print(MessageType type, std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid info(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid warn(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid error(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid debug(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid user(std::string_view fmt, Args&amp;&amp;... args) const;\n\n[[nodiscard]] const MessageContext&amp; conext() const;\n</code></pre>"},{"location":"en/API_REFERENCE/#struct-oldvalueandmatchinfo","title":"Struct: <code>OldValueAndMatchInfo</code>","text":"<pre><code>struct OldValueAndMatchInfo {\n    uint8_t old_value;\n    MatchFlags match_info;\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#class-matchesandoldvaluesswath","title":"Class: <code>MatchesAndOldValuesSwath</code>","text":"<pre><code>class MatchesAndOldValuesSwath {\npublic:\n    void* firstByteInChild = nullptr;\n    std::vector&lt;OldValueAndMatchInfo&gt; data;\n\n    MatchesAndOldValuesSwath() = default;\n\n    void addElement(void* addr, uint8_t byte, MatchFlags matchFlags);\n    std::string toPrintableString(size_t idx, size_t len) const;\n    std::string toByteArrayText(size_t idx, size_t len) const;\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#class-matchesandoldvaluesarray","title":"Class: <code>MatchesAndOldValuesArray</code>","text":"<pre><code>class MatchesAndOldValuesArray {\npublic:\n    size_t maxNeededBytes;\n    std::vector&lt;MatchesAndOldValuesSwath&gt; swaths;\n\n    MatchesAndOldValuesArray(size_t maxBytes);\n\n    void addSwath(const MatchesAndOldValuesSwath&amp; swath);\n    std::optional&lt;std::pair&lt;MatchesAndOldValuesSwath*, size_t&gt;&gt; nthMatch(size_t n);\n    void deleteInAddressRange(void* start, void* end, unsigned long&amp; numMatches);\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#enum-matchflags","title":"Enum: <code>MatchFlags</code>","text":"<pre><code>enum class [[gnu::packed]] MatchFlags : uint16_t {\n    EMPTY = 0,\n    U8B = 1 &lt;&lt; 0, S8B = 1 &lt;&lt; 1,\n    U16B = 1 &lt;&lt; 2, S16B = 1 &lt;&lt; 3,\n    U32B = 1 &lt;&lt; 4, S32B = 1 &lt;&lt; 5,\n    U64B = 1 &lt;&lt; 6, S64B = 1 &lt;&lt; 7,\n    F32B = 1 &lt;&lt; 8, F64B = 1 &lt;&lt; 9,\n    I8B = U8B | S8B, I16B = U16B | S16B,\n    I32B = U32B | S32B, I64B = U64B | S64B,\n    INTEGER = I8B | I16B | I32B | I64B,\n    FLOAT = F32B | F64B,\n    ALL = INTEGER | FLOAT,\n    B8 = I8B, B16 = I16B,\n    B32 = I32B | F32B, B64 = I64B | F64B,\n    MAX = 0xffffU\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#enum-wildcard","title":"Enum: <code>Wildcard</code>","text":"<pre><code>enum class Wildcard : uint8_t { FIXED = 0xffU, WILDCARD = 0x00U };\n</code></pre>"},{"location":"en/API_REFERENCE/#struct-value","title":"Struct: <code>Value</code>","text":"<pre><code>struct [[gnu::packed]] Value {\n    std::vector&lt;uint8_t&gt; bytes;     // Snapshot bytes\n    MatchFlags flags = MatchFlags::EMPTY; // Type/width flag\n\n    constexpr static void zero(Value&amp; val);\n\n    std::span&lt;const uint8_t&gt; view() const noexcept;\n    void setBytes(const uint8_t* data, std::size_t len);\n    void setBytes(const std::vector&lt;uint8_t&gt;&amp; val);\n    void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f);\n    void setBytesWithFlag(const std::vector&lt;uint8_t&gt;&amp; val, MatchFlags f);\n    template &lt;typename T&gt; void setScalar(const T&amp; v);\n    template &lt;typename T&gt; void setScalarWithFlag(const T&amp; v, MatchFlags f);\n    template &lt;typename T&gt; void setScalarTyped(const T&amp; v);\n};\n</code></pre> <p>Strict numeric decoding: the requested type must match <code>flags</code> and width must be sufficient.</p>"},{"location":"en/API_REFERENCE/#struct-mem64","title":"Struct: <code>Mem64</code>","text":"<pre><code>struct [[gnu::packed]] Mem64 {\n    std::vector&lt;uint8_t&gt; buffer;    // Current bytes\n\n    template &lt;typename T&gt; T get() const;              // memcpy-based decode\n    std::span&lt;const uint8_t&gt; bytes() const noexcept;  // read-only view\n    void setBytes(const uint8_t* data, std::size_t len);\n    void setBytes(const std::vector&lt;uint8_t&gt;&amp; data);\n    void setString(const std::string&amp; s);\n    template &lt;typename T&gt; void setScalar(const T&amp; v);\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#struct-uservalue","title":"Struct: <code>UserValue</code>","text":"<pre><code>struct [[gnu::packed]] UserValue {\n    int8_t int8_value = 0;\n    uint8_t uint8_value = 0;\n    int16_t int16_value = 0;\n    uint16_t uint16_value = 0;\n    int32_t int32_value = 0;\n    uint32_t uint32_value = 0;\n    int64_t int64_value = 0;\n    uint64_t uint64_value = 0;\n    float float32_value = 0.0F;\n    double float64_value = 0.0;\n    std::optional&lt;std::vector&lt;uint8_t&gt;&gt; bytearray_value;\n    std::optional&lt;std::vector&lt;uint8_t&gt;&gt; byteMask; // 0xFF=fixed, 0x00=wildcard\n    std::optional&lt;Wildcard&gt; wildcard_value;\n    std::string string_value;\n    MatchFlags flags = MatchFlags::EMPTY;\n};\n</code></pre>"},{"location":"en/API_REFERENCE/#usage-patterns","title":"Usage Patterns","text":""},{"location":"en/API_REFERENCE/#common-patterns","title":"Common Patterns","text":""},{"location":"en/API_REFERENCE/#1-process-checking","title":"1. Process Checking","text":"<pre><code>auto state = ProcessChecker::check_process(pid);\nif (state == ProcessState::RUNNING) { /* ... */ }\n</code></pre>"},{"location":"en/API_REFERENCE/#2-set-parsing","title":"2. Set Parsing","text":"<pre><code>Set mySet;\nif (parse_uintset(\"1,2,3,10..15\", mySet, 100)) {\n    // Use parsed set\n}\n</code></pre>"},{"location":"en/API_REFERENCE/#3-message-printing","title":"3. Message Printing","text":"<pre><code>MessagePrinter printer{.debugMode = true};\nprinter.info(\"Process {} is running\", pid);\nprinter.error(\"Failed to read memory at 0x{:08x}\", address);\n</code></pre>"},{"location":"en/API_REFERENCE/#4-memory-analysis","title":"4. Memory Analysis","text":"<pre><code>MatchesAndOldValuesArray matches(4096);\nMatchesAndOldValuesSwath swath;\nswath.addElement(addr, byte, MatchFlags::U32B);\nmatches.addSwath(swath);\n</code></pre>"},{"location":"en/API_REFERENCE/#5-value-handling","title":"5. Value Handling","text":"<pre><code>Value val = uint32_t{42};\nval.flags = MatchFlags::U32B;\n\nMem64 mem64;\nmem64.set&lt;double&gt;(3.14159);\nauto value = mem64.get&lt;double&gt;();\n</code></pre>"},{"location":"en/API_REFERENCE/#error-handling","title":"Error Handling","text":""},{"location":"en/API_REFERENCE/#return-values","title":"Return Values","text":"<ul> <li><code>parse_uintset</code>: Returns <code>bool</code> (true/false)</li> <li><code>nthMatch</code>: Returns <code>std::optional</code></li> <li><code>check_process</code>: Returns <code>ProcessState</code></li> </ul>"},{"location":"en/API_REFERENCE/#exceptions","title":"Exceptions","text":"<ul> <li><code>Mem64::get&lt;T&gt;()</code>: Throws <code>std::bad_variant_access</code> on type mismatch</li> <li>Format strings: Throw appropriate exceptions on format errors</li> </ul>"},{"location":"en/NamingConvention/","title":"C++ Naming Conventions","text":""},{"location":"en/NamingConvention/#1-classes-and-structures","title":"1. Classes and Structures","text":"<ul> <li>Class Names: Use <code>CamelCase</code> style.</li> <li> <p>Example:</p> <p><code>cpp class MyClassName {};</code></p> </li> <li> <p>Structure Names: Use <code>CamelCase</code> style.</p> </li> <li> <p>Example:</p> <p><code>cpp struct MyStructName {};</code></p> </li> </ul>"},{"location":"en/NamingConvention/#2-enums","title":"2. Enums","text":"<ul> <li>Enum Type Names: Use <code>CamelCase</code> style.</li> <li> <p>Example:</p> <p><code>cpp enum MyEnumType {};</code></p> </li> <li> <p>Enum Constant Names: Use <code>UPPER_CASE</code> style.</p> </li> <li> <p>Example:</p> <p><code>cpp enum MyEnumType {     ENUM_CONSTANT_ONE,     ENUM_CONSTANT_TWO };</code></p> </li> </ul>"},{"location":"en/NamingConvention/#3-functions","title":"3. Functions","text":"<ul> <li>Function Names: Use <code>camelBack</code> style.</li> <li> <p>Example:</p> <p><code>cpp void myFunctionName();</code></p> </li> </ul>"},{"location":"en/NamingConvention/#4-variables","title":"4. Variables","text":"<ul> <li>Regular Variable Names: Use <code>camelBack</code> style.</li> <li> <p>Example:</p> <p><code>cpp int myVariableName;</code></p> </li> <li> <p>Global Variable Names: Use <code>UPPER_CASE</code> style.</p> </li> <li> <p>Example:</p> <p><code>cpp int GLOBAL_VARIABLE_NAME;</code></p> </li> <li> <p>Constant Names: Use <code>UPPER_CASE</code> style.</p> </li> <li> <p>Example:</p> <p><code>cpp const int MAX_BUFFER_SIZE = 1024;</code></p> </li> </ul>"},{"location":"en/NamingConvention/#5-parameters","title":"5. Parameters","text":"<ul> <li>Function Parameter Names: Use <code>camelBack</code> style.</li> <li> <p>Example:</p> <p><code>cpp void myFunction(int parameterName);</code></p> </li> </ul>"},{"location":"en/NamingConvention/#6-namespaces","title":"6. Namespaces","text":"<ul> <li>Namespace Names: Use <code>lower_case</code> style.</li> <li> <p>Example:</p> <p><code>cpp namespace my_namespace {     void myFunction(); }</code></p> </li> </ul>"},{"location":"en/NamingConvention/#7-macros","title":"7. Macros","text":"<ul> <li>Macro Names: Use <code>UPPER_CASE</code> style.</li> <li> <p>Example:</p> <p>```cpp</p> </li> </ul>"},{"location":"en/NamingConvention/#8-member-variables","title":"8. Member Variables","text":"<ul> <li>Private Member Variables: Prefix with <code>m_</code> and use <code>camelBack</code> style.</li> <li> <p>Example:</p> <p><code>cpp class MyClass { private:     int m_privateMember; };</code></p> </li> <li> <p>Protected Member Variables: Prefix with <code>m_</code> and use <code>camelBack</code> style.</p> </li> <li> <p>Example:</p> <p><code>cpp class MyClass { protected:     int m_protectedMember; };</code></p> </li> <li> <p>Static Member Variables: Prefix with <code>s_</code> and use <code>camelBack</code> style.</p> </li> <li> <p>Example:</p> <p><code>cpp class MyClass { private:     static int s_staticMember; };</code></p> </li> <li> <p>Public Member Variables: Use <code>camelBack</code> style.</p> </li> <li> <p>Example:</p> <p><code>cpp class MyClass { public:     int publicMemberVariable; };</code></p> </li> </ul>"},{"location":"en/NamingConvention/#9-special-rules","title":"9. Special Rules","text":"<ul> <li>Disabled Rules:</li> <li>Disable <code>modernize-use-trailing-return-type</code>.</li> <li>Disable <code>modernize-avoid-c-arrays</code>.</li> </ul>"},{"location":"en/endianness/","title":"Endianness Module Documentation","text":""},{"location":"en/endianness/#overview","title":"Overview","text":"<p>The <code>endianness</code> module provides comprehensive byte order handling utilities for the NewScanmem project. It supports both compile-time and runtime endianness detection, byte swapping operations, and automatic endianness correction for various data types.</p>"},{"location":"en/endianness/#module-structure","title":"Module Structure","text":"<pre><code>export module endianness;\n</code></pre>"},{"location":"en/endianness/#dependencies","title":"Dependencies","text":"<ul> <li><code>&lt;cstdint&gt;</code> - Fixed-width integer types</li> <li><code>&lt;cstring&gt;</code> - C string operations</li> <li><code>&lt;bit&gt;</code> - Bit operations and endian detection</li> <li><code>&lt;type_traits&gt;</code> - Type traits for template metaprogramming</li> <li><code>&lt;concepts&gt;</code> - C++20 concepts</li> <li><code>value</code> module - Value type definitions</li> </ul>"},{"location":"en/endianness/#core-features","title":"Core Features","text":""},{"location":"en/endianness/#1-endianness-detection","title":"1. Endianness Detection","text":""},{"location":"en/endianness/#compile-time-detection","title":"Compile-time Detection","text":"<pre><code>constexpr bool isBigEndian() noexcept;\nconstexpr bool isLittleEndian() noexcept;\n</code></pre> <p>Uses <code>std::endian::native</code> to determine host endianness at compile time.</p>"},{"location":"en/endianness/#2-byte-swapping-functions","title":"2. Byte Swapping Functions","text":""},{"location":"en/endianness/#basic-byte-swapping","title":"Basic Byte Swapping","text":"<pre><code>constexpr uint8_t swapBytes(uint8_t value) noexcept;\nconstexpr uint16_t swapBytes(uint16_t value) noexcept;\nconstexpr uint32_t swapBytes(uint32_t value) noexcept;\nconstexpr uint64_t swapBytes(uint64_t value) noexcept;\n</code></pre>"},{"location":"en/endianness/#generic-byte-swapping","title":"Generic Byte Swapping","text":"<pre><code>template&lt;typename T&gt;\nconstexpr T swapBytesIntegral(T value) noexcept;\n</code></pre> <p>Supports integer types of sizes 1, 2, 4, and 8 bytes.</p>"},{"location":"en/endianness/#3-endianness-correction-for-value-types","title":"3. Endianness Correction for Value Types","text":"<pre><code>void fixEndianness(Value&amp; value, bool reverseEndianness) noexcept;\n</code></pre> <p>Performs in-place endianness correction on <code>Value.bytes</code> based on <code>flags</code> (width 2/4/8).</p>"},{"location":"en/endianness/#4-network-byte-order-conversion","title":"4. Network Byte Order Conversion","text":"<pre><code>template&lt;SwappableIntegral T&gt;\nconstexpr T hostToNetwork(T value) noexcept;\n\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T networkToHost(T value) noexcept;\n</code></pre> <p>Converts between host and network byte order (big-endian).</p>"},{"location":"en/endianness/#5-little-endian-conversion","title":"5. Little-endian Conversion","text":"<pre><code>template&lt;SwappableIntegral T&gt;\nconstexpr T hostToLittleEndian(T value) noexcept;\n\ntemplate&lt;SwappableIntegral T&gt;\nconstexpr T littleEndianToHost(T value) noexcept;\n</code></pre>"},{"location":"en/endianness/#usage-examples","title":"Usage Examples","text":""},{"location":"en/endianness/#examples-basic-byte-swapping","title":"Examples Basic Byte Swapping","text":"<pre><code>import endianness;\n\nuint32_t value = 0x12345678;\nuint32_t swapped = endianness::swapBytes(value);\n// swapped = 0x78563412 on little-endian systems\n</code></pre>"},{"location":"en/endianness/#endianness-correction","title":"Endianness Correction","text":"<pre><code>import endianness;\nimport value;\n\nValue val = uint32_t{0x12345678};\nendianness::fixEndianness(val, true);  // Reverse endianness\n</code></pre>"},{"location":"en/endianness/#network-communication","title":"Network Communication","text":"<pre><code>uint16_t port = 8080;\nuint16_t networkPort = endianness::hostToNetwork(port);\n</code></pre>"},{"location":"en/endianness/#concepts-and-constraints","title":"Concepts and Constraints","text":""},{"location":"en/endianness/#swappableintegral-concept","title":"SwappableIntegral Concept","text":"<pre><code>template&lt;typename T&gt;\nconcept SwappableIntegral = std::integral&lt;T&gt; &amp;&amp; \n    (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8);\n</code></pre> <p>Restricts byte swapping operations to integral types of specific sizes.</p>"},{"location":"en/endianness/#implementation-details","title":"Implementation Details","text":""},{"location":"en/endianness/#byte-swapping-algorithms","title":"Byte Swapping Algorithms","text":"<ul> <li>16-bit: Uses bit rotation: <code>(value &lt;&lt; 8) | (value &gt;&gt; 8)</code></li> <li>32-bit: Uses bit masking and shifting for optimal performance</li> <li>64-bit: Uses bit masking and shifting across 8 bytes</li> </ul>"},{"location":"en/endianness/#compile-time-optimization","title":"Compile-time Optimization","text":"<p>All byte swapping operations are marked <code>constexpr</code> for compile-time evaluation when possible.</p>"},{"location":"en/endianness/#type-safety","title":"Type Safety","text":"<p>Uses C++20 concepts to ensure type safety and provide clear error messages for unsupported types.</p>"},{"location":"en/endianness/#error-handling","title":"Error Handling","text":"<ul> <li><code>swapBytesIntegral</code> uses <code>static_assert</code> for compile-time type checking</li> <li><code>swapBytesInPlace</code> silently ignores unsupported sizes</li> <li><code>fixEndianness</code> infers width from <code>flags</code> (B16/B32/B64) and swaps <code>Value.bytes</code> in place</li> </ul>"},{"location":"en/endianness/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>All operations are constexpr for compile-time optimization</li> <li>Byte swapping uses efficient bit manipulation operations</li> <li>No dynamic memory allocation</li> <li>Minimal runtime overhead for supported types</li> </ul>"},{"location":"en/endianness/#integration-with-cli","title":"Integration with CLI","text":"<p>The <code>endianness</code> module is utilized in the CLI for automatic byte order handling during memory scanning operations. For example, the <code>scan</code> command leverages this module to ensure correct endianness for target values.</p>"},{"location":"en/endianness/#see-also","title":"See Also","text":"<ul> <li>Value Module - For Value type definitions</li> <li>Target Memory Module - For memory analysis operations</li> </ul>"},{"location":"en/main/","title":"Main Application Documentation","text":""},{"location":"en/main/#overview","title":"Overview","text":"<p>The <code>main.cpp</code> file serves as the entry point for the NewScanmem application. It demonstrates basic module integration and provides a foundation for the memory scanning utility.</p>"},{"location":"en/main/#file-structure","title":"File Structure","text":"<pre><code>import sets;\n\nint main() {\n    Set val;\n    return 0;\n}\n</code></pre>"},{"location":"en/main/#current-implementation","title":"Current Implementation","text":"<p>The current main function is minimal and serves as a placeholder for:</p> <ol> <li>Module Integration Testing: Demonstrates that the <code>sets</code> module can be successfully imported and used</li> <li>Basic Framework: Provides a starting point for application development</li> <li>Compilation Verification: Ensures all modules compile correctly together</li> </ol>"},{"location":"en/main/#planned-features","title":"Planned Features","text":""},{"location":"en/main/#command-line-interface","title":"Command Line Interface","text":"<pre><code>// Future implementation\nint main(int argc, char* argv[]) {\n    // Parse command line arguments\n    // Initialize modules\n    // Start memory scanning\n    // Display results\n}\n</code></pre>"},{"location":"en/main/#integration-points","title":"Integration Points","text":"<p>The main application will integrate all modules:</p> <ol> <li>Process Management (process_checker)</li> <li>Target process selection</li> <li>Process state monitoring</li> <li> <p>Permission checking</p> </li> <li> <p>Memory Analysis (targetmem)</p> </li> <li>Memory region scanning</li> <li>Value matching</li> <li> <p>Pattern detection</p> </li> <li> <p>Data Types (value)</p> </li> <li>Multi-type value support</li> <li>Endianness handling</li> <li> <p>Byte array operations</p> </li> <li> <p>Utilities (sets, endianness, show_message)</p> </li> <li>Set operations for results</li> <li>Byte order conversion</li> <li>User messaging and logging</li> </ol>"},{"location":"en/main/#usage-examples","title":"Usage Examples","text":""},{"location":"en/main/#basic-execution","title":"Basic Execution","text":"<pre><code># Current usage\n./newscanmem\n\n# Future usage examples\n./newscanmem --pid 1234 --type int32 --value 42\n./newscanmem --pid 1234 --range 0x1000-0x2000 --string \"hello\"\n./newscanmem --pid 1234 --float --tolerance 0.001\n</code></pre>"},{"location":"en/main/#development-roadmap","title":"Development Roadmap","text":""},{"location":"en/main/#phase-1-basic-framework","title":"Phase 1: Basic Framework","text":"<ul> <li>[ ] Command line argument parsing</li> <li>[ ] Process selection and validation</li> <li>[ ] Basic memory scanning</li> <li>[ ] Result display</li> </ul>"},{"location":"en/main/#phase-2-advanced-features","title":"Phase 2: Advanced Features","text":"<ul> <li>[ ] Multiple value type support</li> <li>[ ] Memory region filtering</li> <li>[ ] Pattern matching</li> <li>[ ] Interactive mode</li> </ul>"},{"location":"en/main/#phase-3-optimization","title":"Phase 3: Optimization","text":"<ul> <li>[ ] Performance tuning</li> <li>[ ] Memory usage optimization</li> <li>[ ] Parallel processing</li> <li>[ ] Result caching</li> </ul>"},{"location":"en/main/#phase-4-uiux","title":"Phase 4: UI/UX","text":"<ul> <li>[ ] Progress indicators</li> <li>[ ] Color output</li> <li>[ ] Export formats</li> <li>[ ] Configuration files</li> </ul>"},{"location":"en/main/#module-integration-example","title":"Module Integration Example","text":"<pre><code>// Future main.cpp structure\nimport process_checker;\nimport targetmem;\nimport value;\nimport show_message;\nimport sets;\nimport endianness;\n\nint main(int argc, char* argv[]) {\n    MessagePrinter printer;\n\n    // Parse arguments\n    if (argc &lt; 2) {\n        printer.error(\"Usage: {} --pid &lt;pid&gt; [...]\", argv[0]);\n        return 1;\n    }\n\n    // Check process\n    pid_t pid = std::stoi(argv[2]);\n    if (ProcessChecker::is_process_dead(pid)) {\n        printer.error(\"Process {} is not running\", pid);\n        return 1;\n    }\n\n    // Initialize scanner\n    printer.info(\"Scanning process {}...\", pid);\n\n    // Perform scan\n    MatchesAndOldValuesArray matches(get_memory_size(pid));\n    // ... scanning logic ...\n\n    // Display results\n    printer.info(\"Found {} matches\", get_total_matches(matches));\n\n    return 0;\n}\n</code></pre>"},{"location":"en/main/#build-instructions","title":"Build Instructions","text":""},{"location":"en/main/#current-build","title":"Current Build","text":"<pre><code># Build the project\nmkdir build &amp;&amp; cd build\ncmake ..\nmake\n\n# Run the application\n./newscanmem\n</code></pre>"},{"location":"en/main/#module-dependencies","title":"Module Dependencies","text":"<p>The main application depends on all modules:</p> <ul> <li><code>sets</code> - Set operations and parsing</li> <li><code>process_checker</code> - Process state checking  </li> <li><code>targetmem</code> - Memory analysis structures</li> <li><code>value</code> - Value type definitions</li> <li><code>endianness</code> - Byte order handling</li> <li><code>show_message</code> - Message and logging system</li> </ul>"},{"location":"en/main/#testing-framework","title":"Testing Framework","text":""},{"location":"en/main/#unit-tests","title":"Unit Tests","text":"<pre><code>// Test basic functionality\nvoid test_main_integration() {\n    Set test_set;\n    bool parse_result = parse_uintset(\"1,2,3\", test_set, 100);\n    assert(parse_result == true);\n    assert(test_set.size() == 3);\n\n    std::cout &lt;&lt; \"Main integration test passed!\\n\";\n}\n\nint main() {\n    test_main_integration();\n    return 0;\n}\n</code></pre>"},{"location":"en/main/#configuration","title":"Configuration","text":""},{"location":"en/main/#environment-variables","title":"Environment Variables","text":"<p>Future versions may support:</p> <ul> <li><code>SCANMEM_DEBUG</code>: Enable debug mode</li> <li><code>SCANMEM_BACKEND</code>: Enable backend mode</li> <li><code>SCANMEM_LOG_FILE</code>: Log file path</li> </ul>"},{"location":"en/main/#configuration-files","title":"Configuration Files","text":"<pre><code># ~/.scanmemrc example\n[general]\ndebug=true\nbackend=false\n\n[scanning]\ndefault_type=int32\nbatch_size=1000\ntimeout=30\n</code></pre>"},{"location":"en/main/#error-handling","title":"Error Handling","text":""},{"location":"en/main/#current-error-handling","title":"Current Error Handling","text":"<p>The current implementation provides minimal error handling through:</p> <ul> <li>Module import verification</li> <li>Basic compilation checks</li> <li>Placeholder return codes</li> </ul>"},{"location":"en/main/#future-error-handling","title":"Future Error Handling","text":"<pre><code>enum class ScanError {\n    SUCCESS = 0,\n    INVALID_PID,\n    PROCESS_NOT_FOUND,\n    PERMISSION_DENIED,\n    MEMORY_ACCESS_FAILED,\n    INVALID_ARGUMENTS,\n    OUT_OF_MEMORY\n};\n\nScanError perform_scan(const ScanConfig&amp; config);\n</code></pre>"},{"location":"en/main/#security-considerations","title":"Security Considerations","text":""},{"location":"en/main/#current-security","title":"Current Security","text":"<ul> <li>No elevated privileges required</li> <li>Read-only memory access</li> <li>Process permission validation</li> </ul>"},{"location":"en/main/#future-security","title":"Future Security","text":"<ul> <li>Capability checking</li> <li>Sandboxing considerations</li> <li>Secure memory access patterns</li> <li>Input validation</li> </ul>"},{"location":"en/main/#performance-metrics","title":"Performance Metrics","text":""},{"location":"en/main/#current-metrics","title":"Current Metrics","text":"<ul> <li>Compilation time: ~2-3 seconds</li> <li>Binary size: ~50KB (minimal)</li> <li>Memory usage: ~1MB (minimal)</li> </ul>"},{"location":"en/main/#target-metrics","title":"Target Metrics","text":"<ul> <li>Scan speed: 1GB/sec for basic types</li> <li>Memory usage: &lt;100MB for large processes</li> <li>Response time: &lt;1 second for initial results</li> </ul>"},{"location":"en/main/#platform-compatibility","title":"Platform Compatibility","text":""},{"location":"en/main/#current-support","title":"Current Support","text":"<ul> <li>Linux: Full support (primary platform)</li> <li>macOS: Planned support</li> <li>Windows: Not currently supported</li> </ul>"},{"location":"en/main/#system-requirements","title":"System Requirements","text":"<ul> <li>OS: Linux with /proc filesystem</li> <li>Compiler: C++23 with modules support</li> <li>Memory: 64MB minimum, 1GB recommended</li> <li>Permissions: Read access to target process memory</li> </ul>"},{"location":"en/main/#debugging","title":"Debugging","text":""},{"location":"en/main/#debug-build","title":"Debug Build","text":"<pre><code># Build with debug symbols\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake\n\n# Run with debugger\ngdb ./newscanmem\n(gdb) run --pid 1234\n</code></pre>"},{"location":"en/main/#logging","title":"Logging","text":"<pre><code>// Enable debug logging\nMessageContext ctx{.debugMode = true};\nMessagePrinter printer(ctx);\nprinter.debug(\"Starting scan for PID: {}\", pid);\n</code></pre>"},{"location":"en/main/#future-api-design","title":"Future API Design","text":""},{"location":"en/main/#future-api-command-line-interface","title":"Future API Command Line Interface","text":"<pre><code># Basic scan\n./newscanmem --pid 1234 --int32 42\n\n# Advanced scan\n./newscanmem --pid 1234 --range 0x1000-0xFFFF --float 3.14 --tolerance 0.001\n\n# Interactive mode\n./newscanmem --interactive\n\n# Batch mode\n./newscanmem --pid 1234 --batch --output results.json\n</code></pre>"},{"location":"en/main/#programmatic-api","title":"Programmatic API","text":"<pre><code>// Future C++ API\nclass ScanManager {\npublic:\n    ScanResult scan(const ScanConfig&amp; config);\n    void set_progress_callback(ProgressCallback callback);\n    void cancel_scan();\n};\n</code></pre>"},{"location":"en/main/#see-also","title":"See Also","text":"<ul> <li>Sets Module - Set operations and parsing</li> <li>Process Checker Module - Process state checking</li> <li>Target Memory Module - Memory analysis structures</li> <li>Value Module - Value type definitions</li> <li>Endianness Module - Byte order handling</li> <li>Show Message Module - Message and logging system</li> </ul>"},{"location":"en/main/#contributing","title":"Contributing","text":""},{"location":"en/main/#development-setup","title":"Development Setup","text":"<pre><code># Clone repository\ngit clone https://github.com/your-org/newscanmem.git\ncd newscanmem\n\n# Install dependencies\nsudo apt install build-essential cmake libboost-all-dev\n\n# Build and test\nmkdir build &amp;&amp; cd build\ncmake ..\nmake test\n</code></pre>"},{"location":"en/main/#code-style","title":"Code Style","text":"<ul> <li>Use modern C++23 features</li> <li>Follow RAII principles</li> <li>Prefer compile-time checks</li> <li>Use modules for encapsulation</li> <li>Document public APIs</li> </ul>"},{"location":"en/main/#license-and-legal","title":"License and Legal","text":"<p>This project is part of the NewScanmem memory scanning utility. See individual module documentation for specific licensing information.</p>"},{"location":"en/main/#support","title":"Support","text":"<p>For issues and questions:</p> <ul> <li>Check individual module documentation</li> <li>Review build requirements</li> <li>Verify system compatibility</li> <li>Test with minimal examples</li> </ul>"},{"location":"en/main/#cli-and-repl-integration","title":"CLI and REPL Integration","text":"<p>The main application now integrates a Command-Line Interface (CLI) with a REPL loop. This allows users to interactively execute commands for memory scanning and analysis. The <code>main.cpp</code> file initializes the REPL and registers commands such as <code>help</code>, <code>quit</code>, and <code>pid</code>.</p>"},{"location":"en/maps/","title":"Maps Module Documentation","text":""},{"location":"en/maps/#overview","title":"Overview","text":"<p>The Maps module provides functionality to read and parse Linux <code>/proc/[pid]/maps</code> files, extracting memory region information for process analysis. This is a modern C++20 implementation that replaces the legacy C code with type-safe, RAII-compliant interfaces.</p>"},{"location":"en/maps/#module-structure","title":"Module Structure","text":"<pre><code>import maps;\n</code></pre>"},{"location":"en/maps/#core-components","title":"Core Components","text":""},{"location":"en/maps/#1-region-types","title":"1. Region Types","text":""},{"location":"en/maps/#regiontype-enum","title":"<code>RegionType</code> Enum","text":"<p>Represents the classification of memory regions:</p> <pre><code>enum class RegionType : uint8_t {\n    MISC,   // Miscellaneous memory regions\n    EXE,    // Executable binary regions\n    CODE,   // Code segments (shared libraries, etc.)\n    HEAP,   // Heap memory regions\n    STACK   // Stack memory regions\n};\n\nconstexpr std::array&lt;std::string_view, 5&gt; REGION_TYPE_NAMES = {\n    \"misc\", \"exe\", \"code\", \"heap\", \"stack\"\n};\n</code></pre>"},{"location":"en/maps/#2-scan-levels","title":"2. Scan Levels","text":""},{"location":"en/maps/#regionscanlevel-enum","title":"<code>RegionScanLevel</code> Enum","text":"<p>Controls which memory regions are included in scanning:</p> <pre><code>enum class RegionScanLevel : uint8_t {\n    ALL,                       // All readable regions\n    ALL_RW,                    // All readable/writable regions\n    HEAP_STACK_EXECUTABLE,     // Heap, stack, and executable regions\n    HEAP_STACK_EXECUTABLE_BSS  // Above plus BSS segments\n};\n</code></pre>"},{"location":"en/maps/#3-region-metadata","title":"3. Region Metadata","text":""},{"location":"en/maps/#regionflags-structure","title":"<code>RegionFlags</code> Structure","text":"<p>Contains permission and state flags for memory regions:</p> <pre><code>struct RegionFlags {\n    bool read : 1;    // Read permission\n    bool write : 1;   // Write permission\n    bool exec : 1;    // Execute permission\n    bool shared : 1;  // Shared mapping\n    bool private_ : 1; // Private mapping\n};\n</code></pre>"},{"location":"en/maps/#region-structure","title":"<code>Region</code> Structure","text":"<p>Complete information about a memory region:</p> <pre><code>struct Region {\n    void* start;           // Starting address\n    std::size_t size;      // Region size in bytes\n    RegionType type;       // Region classification\n    RegionFlags flags;     // Permission flags\n    void* loadAddr;        // Load address for ELF files\n    std::string filename;  // Associated file path\n    std::size_t id;        // Unique identifier\n\n    // Helper methods\n    [[nodiscard]] bool isReadable() const noexcept;\n    [[nodiscard]] bool isWritable() const noexcept;\n    [[nodiscard]] bool isExecutable() const noexcept;\n    [[nodiscard]] bool isShared() const noexcept;\n    [[nodiscard]] bool isPrivate() const noexcept;\n\n    [[nodiscard]] std::pair&lt;void*, std::size_t&gt; asSpan() const noexcept;\n    [[nodiscard]] bool contains(void* address) const noexcept;\n};\n</code></pre>"},{"location":"en/maps/#usage-examples","title":"Usage Examples","text":""},{"location":"en/maps/#basic-usage","title":"Basic Usage","text":"<pre><code>import maps;\n\n// Read all memory regions from process\nauto result = maps::readProcessMaps(1234);\nif (result) {\n    for (const auto&amp; region : *result) {\n        std::cout &lt;&lt; std::format(\"Region: {}-{} ({})\\n\", \n                               region.start, \n                               static_cast&lt;char*&gt;(region.start) + region.size,\n                               REGION_TYPE_NAMES[static_cast&lt;size_t&gt;(region.type)]);\n    }\n}\n</code></pre>"},{"location":"en/maps/#filtered-scanning","title":"Filtered Scanning","text":"<pre><code>// Only scan heap and stack regions\nauto regions = maps::readProcessMaps(\n    pid, \n    maps::RegionScanLevel::HEAP_STACK_EXECUTABLE\n);\n\nif (regions) {\n    for (const auto&amp; region : *regions) {\n        if (region.type == maps::RegionType::HEAP) {\n            std::cout &lt;&lt; \"Heap region found: \" &lt;&lt; region.filename &lt;&lt; \"\\n\";\n        }\n    }\n}\n</code></pre>"},{"location":"en/maps/#error-handling","title":"Error Handling","text":"<pre><code>auto result = maps::readProcessMaps(pid);\nif (!result) {\n    std::cerr &lt;&lt; \"Error: \" &lt;&lt; result.error().message &lt;&lt; \"\\n\";\n    return;\n}\n</code></pre>"},{"location":"en/maps/#class-mapsreader","title":"Class: <code>MapsReader</code>","text":""},{"location":"en/maps/#static-methods","title":"Static Methods","text":""},{"location":"en/maps/#readprocessmaps","title":"<code>readProcessMaps</code>","text":"<p>Reads memory regions from a process:</p> <pre><code>[[nodiscard]] static std::expected&lt;std::vector&lt;Region&gt;, Error&gt; \nreadProcessMaps(pid_t pid, RegionScanLevel level = RegionScanLevel::ALL);\n</code></pre> <p>Parameters:</p> <ul> <li><code>pid</code>: Target process ID</li> <li><code>level</code>: Scan level filter (default: <code>all</code>)</li> </ul> <p>Returns:</p> <ul> <li><code>std::expected</code> containing vector of regions or error information</li> </ul> <p>Error Handling:</p> <ul> <li>Returns <code>std::error_code</code> with appropriate error messages</li> <li>Common errors: file not found, permission denied, invalid format</li> </ul>"},{"location":"en/maps/#error-handling-module","title":"Error Handling Module","text":""},{"location":"en/maps/#mapsreadererror-structure","title":"<code>MapsReader::Error</code> Structure","text":"<pre><code>struct Error {\n    std::string message;   // Human-readable error description\n    std::error_code code;  // System error code\n};\n</code></pre>"},{"location":"en/maps/#common-error-scenarios","title":"Common Error Scenarios","text":"<ol> <li>Process doesn't exist: <code>no_such_file_or_directory</code></li> <li>Permission denied: <code>permission_denied</code></li> <li>Invalid format: <code>invalid_argument</code></li> </ol>"},{"location":"en/maps/#advanced-features","title":"Advanced Features","text":""},{"location":"en/maps/#region-analysis","title":"Region Analysis","text":"<pre><code>// Check if address is within any region\nauto regions = maps::readProcessMaps(pid);\nvoid* address = /* some address */;\n\nfor (const auto&amp; region : *regions) {\n    if (region.contains(address)) {\n        std::cout &lt;&lt; \"Address found in: \" &lt;&lt; region.filename &lt;&lt; \"\\n\";\n        break;\n    }\n}\n</code></pre>"},{"location":"en/maps/#permission-checking","title":"Permission Checking","text":"<pre><code>// Find writable executable regions (potential shellcode targets)\nfor (const auto&amp; region : *regions) {\n    if (region.is_writable() &amp;&amp; region.is_executable()) {\n        std::cout &lt;&lt; \"WX region: \" &lt;&lt; region.filename &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>"},{"location":"en/maps/#performance-notes","title":"Performance Notes","text":"<ul> <li>Memory Efficient: Uses <code>std::string</code> with SSO for small filenames</li> <li>Zero-Copy: Direct string extraction from map lines</li> <li>Early Filtering: Regions filtered during parsing based on scan level</li> <li>RAII: Automatic resource cleanup via <code>std::ifstream</code></li> </ul>"},{"location":"en/maps/#thread-safety","title":"Thread Safety","text":"<ul> <li>Thread-Safe: All methods are thread-safe for concurrent access</li> <li>No Shared State: Each call creates independent state</li> <li>Immutable Results: Returned vectors contain immutable data</li> </ul>"},{"location":"en/maps/#platform-compatibility","title":"Platform Compatibility","text":"<ul> <li>Linux Only: Requires <code>/proc/[pid]/maps</code> filesystem</li> <li>C++23 Required: Uses <code>std::expected</code> and other C++23 features</li> <li>64-bit Support: Handles both 32-bit and 64-bit address spaces</li> </ul>"},{"location":"en/maps/#migration-from-legacy-c-code","title":"Migration from Legacy C Code","text":""},{"location":"en/maps/#legacy-c-modern-c","title":"Legacy C \u2192 Modern C++","text":"Legacy C Modern C++ <code>region_t*</code> <code>maps::Region</code> <code>list_t</code> <code>std::vector&lt;Region&gt;</code> <code>bool return</code> <code>std::expected</code> <code>char*</code> filename <code>std::string</code> Manual memory management RAII Error codes Exception-safe error handling"},{"location":"en/maps/#integration-with-cli","title":"Integration with CLI","text":"<p>The <code>maps</code> module is used in the CLI to retrieve and display memory region information for the target process. For example, the <code>list</code> command utilizes this module to parse and output <code>/proc/[pid]/maps</code> data.</p>"},{"location":"en/maps/#examples","title":"Examples","text":""},{"location":"en/maps/#complete-working-example","title":"Complete Working Example","text":"<pre><code>#include &lt;iostream&gt;\nimport maps;\n\nint main() {\n    pid_t target_pid = 1234; // Replace with actual PID\n\n    auto regions = maps::readProcessMaps(target_pid);\n    if (!regions) {\n        std::cerr &lt;&lt; \"Failed to read maps: \" &lt;&lt; regions.error().message &lt;&lt; \"\\n\";\n        return 1;\n    }\n\n    std::cout &lt;&lt; \"Found \" &lt;&lt; regions-&gt;size() &lt;&lt; \" memory regions:\\n\";\n\n    for (const auto&amp; region : *regions) {\n        std::cout &lt;&lt; std::format(\n            \"0x{:x}-0x{:x} {} {} {}\\n\",\n            reinterpret_cast&lt;uintptr_t&gt;(region.start),\n            reinterpret_cast&lt;uintptr_t&gt;(region.start) + region.size,\n            region.is_readable() ? 'r' : '-',\n            region.is_writable() ? 'w' : '-',\n            region.is_executable() ? 'x' : '-',\n            region.filename.empty() ? \"[anonymous]\" : region.filename\n        );\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"en/process_checker/","title":"Process Checker Module Documentation","text":""},{"location":"en/process_checker/#overview","title":"Overview","text":"<p>The <code>process_checker</code> module provides process state monitoring and checking functionality for the NewScanmem project. It allows checking if processes are running, dead, or in zombie states by examining the Linux <code>/proc</code> filesystem.</p>"},{"location":"en/process_checker/#module-structure","title":"Module Structure","text":"<pre><code>export module process_checker;\n</code></pre>"},{"location":"en/process_checker/#dependencies","title":"Dependencies","text":"<ul> <li><code>&lt;unistd.h&gt;</code> - POSIX operating system API</li> <li><code>&lt;filesystem&gt;</code> - C++17 filesystem operations</li> <li><code>&lt;fstream&gt;</code> - File stream operations</li> <li><code>&lt;string&gt;</code> - String operations</li> </ul>"},{"location":"en/process_checker/#core-features","title":"Core Features","text":""},{"location":"en/process_checker/#1-process-state-enumeration","title":"1. Process State Enumeration","text":"<pre><code>enum class ProcessState { \n    RUNNING,  // Process is running\n    ERROR,    // Error occurred during checking\n    DEAD,     // Process does not exist\n    ZOMBIE    // Process is in zombie state\n};\n</code></pre>"},{"location":"en/process_checker/#2-processchecker-class","title":"2. ProcessChecker Class","text":""},{"location":"en/process_checker/#public-interface","title":"Public Interface","text":"<pre><code>class ProcessChecker {\npublic:\n    static ProcessState checkProcess(pid_t pid);\n    static bool isProcessDead(pid_t pid);\n};\n</code></pre>"},{"location":"en/process_checker/#methods","title":"Methods","text":""},{"location":"en/process_checker/#checkprocesspid_t-pid","title":"checkProcess(pid_t pid)","text":"<p>Checks the state of a process given its PID.</p> <p>Parameters:</p> <ul> <li><code>pid</code>: Process ID to check</li> </ul> <p>Returns:</p> <ul> <li><code>ProcessState::RUNNING</code>: Process is running (includes sleeping, waiting, stopped states)</li> <li><code>ProcessState::ERROR</code>: Error occurred during checking (invalid PID, file access issues)</li> <li><code>ProcessState::DEAD</code>: Process does not exist (/proc/[pid] directory missing)</li> <li><code>ProcessState::ZOMBIE</code>: Process is in zombie or dead state</li> </ul>"},{"location":"en/process_checker/#isprocessdeadpid_t-pid","title":"isProcessDead(pid_t pid)","text":"<p>Convenience method to check if a process is not running.</p> <p>Parameters:</p> <ul> <li><code>pid</code>: Process ID to check</li> </ul> <p>Returns:</p> <ul> <li><code>true</code>: Process is dead, zombie, or error occurred</li> <li><code>false</code>: Process is running</li> </ul>"},{"location":"en/process_checker/#implementation-details","title":"Implementation Details","text":""},{"location":"en/process_checker/#process-state-detection","title":"Process State Detection","text":"<p>The module reads <code>/proc/[pid]/status</code> and examines the \"State:\" field:</p> <ul> <li>Running states: 'R' (Running), 'S' (Sleeping), 'D' (Waiting), 'T' (Stopped)</li> <li>Zombie states: 'Z' (Zombie), 'X' (Dead)</li> <li>Error handling: Invalid state characters, file access errors</li> </ul>"},{"location":"en/process_checker/#file-system-operations","title":"File System Operations","text":"<ol> <li>Validation: Checks if PID is positive</li> <li>Existence: Verifies <code>/proc/[pid]</code> directory exists</li> <li>Access: Opens <code>/proc/[pid]/status</code> file</li> <li>Parsing: Reads state information from file content</li> </ol>"},{"location":"en/process_checker/#usage-examples","title":"Usage Examples","text":""},{"location":"en/process_checker/#basic-process-checking","title":"Basic Process Checking","text":"<pre><code>import process_checker;\n\npid_t pid = 1234;\nProcessState state = ProcessChecker::checkProcess(pid);\n\nswitch (state) {\n    case ProcessState::RUNNING:\n        std::cout &lt;&lt; \"Process is running\\n\";\n        break;\n    case ProcessState::DEAD:\n        std::cout &lt;&lt; \"Process does not exist\\n\";\n        break;\n    case ProcessState::ZOMBIE:\n        std::cout &lt;&lt; \"Process is zombie/dead\\n\";\n        break;\n    case ProcessState::ERROR:\n        std::cout &lt;&lt; \"Error checking process\\n\";\n        break;\n}\n</code></pre>"},{"location":"en/process_checker/#quick-process-death-check","title":"Quick Process Death Check","text":"<pre><code>if (ProcessChecker::isProcessDead(pid)) {\n    std::cout &lt;&lt; \"Process is no longer running\\n\";\n} else {\n    std::cout &lt;&lt; \"Process is still running\\n\";\n}\n</code></pre>"},{"location":"en/process_checker/#monitoring-loop","title":"Monitoring Loop","text":"<pre><code>#include &lt;chrono&gt;\n#include &lt;thread&gt;\n\nvoid monitorProcess(pid_t pid) {\n    while (true) {\n        if (ProcessChecker::isProcessDead(pid)) {\n            std::cout &lt;&lt; \"Process \" &lt;&lt; pid &lt;&lt; \" has terminated\\n\";\n            break;\n        }\n\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n</code></pre>"},{"location":"en/process_checker/#error-handling","title":"Error Handling","text":""},{"location":"en/process_checker/#error-conditions","title":"Error Conditions","text":"<ol> <li>Invalid PID: PIDs less than or equal to 0 return <code>ProcessState::ERROR</code></li> <li>File Access: Cannot open <code>/proc/[pid]/status</code> returns <code>ProcessState::ERROR</code></li> <li>Parse Errors: Malformed state information returns <code>ProcessState::ERROR</code></li> </ol>"},{"location":"en/process_checker/#linux-specific-notes","title":"Linux Specific Notes","text":"<ul> <li>Requires Linux <code>/proc</code> filesystem</li> <li>Needs read permissions on <code>/proc/[pid]/status</code></li> <li>May not work on systems with restricted <code>/proc</code> access</li> </ul>"},{"location":"en/process_checker/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>File I/O operations may have some overhead</li> <li>Consider caching results for frequent checks</li> <li>Thread-safe for concurrent access to different PIDs</li> </ul>"},{"location":"en/process_checker/#security-considerations","title":"Security Considerations","text":"<ul> <li>No elevated privileges required for basic checking</li> <li>May require appropriate permissions to read <code>/proc/[pid]/status</code></li> <li>Does not perform any process memory access</li> </ul>"},{"location":"en/process_checker/#platform-compatibility","title":"Platform Compatibility","text":"<ul> <li>Linux: Full support (primary target platform)</li> <li>macOS: Not supported (different proc filesystem structure)</li> <li>Windows: Not supported (requires different implementation)</li> </ul>"},{"location":"en/process_checker/#see-also","title":"See Also","text":"<ul> <li>Target Memory Module - For memory analysis operations</li> <li>Main Application - For process targeting in the application</li> </ul>"},{"location":"en/process_checker/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Support for additional process information</li> <li>Cross-platform compatibility</li> <li>Non-blocking process checking</li> <li>Process permission checking</li> </ul>"},{"location":"en/process_checker/#integration-with-cli","title":"Integration with CLI","text":"<p>The <code>process_checker</code> module is directly used in the CLI for commands like <code>pid</code>, which checks and displays the state of the target process. This ensures that users can verify process status interactively.</p>"},{"location":"en/sets/","title":"Sets Module Documentation","text":""},{"location":"en/sets/#overview","title":"Overview","text":"<p>The <code>sets</code> module provides set operations and parsing utilities for the NewScanmem project. It includes a <code>Set</code> class for managing collections of integers and a powerful parser for set expressions with support for ranges, hex/decimal numbers, and inversion operations.</p>"},{"location":"en/sets/#module-structure","title":"Module Structure","text":"<pre><code>export module sets;\n</code></pre>"},{"location":"en/sets/#dependencies","title":"Dependencies","text":"<ul> <li><code>&lt;algorithm&gt;</code> - Standard algorithms</li> <li><code>&lt;boost/regex.hpp&gt;</code> - Regular expression support</li> <li><code>&lt;boost/spirit/include/phoenix.hpp&gt;</code> - Boost Spirit Phoenix for semantic actions</li> <li><code>&lt;boost/spirit/include/qi.hpp&gt;</code> - Boost Spirit Qi for parsing</li> <li><code>&lt;cctype&gt;</code> - Character classification</li> <li><code>&lt;compare&gt;</code> - Three-way comparison</li> <li><code>&lt;cstdlib&gt;</code> - C standard library</li> <li><code>&lt;stdexcept&gt;</code> - Standard exceptions</li> <li><code>&lt;string&gt;</code> - String operations</li> <li><code>&lt;vector&gt;</code> - Dynamic array container</li> </ul>"},{"location":"en/sets/#core-features","title":"Core Features","text":""},{"location":"en/sets/#1-set-structure","title":"1. Set Structure","text":"<pre><code>export struct Set {\n    std::vector&lt;size_t&gt; buf;\n\n    size_t size() const;\n    void clear();\n    static int cmp(const size_t&amp; i1, const size_t&amp; i2);\n};\n</code></pre>"},{"location":"en/sets/#methods","title":"Methods","text":"<ul> <li>size(): Returns the number of elements in the set</li> <li>clear(): Removes all elements from the set</li> <li>cmp(): Static comparison function for two size_t values using three-way comparison</li> </ul>"},{"location":"en/sets/#2-set-expression-parser","title":"2. Set Expression Parser","text":"<pre><code>export bool parse_uintset(std::string_view lptr, Set&amp; set, size_t maxSZ);\n</code></pre>"},{"location":"en/sets/#supported-expression-formats","title":"Supported Expression Formats","text":"<ul> <li>Single numbers: <code>42</code>, <code>0x2A</code></li> <li>Ranges: <code>10..20</code>, <code>0x10..0xFF</code></li> <li>Multiple values: <code>1,2,3,4,5</code></li> <li>Mixed format: <code>1,5,10..15,0x20</code></li> <li>Inversion: <code>!1,2,3</code> (all numbers except 1,2,3)</li> <li>Hexadecimal: <code>0x10</code>, <code>0xFF</code>, <code>0xdeadbeef</code></li> </ul>"},{"location":"en/sets/#parameters","title":"Parameters","text":"<ul> <li>lptr: The set expression string to parse</li> <li>set: The Set object to populate with results</li> <li>maxSZ: Maximum allowed value (exclusive upper bound)</li> </ul>"},{"location":"en/sets/#return-value","title":"Return Value","text":"<ul> <li><code>true</code>: Parsing successful</li> <li><code>false</code>: Parsing failed (invalid syntax, out of bounds, etc.)</li> </ul>"},{"location":"en/sets/#3-deprecated-memory-management","title":"3. Deprecated Memory Management","text":"<pre><code>[[deprecated(\"This interface is deprecated...\")]]\nconstexpr auto inc_arr_sz = [](size_t** valarr, size_t* arr_maxsz, size_t maxsz) -&gt; bool;\n</code></pre> <p>A deprecated C-style memory management utility for dynamic array resizing.</p>"},{"location":"en/sets/#integration-with-cli","title":"Integration with CLI","text":"<p>The <code>sets</code> module is utilized in the CLI for parsing and managing result sets during memory scanning. Commands like <code>scan</code> and <code>reset</code> rely on this module to handle set operations efficiently.</p>"},{"location":"en/sets/#usage-examples","title":"Usage Examples","text":""},{"location":"en/sets/#basic-set-parsing","title":"Basic Set Parsing","text":"<pre><code>import sets;\n\nSet mySet;\nbool success = parse_uintset(\"1,2,3,4,5\", mySet, 100);\nif (success) {\n    std::cout &lt;&lt; \"Set contains \" &lt;&lt; mySet.size() &lt;&lt; \" elements\\n\";\n}\n</code></pre>"},{"location":"en/sets/#range-parsing","title":"Range Parsing","text":"<pre><code>Set rangeSet;\nparse_uintset(\"10..20\", rangeSet, 100);\n// Results: {10, 11, 12, ..., 20}\n</code></pre>"},{"location":"en/sets/#hexadecimal-support","title":"Hexadecimal Support","text":"<pre><code>Set hexSet;\nparse_uintset(\"0x10,0x20,0x30..0x35\", hexSet, 256);\n// Results: {16, 32, 48, 49, 50, 51, 52, 53}\n</code></pre>"},{"location":"en/sets/#set-inversion","title":"Set Inversion","text":"<pre><code>Set invertedSet;\nparse_uintset(\"!0,1,2\", invertedSet, 10);\n// Results: {3, 4, 5, 6, 7, 8, 9}\n</code></pre>"},{"location":"en/sets/#complex-expressions","title":"Complex Expressions","text":"<pre><code>Set complexSet;\nparse_uintset(\"0,5,10..15,0x20,!12\", complexSet, 100);\n// Results: {0, 5, 10, 11, 13, 14, 15, 32}\n</code></pre>"},{"location":"en/sets/#empty-set-handling","title":"Empty Set Handling","text":"<pre><code>Set emptySet;\nbool result = parse_uintset(\"\", emptySet, 100);  // Returns false\n\nSet invertedEmpty;\nparse_uintset(\"!\", invertedEmpty, 5);  // Results: {0, 1, 2, 3, 4}\n</code></pre>"},{"location":"en/sets/#parser-grammar","title":"Parser Grammar","text":"<p>The parser uses Boost Spirit Qi and supports the following grammar:</p> <pre><code>expression ::= [\"!\"] (range | single) { \",\" (range | single) }\nrange ::= number \"..\" number\nsingle ::= number\nnumber ::= hex_number | decimal_number\nhex_number ::= \"0x\" hex_digits\ndecimal_number ::= decimal_digits\n</code></pre>"},{"location":"en/sets/#error-handling","title":"Error Handling","text":""},{"location":"en/sets/#parse-errors","title":"Parse Errors","text":"<p>The parser will return <code>false</code> for:</p> <ul> <li>Invalid syntax (e.g., \"1..\", \"abc\", \"1..2..3\")</li> <li>Out of bounds values (exceeding maxSZ)</li> <li>Empty expressions (except for inversion of empty set)</li> <li>Invalid ranges (start &gt; end)</li> </ul>"},{"location":"en/sets/#exception-safety","title":"Exception Safety","text":"<p>The parser uses exception handling internally but converts all Boost Spirit exceptions to boolean return values for clean API usage.</p>"},{"location":"en/sets/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Complexity: O(n log n) due to sorting and duplicate removal</li> <li>Memory: Uses std::vector for storage with automatic memory management</li> <li>Boost Spirit: Parser is efficient but has some compile-time overhead</li> </ul>"},{"location":"en/sets/#implementation-details","title":"Implementation Details","text":""},{"location":"en/sets/#sorting-and-deduplication","title":"Sorting and Deduplication","text":"<p>After parsing, the module automatically:</p> <ol> <li>Sorts the elements in ascending order</li> <li>Removes duplicate values</li> <li>Handles inversion logic efficiently</li> </ol>"},{"location":"en/sets/#range-expansion","title":"Range Expansion","text":"<p>Ranges are expanded into individual values:</p> <ul> <li><code>10..15</code> becomes <code>{10, 11, 12, 13, 14, 15}</code></li> <li>Each value is validated against maxSZ</li> </ul>"},{"location":"en/sets/#inversion-logic","title":"Inversion Logic","text":"<p>Inversion creates the complement set:</p> <ul> <li>Original: <code>{1, 3, 5}</code> with maxSZ=10</li> <li>Inverted: <code>{0, 2, 4, 6, 7, 8, 9}</code></li> </ul>"},{"location":"en/sets/#limitations","title":"Limitations","text":"<ul> <li>maxSZ: All values must be less than maxSZ</li> <li>Memory: Large ranges can consume significant memory</li> <li>Performance: Very large ranges may impact performance</li> </ul>"},{"location":"en/sets/#examples-of-invalid-input","title":"Examples of Invalid Input","text":"<pre><code>Set set;\nparse_uintset(\"5..2\", set, 100);     // false - invalid range\nparse_uintset(\"1,200\", set, 100);    // false - out of bounds\nparse_uintset(\"abc\", set, 100);      // false - invalid syntax\nparse_uintset(\"1..\", set, 100);      // false - incomplete range\n</code></pre>"},{"location":"en/sets/#testing","title":"Testing","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nvoid test_parser() {\n    Set set;\n\n    // Test basic parsing\n    parse_uintset(\"1,2,3\", set, 100);\n    assert(set.size() == 3);\n\n    // Test ranges\n    parse_uintset(\"1..3\", set, 100);\n    assert(set.size() == 3);\n\n    // Test inversion\n    parse_uintset(\"!1..3\", set, 10);\n    assert(set.size() == 7);\n\n    std::cout &lt;&lt; \"All tests passed!\\n\";\n}\n</code></pre>"},{"location":"en/sets/#see-also","title":"See Also","text":"<ul> <li>Main Application - For integration examples</li> <li>Value Module - For value type definitions used with sets</li> </ul>"},{"location":"en/sets/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Support for floating-point ranges</li> <li>Custom delimiters</li> <li>Performance optimizations for large ranges</li> <li>Memory-efficient sparse set representation</li> </ul>"},{"location":"en/show_message/","title":"Show Message Module Documentation","text":""},{"location":"en/show_message/#overview","title":"Overview","text":"<p>The <code>show_message</code> module provides a comprehensive message printing and logging system for the NewScanmem project. It supports multiple message types, conditional output based on debug/backend modes, and formatted output using C++20 format strings.</p>"},{"location":"en/show_message/#module-structure","title":"Module Structure","text":"<pre><code>export module show_message;\n</code></pre>"},{"location":"en/show_message/#dependencies","title":"Dependencies","text":"<ul> <li><code>&lt;boost/process.hpp&gt;</code> - Boost process library</li> <li><code>&lt;cstdint&gt;</code> - Fixed-width integer types</li> <li><code>&lt;format&gt;</code> - C++20 format library</li> <li><code>&lt;iostream&gt;</code> - Standard I/O streams</li> <li><code>&lt;string_view&gt;</code> - String view for efficient string handling</li> </ul>"},{"location":"en/show_message/#core-features","title":"Core Features","text":""},{"location":"en/show_message/#1-message-type-system","title":"1. Message Type System","text":"<pre><code>enum class MessageType : uint8_t {\n    INFO,    // Informational messages\n    WARN,    // Warning messages\n    ERROR,   // Error messages\n    DEBUG,   // Debug messages (conditional)\n    USER     // User-facing messages (conditional)\n};\n</code></pre>"},{"location":"en/show_message/#2-message-context","title":"2. Message Context","text":"<pre><code>struct MessageContext {\n    bool debugMode = false;    // Enable debug output\n    bool backendMode = false;  // Suppress user output\n};\n</code></pre>"},{"location":"en/show_message/#3-messageprinter-class","title":"3. MessagePrinter Class","text":""},{"location":"en/show_message/#constructor","title":"Constructor","text":"<pre><code>MessagePrinter(MessageContext ctx = {});\n</code></pre>"},{"location":"en/show_message/#main-print-method","title":"Main Print Method","text":"<pre><code>template&lt;typename... Args&gt;\nvoid print(MessageType type, std::string_view fmt, Args&amp;&amp;... args) const;\n</code></pre>"},{"location":"en/show_message/#convenience-methods","title":"Convenience Methods","text":"<pre><code>template&lt;typename... Args&gt;\nvoid info(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid warn(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid error(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid debug(std::string_view fmt, Args&amp;&amp;... args) const;\n\ntemplate&lt;typename... Args&gt;\nvoid user(std::string_view fmt, Args&amp;&amp;... args) const;\n</code></pre>"},{"location":"en/show_message/#usage-examples","title":"Usage Examples","text":""},{"location":"en/show_message/#basic-usage","title":"Basic Usage","text":"<pre><code>import show_message;\n\nMessagePrinter printer;\nprinter.info(\"Starting memory scan\");\nprinter.warn(\"Low memory detected\");\nprinter.error(\"Failed to open process\");\n</code></pre>"},{"location":"en/show_message/#with-format-strings","title":"With Format Strings","text":"<pre><code>printer.info(\"Scanning process with PID: {}\", pid);\nprinter.warn(\"Found {} suspicious memory regions\", suspicious_count);\nprinter.error(\"Memory read failed at address: 0x{:08x}\", address);\n</code></pre>"},{"location":"en/show_message/#debug-mode-usage","title":"Debug Mode Usage","text":"<pre><code>MessageContext ctx{.debugMode = true};\nMessagePrinter debug_printer(ctx);\n\ndebug_printer.debug(\"Current memory usage: {} bytes\", memory_usage);\ndebug_printer.debug(\"Processing region: 0x{:08x}-0x{:08x}\", start, end);\n</code></pre>"},{"location":"en/show_message/#backend-mode-usage","title":"Backend Mode Usage","text":"<pre><code>MessageContext ctx{.backendMode = true};\nMessagePrinter backend_printer(ctx);\n\nbackend_printer.user(\"Scan complete\");  // Won't print in backend mode\nbackend_printer.info(\"Scan complete\");  // Will print to stderr\n</code></pre>"},{"location":"en/show_message/#combined-context","title":"Combined Context","text":"<pre><code>MessageContext ctx{\n    .debugMode = true,\n    .backendMode = false\n};\nMessagePrinter printer(ctx);\n\nprinter.debug(\"Debug info\");  // Prints to stderr\nprinter.user(\"User message\"); // Prints to stdout\n</code></pre>"},{"location":"en/show_message/#output-channels","title":"Output Channels","text":""},{"location":"en/show_message/#info-warn-error-debug","title":"INFO, WARN, ERROR, DEBUG","text":"<ul> <li>Output: <code>std::cerr</code></li> <li>Format: <code>[level]: message</code></li> </ul>"},{"location":"en/show_message/#user","title":"USER","text":"<ul> <li>Output: <code>std::cout</code> (unless backend mode is enabled)</li> <li>Format: Raw message without prefix</li> </ul>"},{"location":"en/show_message/#message-formatting","title":"Message Formatting","text":"<p>The module uses C++20 format strings with the following features:</p>"},{"location":"en/show_message/#supported-format-specifiers","title":"Supported Format Specifiers","text":"<pre><code>printer.info(\"Integer: {}\", 42);\nprinter.info(\"Hex: 0x{:08x}\", 0x1234);\nprinter.info(\"Float: {:.2f}\", 3.14159);\nprinter.info(\"String: {}\", \"hello\");\nprinter.info(\"Multiple: {} and {}\", 1, \"two\");\n</code></pre>"},{"location":"en/show_message/#error-handling","title":"Error Handling","text":"<p>Format string errors are handled by the standard format library and will throw appropriate exceptions.</p>"},{"location":"en/show_message/#integration-examples","title":"Integration Examples","text":""},{"location":"en/show_message/#with-other-modules","title":"With Other Modules","text":"<pre><code>import show_message;\nimport process_checker;\n\nvoid check_and_report(pid_t pid) {\n    MessagePrinter printer;\n\n    auto state = ProcessChecker::check_process(pid);\n    switch (state) {\n        case ProcessState::RUNNING:\n            printer.info(\"Process {} is running\", pid);\n            break;\n        case ProcessState::DEAD:\n            printer.warn(\"Process {} is dead\", pid);\n            break;\n        case ProcessState::ERROR:\n            printer.error(\"Error checking process {}\", pid);\n            break;\n    }\n}\n</code></pre>"},{"location":"en/show_message/#configuration-based-usage","title":"Configuration-based Usage","text":"<pre><code>struct Config {\n    bool debug;\n    bool backend;\n};\n\nvoid initialize_logging(const Config&amp; config) {\n    MessageContext ctx{\n        .debugMode = config.debug,\n        .backendMode = config.backend\n    };\n\n    static MessagePrinter printer(ctx);\n    // Use printer throughout application\n}\n</code></pre>"},{"location":"en/show_message/#thread-safety","title":"Thread Safety","text":"<p>The <code>MessagePrinter</code> class is thread-safe for concurrent use. Each instance maintains its own context and can be used from multiple threads simultaneously.</p>"},{"location":"en/show_message/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Format String Parsing: Done at compile time for literal strings</li> <li>Memory Allocation: Minimal heap allocation for formatted strings</li> <li>I/O Buffering: Uses standard stream buffering</li> </ul>"},{"location":"en/show_message/#customization","title":"Customization","text":""},{"location":"en/show_message/#extending-message-types","title":"Extending Message Types","text":"<p>To add new message types, extend the <code>MessageType</code> enum and add appropriate handling in the <code>print</code> method:</p> <pre><code>// Example extension\nenum class ExtendedMessageType {\n    VERBOSE,  // More detailed than DEBUG\n    TRACE     // Function tracing\n};\n</code></pre>"},{"location":"en/show_message/#custom-output-redirection","title":"Custom Output Redirection","text":"<p>While the module uses fixed output streams, you can create wrapper functions:</p> <pre><code>class CustomMessagePrinter : public MessagePrinter {\n    std::ofstream log_file;\n\npublic:\n    void custom_log(std::string_view msg) {\n        log_file &lt;&lt; std::format(\"{}\\n\", msg);\n        info(\"Logged: {}\", msg);\n    }\n};\n</code></pre>"},{"location":"en/show_message/#error-handling-module","title":"Error Handling Module","text":""},{"location":"en/show_message/#exception-safety","title":"Exception Safety","text":"<p>All methods provide strong exception safety guarantee. Format string errors are propagated to the caller.</p>"},{"location":"en/show_message/#common-issues","title":"Common Issues","text":"<ol> <li>Format String Mismatches: Ensure format specifiers match argument types</li> <li>Locale Issues: Consider locale settings for number formatting</li> <li>Buffer Overflow: Not possible with C++20 format library</li> </ol>"},{"location":"en/show_message/#testing","title":"Testing","text":"<pre><code>void test_message_printer() {\n    MessagePrinter printer;\n\n    printer.info(\"Test info message\");\n    printer.warn(\"Test warning message\");\n    printer.error(\"Test error message\");\n\n    MessageContext ctx{.debugMode = true};\n    MessagePrinter debug_printer(ctx);\n    debug_printer.debug(\"Test debug message\");\n\n    ctx.backendMode = true;\n    MessagePrinter backend_printer(ctx);\n    backend_printer.user(\"Test user message\");  // Won't print\n}\n</code></pre>"},{"location":"en/show_message/#see-also","title":"See Also","text":"<ul> <li>Target Memory Module - Uses message printing for memory operations</li> <li>Process Checker Module - Uses messages for process state reporting</li> <li>Main Application - Integration in main application flow</li> </ul>"},{"location":"en/show_message/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Log file support</li> <li>Colored output support</li> <li>Custom log levels</li> <li>Timestamp support</li> <li>Log rotation capabilities</li> <li>JSON format output option</li> <li>Syslog integration</li> <li>Windows Event Log support (cross-platform)</li> </ul>"},{"location":"en/show_message/#platform-notes","title":"Platform Notes","text":"<ul> <li>Linux/macOS: Full support for all features</li> <li>Windows: Full support for all features</li> <li>UTF-8: Supports Unicode messages on all platforms</li> <li>Terminal Colors: Future enhancement for colorized output</li> </ul>"},{"location":"en/show_message/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate message types for different severity levels</li> <li>Enable debug mode only when needed to reduce noise</li> <li>Use backend mode for automated/scripted operations</li> <li>Format strings: Use appropriate format specifiers for readability</li> <li>Error handling: Always handle format string errors appropriately</li> <li>Performance: Avoid complex formatting in tight loops</li> </ol>"},{"location":"en/show_message/#migration-from-printf-style-logging","title":"Migration from printf-style logging","text":"<pre><code>// Old style\nprintf(\"Error: %s at line %d\\n\", message, line);\n\n// New style\nprinter.error(\"{} at line {}\", message, line);\n</code></pre>"},{"location":"en/show_message/#integration-with-build-systems","title":"Integration with Build Systems","text":"<p>The module can be configured through build flags:</p> <pre><code>#ifdef NDEBUG\n    MessageContext ctx{.debugMode = false};\n#else\n    MessageContext ctx{.debugMode = true};\n#endif\n</code></pre>"},{"location":"en/show_message/#common-patterns","title":"Common Patterns","text":""},{"location":"en/show_message/#scoped-debugging","title":"Scoped Debugging","text":"<pre><code>class ScopedDebug {\n    MessagePrinter&amp; printer;\n    std::string name;\n\npublic:\n    ScopedDebug(MessagePrinter&amp; p, std::string_view n) \n        : printer(p), name(n) {\n        printer.debug(\"Entering {}\", name);\n    }\n\n    ~ScopedDebug() {\n        printer.debug(\"Exiting {}\", name);\n    }\n};\n\n// Usage\n{\n    ScopedDebug debug(printer, \"memory_scan\");\n    // ... scan memory ...\n} // Automatically logs exit\n</code></pre>"},{"location":"en/target_mem/","title":"Target Memory Module Documentation","text":""},{"location":"en/target_mem/#overview","title":"Overview","text":"<p>The <code>targetmem</code> module provides memory matching and analysis structures for the NewScanmem project. It includes classes for managing memory matches, storing old values, and performing memory region operations with support for efficient searching and manipulation.</p>"},{"location":"en/target_mem/#module-structure","title":"Module Structure","text":"<pre><code>export module targetmem;\n</code></pre>"},{"location":"en/target_mem/#dependencies","title":"Dependencies","text":"<ul> <li><code>&lt;algorithm&gt;</code> - Standard algorithms</li> <li><code>&lt;cassert&gt;</code> - Assert macros</li> <li><code>&lt;cctype&gt;</code> - Character classification</li> <li><code>&lt;cstddef&gt;</code> - Size type definitions</li> <li><code>&lt;cstdint&gt;</code> - Fixed-width integer types</li> <li><code>&lt;cstdio&gt;</code> - C standard I/O</li> <li><code>&lt;cstdlib&gt;</code> - C standard library</li> <li><code>&lt;cstring&gt;</code> - C string operations</li> <li><code>&lt;optional&gt;</code> - Optional type support</li> <li><code>&lt;sstream&gt;</code> - String stream operations</li> <li><code>&lt;string&gt;</code> - String operations</li> <li><code>&lt;vector&gt;</code> - Dynamic array container</li> <li><code>value</code> module - Value type definitions</li> <li><code>show_message</code> module - Message printing system</li> </ul>"},{"location":"en/target_mem/#core-features","title":"Core Features","text":""},{"location":"en/target_mem/#1-memory-match-flags","title":"1. Memory Match Flags","text":"<p>Uses <code>MatchFlags</code> from the <code>value</code> module to indicate the type and status of memory matches.</p>"},{"location":"en/target_mem/#2-oldvalueandmatchinfo-structure","title":"2. OldValueAndMatchInfo Structure","text":"<pre><code>struct OldValueAndMatchInfo {\n    uint8_t old_value;      // The original byte value\n    MatchFlags match_info;  // Match type and status flags\n};\n</code></pre>"},{"location":"en/target_mem/#3-matchesandoldvaluesswath-class","title":"3. MatchesAndOldValuesSwath Class","text":"<p>Represents a contiguous memory region with match information.</p> <pre><code>class MatchesAndOldValuesSwath {\npublic:\n    void* firstByteInChild = nullptr;                    // Starting address\n    std::vector&lt;OldValueAndMatchInfo&gt; data;              // Match data\n\n    // Constructors\n    MatchesAndOldValuesSwath() = default;\n\n    // Element management\n    void addElement(void* addr, uint8_t byte, MatchFlags matchFlags);\n\n    // String representation utilities\n    std::string toPrintableString(size_t idx, size_t len) const;\n    std::string toByteArrayText(size_t idx, size_t len) const;\n};\n</code></pre>"},{"location":"en/target_mem/#methods","title":"Methods","text":""},{"location":"en/target_mem/#addelementvoid-addr-uint8_t-byte-matchflags-matchflags","title":"addElement(void* addr, uint8_t byte, MatchFlags matchFlags)","text":"<p>Adds a new memory match to the swath.</p> <p>Parameters:</p> <ul> <li><code>addr</code>: Memory address of the match</li> <li><code>byte</code>: The byte value at this address</li> <li><code>matchFlags</code>: Type of match and flags</li> </ul>"},{"location":"en/target_mem/#toprintablestringsize_t-idx-size_t-len","title":"toPrintableString(size_t idx, size_t len)","text":"<p>Converts memory bytes to a printable ASCII string.</p> <p>Parameters:</p> <ul> <li><code>idx</code>: Starting index in the data vector</li> <li><code>len</code>: Number of bytes to convert</li> </ul> <p>Returns: Printable string with non-printable characters as '.'</p>"},{"location":"en/target_mem/#tobytearraytextsize_t-idx-size_t-len","title":"toByteArrayText(size_t idx, size_t len)","text":"<p>Converts memory bytes to hexadecimal text representation.</p> <p>Parameters:</p> <ul> <li><code>idx</code>: Starting index in the data vector</li> <li><code>len</code>: Number of bytes to convert</li> </ul> <p>Returns: Space-separated hexadecimal values</p>"},{"location":"en/target_mem/#4-matchesandoldvaluesarray-class","title":"4. MatchesAndOldValuesArray Class","text":"<p>Manages multiple swaths and provides search operations.</p> <pre><code>class MatchesAndOldValuesArray {\npublic:\n    size_t maxNeededBytes;                          // Maximum memory needed\n    std::vector&lt;MatchesAndOldValuesSwath&gt; swaths;   // Collection of swaths\n\n    // Constructor\n    MatchesAndOldValuesArray(size_t maxBytes);\n\n    // Swath management\n    void addSwath(const MatchesAndOldValuesSwath&amp; swath);\n\n    // Search operations\n    std::optional&lt;std::pair&lt;MatchesAndOldValuesSwath*, size_t&gt;&gt; nthMatch(size_t n);\n\n    // Memory range operations\n    void deleteInAddressRange(void* start, void* end, unsigned long&amp; numMatches);\n};\n</code></pre>"},{"location":"en/target_mem/#matchesandoldvaluesarray-methods","title":"MatchesAndOldValuesArray Methods","text":""},{"location":"en/target_mem/#constructorsize_t-maxbytes","title":"Constructor(size_t maxBytes)","text":"<p>Initializes with maximum memory requirement.</p> <p>Parameters:</p> <ul> <li><code>maxBytes</code>: Maximum bytes needed for all matches</li> </ul>"},{"location":"en/target_mem/#addswathconst-matchesandoldvaluesswath-swath","title":"addSwath(const MatchesAndOldValuesSwath&amp; swath)","text":"<p>Adds a new swath to the collection.</p>"},{"location":"en/target_mem/#nthmatchsize_t-n","title":"nthMatch(size_t n)","text":"<p>Finds the nth valid match across all swaths.</p> <p>Parameters:</p> <ul> <li><code>n</code>: Match index to find (0-based)</li> </ul> <p>Returns: Optional pair of (swath pointer, index within swath) or nullopt if not found</p>"},{"location":"en/target_mem/#deleteinaddressrangevoidstart-void-end-unsigned-long-nummatches","title":"deleteInAddressRange(voidstart, void end, unsigned long&amp; numMatches)","text":"<p>Removes all matches within a specified address range.</p> <p>Parameters:</p> <ul> <li><code>start</code>: Starting address of range (inclusive)</li> <li><code>end</code>: Ending address of range (exclusive)</li> <li><code>numMatches</code>: Output parameter counting removed matches</li> </ul>"},{"location":"en/target_mem/#usage-examples","title":"Usage Examples","text":""},{"location":"en/target_mem/#creating-and-populating-swaths","title":"Creating and Populating Swaths","text":"<pre><code>import targetmem;\n\nMatchesAndOldValuesSwath swath;\n\n// Add memory matches\nvoid* base_addr = reinterpret_cast&lt;void*&gt;(0x1000);\nswath.addElement(base_addr, 0x41, MatchFlags::U8B);        // 'A' character\nswath.addElement(static_cast&lt;char*&gt;(base_addr) + 1, 0x42, MatchFlags::U8B); // 'B' character\nswath.addElement(static_cast&lt;char*&gt;(base_addr) + 2, 0x00, MatchFlags::EMPTY); // No match\n</code></pre>"},{"location":"en/target_mem/#string-representations","title":"String Representations","text":"<pre><code>// Get printable representation\nstd::string printable = swath.toPrintableString(0, 3);\n// Result: \"AB.\"\n\n// Get hex representation\nstd::string hex = swath.toByteArrayText(0, 3);\n// Result: \"41 42 0\"\n</code></pre>"},{"location":"en/target_mem/#managing-multiple-swaths","title":"Managing Multiple Swaths","text":"<pre><code>MatchesAndOldValuesArray array(1024); // Max 1KB of matches\n\n// Add swaths\narray.addSwath(swath1);\narray.addSwath(swath2);\n\n// Find specific matches\nauto match = array.nthMatch(5);\nif (match) {\n    auto [swath_ptr, index] = *match;\n    // Process the 6th match (0-based index 5)\n}\n</code></pre>"},{"location":"en/target_mem/#address-range-operations","title":"Address Range Operations","text":"<pre><code>// Remove matches in a specific address range\nunsigned long removed_count = 0;\nvoid* start_range = reinterpret_cast&lt;void*&gt;(0x1000);\nvoid* end_range = reinterpret_cast&lt;void*&gt;(0x2000);\n\narray.deleteInAddressRange(start_range, end_range, removed_count);\nstd::cout &lt;&lt; \"Removed \" &lt;&lt; removed_count &lt;&lt; \" matches\\n\";\n</code></pre>"},{"location":"en/target_mem/#memory-layout-and-addressing","title":"Memory Layout and Addressing","text":""},{"location":"en/target_mem/#address-calculation","title":"Address Calculation","text":"<p>The module uses pointer arithmetic to calculate actual memory addresses:</p> <pre><code>// Calculate actual address from swath data\nvoid* actual_address = static_cast&lt;char*&gt;(swath.firstByteInChild) + index;\n</code></pre>"},{"location":"en/target_mem/#swath-organization","title":"Swath Organization","text":"<p>Each swath represents a contiguous memory region with:</p> <ul> <li>Fixed starting address (<code>firstByteInChild</code>)</li> <li>Sequential byte values (<code>data</code> vector)</li> <li>Match flags for each byte</li> </ul>"},{"location":"en/target_mem/#performance-considerations","title":"Performance Considerations","text":""},{"location":"en/target_mem/#memory-usage","title":"Memory Usage","text":"<ul> <li>Swath overhead: Each swath has minimal overhead</li> <li>Data storage: Stores one byte + flags per address</li> <li>Vector growth: Uses std::vector with amortized growth</li> </ul>"},{"location":"en/target_mem/#search-performance","title":"Search Performance","text":"<ul> <li>nthMatch: O(n) traversal across all swaths</li> <li>Range deletion: O(n) with efficient std::remove_if</li> <li>Memory locality: Good cache performance due to vector storage</li> </ul>"},{"location":"en/target_mem/#error-handling","title":"Error Handling","text":""},{"location":"en/target_mem/#bounds-checking","title":"Bounds Checking","text":"<p>All methods include bounds checking:</p> <ul> <li><code>toPrintableString</code> and <code>toByteArrayText</code> use <code>std::min</code> to prevent overflow</li> <li><code>nthMatch</code> returns <code>std::nullopt</code> for invalid indices</li> </ul>"},{"location":"en/target_mem/#null-pointer-safety","title":"Null Pointer Safety","text":"<ul> <li><code>firstByteInChild</code> is initialized to nullptr</li> <li>Methods verify vector sizes before access</li> </ul>"},{"location":"en/target_mem/#advanced-usage","title":"Advanced Usage","text":""},{"location":"en/target_mem/#complex-memory-analysis","title":"Complex Memory Analysis","text":"<pre><code>void analyze_memory_region(void* start, size_t size) {\n    MatchesAndOldValuesArray matches(size);\n    MatchesAndOldValuesSwath swath;\n\n    swath.firstByteInChild = start;\n\n    // Analyze each byte\n    for (size_t i = 0; i &lt; size; ++i) {\n        void* addr = static_cast&lt;char*&gt;(start) + i;\n        uint8_t value = read_memory_byte(addr); // Implementation specific\n\n        MatchFlags flags = analyze_value(value); // Determine match type\n        swath.addElement(addr, value, flags);\n    }\n\n    matches.addSwath(swath);\n\n    // Process results\n    auto first_match = matches.nthMatch(0);\n    if (first_match) {\n        // Found at least one match\n    }\n}\n</code></pre>"},{"location":"en/target_mem/#memory-pattern-matching","title":"Memory Pattern Matching","text":"<pre><code>void find_string_patterns(const MatchesAndOldValuesArray&amp; matches) {\n    for (const auto&amp; swath : matches.swaths) {\n        for (size_t i = 0; i &lt; swath.data.size(); ++i) {\n            if (swath.data[i].match_info != MatchFlags::EMPTY) {\n                // Check for ASCII string patterns\n                std::string chars = swath.toPrintableString(i, 16);\n                if (is_printable_string(chars)) {\n                    void* addr = static_cast&lt;char*&gt;(swath.firstByteInChild) + i;\n                    std::cout &lt;&lt; \"String at \" &lt;&lt; addr &lt;&lt; \": \" &lt;&lt; chars &lt;&lt; \"\\n\";\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"en/target_mem/#integration-with-other-modules","title":"Integration with Other Modules","text":""},{"location":"en/target_mem/#with-show-message-module","title":"With Show Message Module","text":"<pre><code>import targetmem;\nimport show_message;\n\nvoid report_matches(const MatchesAndOldValuesArray&amp; matches) {\n    MessagePrinter printer;\n\n    size_t total_matches = 0;\n    for (const auto&amp; swath : matches.swaths) {\n        for (const auto&amp; [value, flags] : swath.data) {\n            if (flags != MatchFlags::EMPTY) {\n                total_matches++;\n            }\n        }\n    }\n\n    printer.info(\"Found {} total matches\", total_matches);\n}\n</code></pre>"},{"location":"en/target_mem/#with-process-checker","title":"With Process Checker","text":"<pre><code>void scan_process_memory(pid_t pid) {\n    if (ProcessChecker::is_process_dead(pid)) {\n        return;\n    }\n\n    // Create memory scanner\n    MatchesAndOldValuesArray matches(get_process_memory_size(pid));\n\n    // Perform scan...\n}\n</code></pre>"},{"location":"en/target_mem/#testing","title":"Testing","text":"<pre><code>void test_target_memory() {\n    // Test swath creation\n    MatchesAndOldValuesSwath swath;\n    swath.addElement(nullptr, 0x41, MatchFlags::U8B);\n\n    assert(swath.data.size() == 1);\n    assert(swath.data[0].old_value == 0x41);\n    assert(swath.data[0].match_info == MatchFlags::U8B);\n\n    // Test string representations\n    std::string printable = swath.toPrintableString(0, 1);\n    assert(printable == \"A\");\n\n    std::string hex = swath.toByteArrayText(0, 1);\n    assert(hex == \"41\");\n\n    // Test array operations\n    MatchesAndOldValuesArray array(1024);\n    array.addSwath(swath);\n\n    auto match = array.nthMatch(0);\n    assert(match.has_value());\n\n    std::cout &lt;&lt; \"All tests passed!\\n\";\n}\n</code></pre>"},{"location":"en/target_mem/#see-also","title":"See Also","text":"<ul> <li>Value Module - For MatchFlags definitions</li> <li>Process Checker Module - For process state checking</li> <li>Show Message Module - For logging and reporting</li> </ul>"},{"location":"en/target_mem/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Support for larger memory regions</li> <li>Compression for sparse match data</li> <li>Parallel processing support</li> <li>Memory scanning optimizations</li> <li>Integration with memory mapping APIs</li> <li>Support for different memory types (heap, stack, code)</li> <li>Pattern matching algorithms</li> <li>Memory write operations</li> <li>Snapshot and comparison features</li> </ul>"},{"location":"en/target_mem/#thread-safety","title":"Thread Safety","text":"<p>The classes are not thread-safe by default. For concurrent access:</p> <ol> <li>Use external synchronization</li> <li>Consider immutable copies for read-only access</li> <li>Use separate instances for different threads</li> </ol>"},{"location":"en/target_mem/#memory-management","title":"Memory Management","text":"<ul> <li>Automatic memory management via std::vector</li> <li>RAII principles for exception safety</li> <li>Efficient move semantics for large datasets</li> <li>Minimal heap allocations during operations</li> </ul>"},{"location":"en/value/","title":"Value Module Documentation","text":""},{"location":"en/value/#overview","title":"Overview","text":"<p>The <code>value</code> module provides comprehensive value type definitions and match flags for the NewScanmem project. It defines various data type representations, memory layouts, and utility structures for handling different numeric types, byte arrays, and wildcard patterns used in memory scanning operations.</p>"},{"location":"en/value/#module-structure","title":"Module Structure","text":"<pre><code>export module value;\n</code></pre>"},{"location":"en/value/#dependencies","title":"Dependencies","text":"<ul> <li><code>&lt;cstdint&gt;</code> - Fixed-width integer types</li> <li><code>&lt;cstring&gt;</code> - Byte copy</li> <li><code>&lt;optional&gt;</code> - Optional type support</li> <li><code>&lt;span&gt;</code> - Byte views</li> <li><code>&lt;string&gt;</code> - String operations</li> <li><code>&lt;type_traits&gt;</code> - Type utilities</li> <li><code>&lt;vector&gt;</code> - Dynamic array container</li> </ul>"},{"location":"en/value/#core-features","title":"Core Features","text":""},{"location":"en/value/#1-match-flags-enumeration","title":"1. Match Flags Enumeration","text":"<pre><code>enum class [[gnu::packed]] MatchFlags : uint16_t {\n    EMPTY = 0,\n\n    // Basic numeric types\n    U8B = 1 &lt;&lt; 0,   // Unsigned 8-bit\n    S8B = 1 &lt;&lt; 1,   // Signed 8-bit\n    U16B = 1 &lt;&lt; 2,  // Unsigned 16-bit\n    S16B = 1 &lt;&lt; 3,  // Signed 16-bit\n    U32B = 1 &lt;&lt; 4,  // Unsigned 32-bit\n    S32B = 1 &lt;&lt; 5,  // Signed 32-bit\n    U64B = 1 &lt;&lt; 6,  // Unsigned 64-bit\n    S64B = 1 &lt;&lt; 7,  // Signed 64-bit\n\n    // Floating point types\n    F32B = 1 &lt;&lt; 8,  // 32-bit float\n    F64B = 1 &lt;&lt; 9,  // 64-bit float\n\n    // Composite types\n    I8B = U8B | S8B,      // Any 8-bit integer\n    I16B = U16B | S16B,   // Any 16-bit integer\n    I32B = U32B | S32B,   // Any 32-bit integer\n    I64B = U64B | S64B,   // Any 64-bit integer\n\n    INTEGER = I8B | I16B | I32B | I64B,  // All integer types\n    FLOAT = F32B | F64B,                  // All floating point types\n    ALL = INTEGER | FLOAT,                // All supported types\n\n    // Byte-based groupings\n    B8 = I8B,           // 8-bit block\n    B16 = I16B,         // 16-bit block\n    B32 = I32B | F32B,  // 32-bit block\n    B64 = I64B | F64B,  // 64-bit block\n\n    MAX = 0xffffU  // Maximum flag value\n};\n</code></pre>"},{"location":"en/value/#2-value-structure-byte-centric","title":"2. Value Structure (byte-centric)","text":"<p>Value stores historical (old) values as raw bytes. Type/width semantics are carried by <code>flags</code>.</p> <pre><code>struct [[gnu::packed]] Value {\n    std::vector&lt;uint8_t&gt; bytes;     // Snapshot bytes\n    MatchFlags flags = MatchFlags::EMPTY; // Type/width flag (required for numeric)\n\n    constexpr static void zero(Value&amp; val);\n\n    // Views and setters\n    std::span&lt;const uint8_t&gt; view() const noexcept;\n    void setBytes(const uint8_t* data, std::size_t len);\n    void setBytes(const std::vector&lt;uint8_t&gt;&amp; val);\n    void setBytesWithFlag(const uint8_t* data, std::size_t len, MatchFlags f);\n    void setBytesWithFlag(const std::vector&lt;uint8_t&gt;&amp; val, MatchFlags f);\n\n    template &lt;typename T&gt; void setScalar(const T&amp; v);\n    template &lt;typename T&gt; void setScalarWithFlag(const T&amp; v, MatchFlags f);\n    template &lt;typename T&gt; void setScalarTyped(const T&amp; v); // auto-set correct flag\n};\n</code></pre> <p>Notes: - Numeric comparisons are strict: old value is decoded only if <code>flags</code> matches the requested type and the byte width is sufficient. - Byte array/string comparisons do not rely on <code>flags</code>.</p>"},{"location":"en/value/#3-mem64-structure-current-bytes-buffer","title":"3. Mem64 Structure (current bytes buffer)","text":"<p>Mem64 represents the current bytes read at a memory location.</p> <pre><code>struct [[gnu::packed]] Mem64 {\n    std::vector&lt;uint8_t&gt; buffer;\n\n    template &lt;typename T&gt; T get() const;              // memcpy decode\n    std::span&lt;const uint8_t&gt; bytes() const noexcept;  // read-only view\n    void setBytes(const uint8_t* data, std::size_t len);\n    void setBytes(const std::vector&lt;uint8_t&gt;&amp; data);\n    void setString(const std::string&amp; s);\n    template &lt;typename T&gt; void setScalar(const T&amp; v);\n};\n</code></pre>"},{"location":"en/value/#methods","title":"Methods","text":"<ul> <li><code>get&lt;T&gt;()</code>: Decode the first <code>sizeof(T)</code> bytes using <code>memcpy</code> (throws if insufficient bytes).</li> <li><code>bytes()</code>: Read-only span view over underlying bytes.</li> <li><code>setBytes(...)</code>, <code>setString(...)</code>, <code>setScalar&lt;T&gt;(...)</code>: Write helpers.</li> </ul>"},{"location":"en/value/#4-wildcard-enumeration","title":"4. Wildcard Enumeration","text":"<pre><code>enum class Wildcard : uint8_t {\n    FIXED = 0xffU,    // Fixed value (no wildcard)\n    WILDCARD = 0x00U  // Wildcard value (matches anything)\n};\n</code></pre>"},{"location":"en/value/#5-uservalue-structure","title":"5. UserValue Structure","text":"<p>Comprehensive user input value representation with optional fields.</p> <pre><code>struct [[gnu::packed]] UserValue {\n    // Basic numeric values\n    int8_t int8_value = 0;\n    uint8_t uint8_value = 0;\n    int16_t int16_value = 0;\n    uint16_t uint16_value = 0;\n    int32_t int32_value = 0;\n    uint32_t uint32_value = 0;\n    int64_t int64_value = 0;\n    uint64_t uint64_value = 0;\n    float float32_value = 0.0F;\n    double float64_value = 0.0;\n\n    // Optional complex types\n    std::optional&lt;std::vector&lt;uint8_t&gt;&gt; bytearray_value;\n    std::optional&lt;std::vector&lt;uint8_t&gt;&gt; byteMask; // 0xFF=fixed, 0x00=wildcard\n    std::optional&lt;Wildcard&gt; wildcard_value;\n\n    // String and flags\n    std::string string_value;\n    MatchFlags flags = MatchFlags::EMPTY;\n};\n</code></pre>"},{"location":"en/value/#usage-examples","title":"Usage Examples","text":""},{"location":"en/value/#basic-value-creation-strict-numeric-free-form-bytes","title":"Basic Value Creation (strict numeric + free-form bytes)","text":"<pre><code>import value;\n\n// Create values with different types\nValue uint8_val; uint8_val.setScalarTyped&lt;uint8_t&gt;(255);\nValue int32_val; int32_val.setScalarTyped&lt;int32_t&gt;(-42);\nValue float_val; float_val.setScalarTyped&lt;float&gt;(3.14f);\n</code></pre>"},{"location":"en/value/#working-with-mem64","title":"Working with Mem64","text":"<pre><code>Mem64 mem64;\nmem64.setScalar&lt;int64_t&gt;(INT64_MAX);\nauto int64_value = mem64.get&lt;int64_t&gt;();\n\nmem64.setScalar&lt;double&gt;(M_PI);\nauto double_value = mem64.get&lt;double&gt;();\n</code></pre>"},{"location":"en/value/#user-value-input","title":"User Value Input","text":"<pre><code>UserValue user_val;\n\n// Set numeric values if needed\nuser_val.int32_value = 42;\nuser_val.float64_value = 1.23;\n\n// Set string value\nuser_val.string_value = \"test_string\";\n\n// Set byte array\nuser_val.bytearray_value = std::vector&lt;uint8_t&gt;{0x01, 0x02, 0x03, 0x04};\n\n// Optional wildcard intent (used with masked matching at higher level)\nuser_val.wildcard_value = Wildcard::WILDCARD;\n</code></pre>"},{"location":"en/value/#flag-operations","title":"Flag Operations","text":"<pre><code>// Check if flags include specific type\nbool is_integer = (flags &amp; MatchFlags::INTEGER) != MatchFlags::EMPTY;\nbool is_float = (flags &amp; MatchFlags::FLOAT) != MatchFlags::EMPTY;\n\n// Check specific bit width\nbool is_32bit = (flags &amp; MatchFlags::B32) != MatchFlags::EMPTY;\n\n// Combine flags\nMatchFlags combined = MatchFlags::U8B | MatchFlags::U16B | MatchFlags::U32B;\n</code></pre>"},{"location":"en/value/#byte-array-handling","title":"Byte Array Handling","text":"<pre><code>// Create value with byte array\nValue byte_val;\nstd::vector&lt;uint8_t&gt; bytes{0x01, 0x02, 0x03, 0x04};\nbyte_val.setBytes(bytes);\n\n// Iterate bytes via view\nfor (auto b : byte_val.view()) {\n    std::cout &lt;&lt; std::hex &lt;&lt; static_cast&lt;int&gt;(b) &lt;&lt; \" \";\n}\n</code></pre>"},{"location":"en/value/#memory-layout-and-packing","title":"Memory Layout and Packing","text":""},{"location":"en/value/#structure-packing","title":"Structure Packing","text":"<p>All structures use <code>[[gnu::packed]]</code> attribute to minimize memory usage:</p> <ul> <li>Value: bytes vector + flag</li> <li>Mem64: bytes vector buffer</li> <li>UserValue: ~200+ bytes (including string and vectors)</li> </ul>"},{"location":"en/value/#alignment","title":"Alignment","text":"<p>Structures are packed to minimize memory usage, which may impact performance on some architectures.</p>"},{"location":"en/value/#type-safety-and-error-handling","title":"Type Safety and Error Handling","text":""},{"location":"en/value/#runtime-type-checking","title":"Runtime Type Checking","text":"<pre><code>Mem64 mem64;\nmem64.setScalar&lt;int32_t&gt;(42);\n// Decoding to a mismatched type or with insufficient bytes throws\ndouble val = mem64.get&lt;double&gt;();\n</code></pre>"},{"location":"en/value/#compile-time-type-checking","title":"Compile-time Type Checking","text":"<pre><code>// Static assertions ensure type safety\nstatic_assert(std::is_trivially_copyable_v&lt;int64_t&gt;);\nstatic_assert(sizeof(std::array&lt;uint8_t, 8&gt;) == 8);\n</code></pre>"},{"location":"en/value/#integration-examples","title":"Integration Examples","text":""},{"location":"en/value/#with-target-memory-module","title":"With Target Memory Module","text":"<pre><code>import value;\nimport targetmem;\n\nvoid create_match_entry(void* addr, uint8_t byte, const Value&amp; value) {\n    OldValueAndMatchInfo info;\n    info.old_value = byte;\n    // Determine flags from context (example: 8-bit unsigned)\n    info.match_info = MatchFlags::U8B;\n}\n</code></pre>"},{"location":"en/value/#with-endianness-module","title":"With Endianness Module","text":"<pre><code>import value;\nimport endianness;\n\nvoid handle_endianness(Value&amp; val, bool reverse_endianness) {\n    if (reverse_endianness) {\n        endianness::fix_endianness(val, true);\n    }\n}\n</code></pre>"},{"location":"en/value/#testing","title":"Testing","text":"<pre><code>void test_value_module() {\n    // Test Value creation\n    Value val; val.setScalarTyped&lt;uint32_t&gt;(42);\n\n    // Test Mem64\n    Mem64 mem64;\n    mem64.setScalar&lt;float&gt;(3.14f);\n    assert(mem64.get&lt;float&gt;() == 3.14f);\n\n    // Test flags\n    MatchFlags flags = MatchFlags::U8B | MatchFlags::U16B;\n    assert((flags &amp; MatchFlags::U8B) != MatchFlags::EMPTY);\n\n    // Test UserValue\n    UserValue user_val;\n    user_val.int32_value = 123;\n    assert(user_val.int32_value == 123);\n\n    std::cout &lt;&lt; \"All tests passed!\\n\";\n}\n</code></pre>"},{"location":"en/value/#performance-considerations","title":"Performance Considerations","text":""},{"location":"en/value/#memory-usage","title":"Memory Usage","text":"<ul> <li>Value: Byte vector storage + strict flags</li> <li>Mem64: Byte buffer with memcpy decode</li> <li>UserValue: Larger due to optional containers and string</li> </ul>"},{"location":"en/value/#runtime-performance","title":"Runtime Performance","text":"<ul> <li>Variant access: O(1) via std::visit or std::get</li> <li>Type checking: Compile-time with std::get_if</li> <li>Memory alignment: Packed structures may have alignment overhead</li> </ul>"},{"location":"en/value/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate types: Choose specific numeric types over generic ones</li> <li>Initialize flags: Always set appropriate MatchFlags</li> <li>Handle type mismatches: Guard reads and check sizes for <code>get&lt;T&gt;()</code></li> <li>Consider alignment: Packed structures may impact performance</li> </ol>"},{"location":"en/value/#see-also","title":"See Also","text":"<ul> <li>Target Memory Module - Uses Value and MatchFlags</li> <li>Endianness Module - Handles byte order for values</li> <li>Show Message Module - For value reporting and debugging</li> </ul>"},{"location":"en/value/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Support for 128-bit types</li> <li>SIMD type support</li> <li>Custom allocator support</li> <li>Serialization/deserialization</li> <li>JSON conversion utilities</li> <li>Memory-mapped file support</li> <li>Zero-copy operations</li> <li>Type reflection capabilities</li> <li>Performance profiling utilities</li> <li>Cross-platform endianness detection helpers</li> </ul>"},{"location":"en/value/#platform-compatibility","title":"Platform Compatibility","text":"<ul> <li>Linux: Full support</li> <li>macOS: Full support</li> <li>Windows: Full support</li> <li>32-bit systems: Limited 64-bit type support</li> <li>Big-endian: Full support with appropriate endianness handling</li> </ul>"},{"location":"en/value/#migration-guide","title":"Migration Guide","text":""},{"location":"en/value/#from-c-style-unions","title":"From C-style unions","text":"<pre><code>// Old C-style union\nunion ValueUnion {\n    uint8_t u8;\n    uint16_t u16;\n    uint32_t u32;\n    float f32;\n};\n\n// New C++23 variant\nValue val = uint32_t{42};  // Type-safe and extensible\n</code></pre>"},{"location":"en/value/#from-raw-pointers","title":"From raw pointers","text":"<p>```cpp // Old raw pointer approach void ptr = malloc(sizeof(int32_t)); (int32_t*)ptr = 42;</p> <p>// New type-safe approach Mem64 mem64; mem64.set(42);  // Safe and automatic cleanup"}]}