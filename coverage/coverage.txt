/workspaces/NewScanmem/src/scan/bytes.cppm:
    1|       |module;
    2|       |
    3|       |#include <algorithm>
    4|       |#include <cstddef>
    5|       |#include <cstdint>
    6|       |#include <iterator>
    7|       |#include <optional>
    8|       |#include <ranges>
    9|       |#include <vector>
   10|       |
   11|       |export module scan.bytes;
   12|       |
   13|       |import scan.types;
   14|       |import value.flags;
   15|       |
   16|       |import value;
   17|       |
   18|       |// Byte compare & search helpers used by the scanning engine.
   19|       |// Public utilities:
   20|       |// - compareBytes / compareBytesMasked: check whether the buffer prefix at the
   21|       |//   current offset matches the supplied pattern (NOT a search).
   22|       |// - findBytePattern / findBytePatternMasked: search for the first occurrence.
   23|       |// - makeBytearrayRoutine: build a scan routine for byte array matches.
   24|       |
   25|       |export inline auto compareBytes(const Mem64* memoryPtr, size_t memLength,
   26|       |                                const std::uint8_t* patternData,
   27|       |                                size_t patternSize, MatchFlags* saveFlags)
   28|      6|    -> unsigned int {
   29|      6|    if (patternData == nullptr || patternSize == 0) {
                                                ^5
   30|      1|        return 0;
   31|      1|    }
   32|      5|    auto hayAll = memoryPtr->bytes();
   33|      5|    size_t limitSize = std::min(hayAll.size(), memLength);
   34|      5|    if (limitSize < patternSize) {
   35|      1|        return 0;
   36|      1|    }
   37|      4|    if (std::equal(patternData, patternData + patternSize, hayAll.begin())) {
   38|      4|        setFlagsIfNotNull(saveFlags, MatchFlags::B8);
   39|      4|        return static_cast<unsigned int>(patternSize);
   40|      4|    }
   41|      0|    return 0;
   42|      4|}
   43|       |
   44|       |// Convenience overload for vector
   45|       |export inline auto compareBytes(const Mem64* memoryPtr, size_t memLength,
   46|       |                                const std::vector<std::uint8_t>& pattern,
   47|      1|                                MatchFlags* saveFlags) -> unsigned int {
   48|      1|    return compareBytes(memoryPtr, memLength, pattern.data(), pattern.size(),
   49|      1|                        saveFlags);
   50|      1|}
   51|       |
   52|       |export inline auto compareBytesMasked(const Mem64* memoryPtr, size_t memLength,
   53|       |                                      const std::uint8_t* patternData,
   54|       |                                      size_t patternSize,
   55|       |                                      const std::uint8_t* maskData,
   56|       |                                      size_t maskSize, MatchFlags* saveFlags)
   57|      6|    -> unsigned int {
   58|      6|    if (patternData == nullptr || maskData == nullptr || patternSize == 0 ||
   59|      6|        maskSize != patternSize) {
   60|      1|        return 0;
   61|      1|    }
   62|      5|    auto hayAll = memoryPtr->bytes();
   63|      5|    size_t limitSize = std::min(hayAll.size(), memLength);
   64|      5|    if (limitSize < patternSize) {
   65|      0|        return 0;
   66|      0|    }
   67|      5|    const size_t PATTERN_SIZE = patternSize;
   68|     15|    for (size_t j = 0; j < PATTERN_SIZE; ++j) {
                                                       ^10
   69|     10|        if (((hayAll[j] ^ patternData[j]) & maskData[j]) != 0) {
   70|      0|            return 0;
   71|      0|        }
   72|     10|    }
   73|      5|    setFlagsIfNotNull(saveFlags, (MatchFlags::B8 | MatchFlags::BYTE_ARRAY));
   74|      5|    return static_cast<unsigned int>(PATTERN_SIZE);
   75|      5|}
   76|       |
   77|       |// Convenience overload for vectors
   78|       |export inline auto compareBytesMasked(const Mem64* memoryPtr, size_t memLength,
   79|       |                                      const std::vector<std::uint8_t>& pattern,
   80|       |                                      const std::vector<std::uint8_t>& mask,
   81|      0|                                      MatchFlags* saveFlags) -> unsigned int {
   82|      0|    return compareBytesMasked(memoryPtr, memLength, pattern.data(),
   83|      0|                              pattern.size(), mask.data(), mask.size(),
   84|      0|                              saveFlags);
   85|      0|}
   86|       |
   87|       |export inline auto findBytePattern(const Mem64* memoryPtr, size_t memLength,
   88|       |                                   const std::uint8_t* patternData,
   89|       |                                   size_t patternSize)
   90|      1|    -> std::optional<ByteMatch> {
   91|      1|    if (patternData == nullptr || patternSize == 0) {
   92|      0|        return std::nullopt;
   93|      0|    }
   94|      1|    auto hayAll = memoryPtr->bytes();
   95|      1|    const size_t LIMIT = std::min(hayAll.size(), memLength);
   96|      1|    if (LIMIT < patternSize) {
   97|      0|        return std::nullopt;
   98|      0|    }
   99|      1|    auto hayView = hayAll | std::views::take(LIMIT);
  100|      1|    auto patternView = std::views::counted(
  101|      1|        patternData, static_cast<std::ptrdiff_t>(patternSize));
  102|      1|    auto searchResult = std::ranges::search(hayView, patternView);
  103|      1|    if (searchResult.empty()) {
  104|      0|        return std::nullopt;
  105|      0|    }
  106|      1|    auto off = static_cast<size_t>(
  107|      1|        std::ranges::distance(hayView.begin(), searchResult.begin()));
  108|      1|    return ByteMatch{.offset = off, .length = patternSize};
  109|      1|}
  110|       |
  111|       |// Convenience overload for vector
  112|       |export inline auto findBytePattern(const Mem64* memoryPtr, size_t memLength,
  113|       |                                   const std::vector<std::uint8_t>& pattern)
  114|      1|    -> std::optional<ByteMatch> {
  115|      1|    return findBytePattern(memoryPtr, memLength, pattern.data(),
  116|      1|                           pattern.size());
  117|      1|}
  118|       |
  119|       |export inline auto findBytePatternMasked(
  120|       |    const Mem64* memoryPtr, size_t memLength, const std::uint8_t* patternData,
  121|       |    size_t patternSize, const std::uint8_t* maskData, size_t maskSize)
  122|      1|    -> std::optional<ByteMatch> {
  123|      1|    if (patternData == nullptr || maskData == nullptr || patternSize == 0 ||
  124|      1|        maskSize != patternSize) {
  125|      0|        return std::nullopt;
  126|      0|    }
  127|      1|    auto hayAll = memoryPtr->bytes();
  128|      1|    const size_t LIMIT = std::min(hayAll.size(), memLength);
  129|      1|    if (LIMIT < patternSize) {
  130|      0|        return std::nullopt;
  131|      0|    }
  132|      1|    for (size_t hayIndex = 0; hayIndex + patternSize <= LIMIT; ++hayIndex) {
                                                                             ^0
  133|      1|        bool matched = true;
  134|      3|        for (size_t patternIndex = 0; patternIndex < patternSize;
  135|      2|             ++patternIndex) {
  136|      2|            if (((hayAll[hayIndex + patternIndex] ^ patternData[patternIndex]) &
  137|      2|                 maskData[patternIndex]) != 0) {
  138|      0|                matched = false;
  139|      0|                break;
  140|      0|            }
  141|      2|        }
  142|      1|        if (matched) {
  143|      1|            return ByteMatch{.offset = hayIndex, .length = patternSize};
  144|      1|        }
  145|      1|    }
  146|      0|    return std::nullopt;
  147|      1|}
  148|       |
  149|       |// Convenience overload for vectors
  150|       |export inline auto findBytePatternMasked(
  151|       |    const Mem64* memoryPtr, size_t memLength,
  152|       |    const std::vector<std::uint8_t>& pattern,
  153|      1|    const std::vector<std::uint8_t>& mask) -> std::optional<ByteMatch> {
  154|      1|    return findBytePatternMasked(memoryPtr, memLength, pattern.data(),
  155|      1|                                 pattern.size(), mask.data(), mask.size());
  156|      1|}
  157|       |
  158|       |export inline auto makeBytearrayRoutine(ScanMatchType matchType)
  159|      2|    -> scanRoutine {
  160|      2|    return [matchType](const Mem64* memoryPtr, size_t memLength,
  161|      2|                       const Value* /*oldValue*/, const UserValue* userValue,
  162|      2|                       MatchFlags* saveFlags) -> unsigned int {
  163|      2|        setFlagsIfNotNull(saveFlags, MatchFlags::EMPTY);
  164|      2|        if (matchType == ScanMatchType::MATCH_ANY) {
  165|      0|            setFlagsIfNotNull(saveFlags, MatchFlags::B8);
  166|      0|            return static_cast<unsigned int>(memLength);
  167|      0|        }
  168|      2|        if (!userValue || !userValue->bytearrayValue) {
  169|      0|            return 0;
  170|      0|        }
  171|      2|        const auto& byteArrayRef = *userValue->bytearrayValue;
  172|      2|        if (userValue->byteMask &&
  173|      2|            userValue->byteMask->size() == byteArrayRef.size()) {
  174|      2|            unsigned matchedLen = compareBytesMasked(
  175|      2|                memoryPtr, memLength, byteArrayRef.data(), byteArrayRef.size(),
  176|      2|                userValue->byteMask->data(), userValue->byteMask->size(),
  177|      2|                saveFlags);
  178|      2|            if (matchedLen > 0) {
  179|      2|                orFlagsIfNotNull(saveFlags, MatchFlags::BYTE_ARRAY);
  180|      2|            }
  181|      2|            return matchedLen;
  182|      2|        }
  183|      0|        unsigned matchedLen =
  184|      0|            compareBytes(memoryPtr, memLength, byteArrayRef.data(),
  185|      0|                         byteArrayRef.size(), saveFlags);
  186|      0|        if (matchedLen > 0) {
  187|      0|            orFlagsIfNotNull(saveFlags, MatchFlags::BYTE_ARRAY);
  188|      0|        }
  189|      0|        return matchedLen;
  190|      2|    };
  191|      2|}

/workspaces/NewScanmem/src/scan/string.cppm:
    1|       |module;
    2|       |#include <algorithm>
    3|       |#include <bit>
    4|       |#include <boost/regex.hpp>
    5|       |#include <cstdint>
    6|       |#include <memory>
    7|       |#include <optional>
    8|       |#include <string>
    9|       |#include <string_view>
   10|       |#include <vector>
   11|       |
   12|       |export module scan.string;
   13|       |
   14|       |import scan.types;
   15|       |import value.flags;
   16|       |import scan.bytes;
   17|       |import value;
   18|       |
   19|       |// This module implements string and regex-related routines and a
   20|       |// thread-local regex cache.
   21|       |// Exports: makeStringRoutine, getCachedRegex, findRegexPattern
   22|       |
   23|       |export inline auto getCachedRegex(const std::string& pattern) noexcept
   24|      4|    -> const boost::regex* {
   25|      4|    thread_local std::string cachedPattern;
   26|      4|    thread_local std::unique_ptr<boost::regex> cachedRegex;
   27|      4|    if (!cachedRegex || cachedPattern != pattern) {
                                      ^0
   28|      4|        try {
   29|      4|            cachedRegex =
   30|      4|                std::make_unique<boost::regex>(pattern, boost::regex::perl);
   31|      4|            cachedPattern = pattern;
   32|      4|        } catch (const boost::regex_error&) {
   33|      1|            return nullptr;
   34|      1|        }
   35|      4|    }
   36|      3|    return cachedRegex.get();
   37|      4|}
   38|       |
   39|       |export inline auto findRegexPattern(const Mem64* memoryPtr, size_t memLength,
   40|       |                                    const std::string& pattern)
   41|       |    -> std::optional<ByteMatch> {
   42|       |    auto hayAll = memoryPtr->bytes();
   43|       |    size_t limitSize = std::min(hayAll.size(), memLength);
   44|       |    std::string hay(hayAll.begin(),
   45|       |                    hayAll.begin() + static_cast<std::ptrdiff_t>(limitSize));
   46|       |    if (const auto* rxVal = getCachedRegex(pattern)) {
   47|       |        boost::smatch matchResult;
   48|       |        if (boost::regex_search(hay, matchResult, *rxVal)) {
   49|       |            return ByteMatch{
   50|       |                .offset = static_cast<size_t>(matchResult.position()),
   51|       |                .length = static_cast<size_t>(matchResult.length())};
   52|       |        }
   53|       |    } else {
   54|       |        return std::nullopt;
   55|       |    }
   56|       |    return std::nullopt;
   57|       |}
   58|       |
   59|       |namespace {
   60|       |
   61|       |[[nodiscard]] inline auto handleMATCHANY(size_t memLength,
   62|       |                                         MatchFlags* saveFlags)
   63|      1|    -> unsigned int {
   64|      1|    setFlagsIfNotNull(saveFlags, MatchFlags::B8);
   65|      1|    return static_cast<unsigned int>(memLength);
   66|      1|}
   67|       |
   68|       |[[nodiscard]] inline auto runRegexMatch(const Mem64* memoryPtr,
   69|       |                                        size_t memLength,
   70|       |                                        const std::string& pattern,
   71|      1|                                        MatchFlags* saveFlags) -> unsigned int {
   72|      1|    auto hayAll = memoryPtr->bytes();
   73|      1|    size_t limitSize = std::min(hayAll.size(), memLength);
   74|      1|    std::string hay(hayAll.begin(),
   75|      1|                    hayAll.begin() + static_cast<std::ptrdiff_t>(limitSize));
   76|      1|    if (const auto* rxVal = getCachedRegex(pattern)) {
   77|      1|        boost::smatch matchResult;
   78|      1|        if (boost::regex_search(hay, matchResult, *rxVal)) {
   79|      1|            setFlagsIfNotNull(saveFlags, MatchFlags::B8);
   80|      1|            return static_cast<unsigned int>(matchResult.length());
   81|      1|        }
   82|      1|    }
   83|      0|    return 0;
   84|      1|}
   85|       |
   86|       |}  // namespace
   87|       |
   88|      6|export inline auto makeStringRoutine(ScanMatchType matchType) -> scanRoutine {
   89|      6|    return [matchType](const Mem64* memoryPtr, size_t memLength,
   90|      6|                       const Value* /*oldValue*/, const UserValue* userValue,
   91|      6|                       MatchFlags* saveFlags) -> unsigned int {
   92|      6|        setFlagsIfNotNull(saveFlags, MatchFlags::EMPTY);
   93|      6|        if (matchType == ScanMatchType::MATCH_ANY) {
   94|      3|            return handleMATCHANY(memLength, saveFlags);
   95|      3|        }
   96|      3|        if (!userValue) {
   97|      0|            return 0;
   98|      0|        }
   99|      3|        if (matchType == ScanMatchType::MATCH_REGEX) {
  100|      2|            return runRegexMatch(memoryPtr, memLength, userValue->stringValue,
  101|      2|                                 saveFlags);
  102|      2|        }
  103|      1|        const std::string_view PATTERN{userValue->stringValue};
  104|      1|        if (PATTERN.empty()) {
  105|      0|            return 0;
  106|      0|        }
  107|      1|        const auto* const MASK_PTR =
  108|      1|            (userValue->byteMask &&
  109|      1|             userValue->byteMask->size() == PATTERN.size())
                           ^0
  110|      1|                ? &*userValue->byteMask
                                ^0
  111|      1|                : nullptr;
  112|      1|        const auto* bytePtr = std::bit_cast<const uint8_t*>(PATTERN.data());
  113|      1|        if (MASK_PTR) {
  114|      0|            return compareBytesMasked(memoryPtr, memLength, bytePtr,
  115|      0|                                      PATTERN.size(), MASK_PTR->data(),
  116|      0|                                      MASK_PTR->size(), saveFlags);
  117|      0|        }
  118|      1|        return compareBytes(memoryPtr, memLength, bytePtr, PATTERN.size(),
  119|      1|                            saveFlags);
  120|      1|    };
  121|      6|}

/workspaces/NewScanmem/src/utils/mem64.cppm:
    1|       |module;
    2|       |
    3|       |#include <bit>
    4|       |#include <cstddef>
    5|       |#include <cstdint>
    6|       |#include <cstring>
    7|       |#include <optional>
    8|       |#include <span>
    9|       |#include <stdexcept>
   10|       |#include <string>
   11|       |#include <type_traits>
   12|       |#include <vector>
   13|       |
   14|       |export module utils.mem64;
   15|       |
   16|       |export struct Mem64 {
   17|       |   private:
   18|       |    std::vector<std::uint8_t> m_buf;
   19|       |
   20|       |   public:
   21|       |    Mem64() = default;
   22|      0|    explicit Mem64(std::size_t n) : m_buf(n) {}
   23|  1.26M|    Mem64(const std::uint8_t* point, std::size_t n) : m_buf(point, point + n) {}
   24|     11|    explicit Mem64(std::span<const std::uint8_t> span) { setBytes(span); }
   25|      3|    explicit Mem64(const std::string& stringInput) { setString(stringInput); }
   26|       |
   27|       |    // Basic info / views
   28|     29|    [[nodiscard]] auto size() const noexcept -> std::size_t {
   29|     29|        return m_buf.size();
   30|     29|    }
   31|      0|    [[nodiscard]] auto empty() const noexcept -> bool { return m_buf.empty(); }
   32|     25|    [[nodiscard]] auto data() const noexcept -> const std::uint8_t* {
   33|     25|        return m_buf.data();
   34|     25|    }
   35|      0|    [[nodiscard]] auto data() noexcept -> std::uint8_t* { return m_buf.data(); }
   36|       |
   37|       |    // Read-only span view
   38|     25|    [[nodiscard]] auto bytes() const noexcept -> std::span<const std::uint8_t> {
   39|     25|        return {data(), size()};
   40|     25|    }
   41|       |
   42|       |    // Assignment / write APIs
   43|      0|    void clear() { m_buf.clear(); }
   44|      0|    void reserve(std::size_t n) { m_buf.reserve(n); }
   45|       |
   46|     14|    void setBytes(const std::uint8_t* point, std::size_t n) {
   47|     14|        m_buf.assign(point, point + n);
   48|     14|    }
   49|     11|    void setBytes(std::span<const std::uint8_t> span) {
   50|     11|        setBytes(span.data(), span.size());
   51|     11|    }
   52|      0|    void setBytes(const std::vector<std::uint8_t>& val) { m_buf = val; }
   53|      3|    void setString(const std::string& stringInput) {
   54|      3|        const auto* point =
   55|      3|            std::bit_cast<const std::uint8_t*>(stringInput.data());
   56|      3|        setBytes(point, stringInput.size());
   57|      3|    }
   58|       |
   59|       |    template <typename T>
   60|       |    void setScalar(const T& val) {
   61|       |        static_assert(std::is_trivially_copyable_v<T>,
   62|       |                      "setScalar requires trivially copyable T");
   63|       |        m_buf.resize(sizeof(T));
   64|       |        std::memcpy(m_buf.data(), &val, sizeof(T));
   65|       |    }
   66|       |
   67|       |    // Read APIs: interpret from start as host-endian scalar
   68|       |    template <typename T>
   69|       |    [[nodiscard]] auto tryGet() const noexcept -> std::optional<T> {
   70|       |        if (m_buf.size() < sizeof(T)) {
   71|       |            return std::nullopt;
   72|       |        }
   73|       |        T out{};
   74|       |        std::memcpy(&out, m_buf.data(), sizeof(T));
   75|       |        return out;
   76|       |    }
   77|       |
   78|       |    // Read API: non-optional variant (legacy migration), throws on failure
   79|       |    template <typename T>
   80|       |    [[nodiscard]] auto get() const -> T {
   81|       |        auto opt = tryGet<T>();
   82|       |        if (!opt) {
   83|       |            throw std::runtime_error("Mem64::get<T>() insufficient bytes");
   84|       |        }
   85|       |        return *opt;
   86|       |    }
   87|       |};

/workspaces/NewScanmem/src/value/flags.cppm:
    1|       |module;
    2|       |
    3|       |#include <cstdint>
    4|       |
    5|       |export module value.flags;
    6|       |
    7|       |// base Flags for matching types
    8|       |export enum class MatchFlags : std::uint16_t {
    9|       |    EMPTY = 0,
   10|       |    // Width-based flags (used for marking match width/type in scan paths)
   11|       |    B8 = 1U << 0,
   12|       |    B16 = 1U << 1,
   13|       |    B32 = 1U << 2,
   14|       |    B64 = 1U << 3,
   15|       |    STRING = 1U << 8,
   16|       |    BYTE_ARRAY = 1U << 9,
   17|       |};
   18|       |
   19|       |// bit wise operators for MatchFlags
   20|       |export constexpr auto operator|(MatchFlags aVal, MatchFlags bVal) noexcept
   21|  1.50M|    -> MatchFlags {
   22|  1.50M|    return static_cast<MatchFlags>(static_cast<std::uint16_t>(aVal) |
   23|  1.50M|                                   static_cast<std::uint16_t>(bVal));
   24|  1.50M|}
   25|       |
   26|       |export constexpr auto operator&(MatchFlags aVal, MatchFlags bVal) noexcept
   27|   460k|    -> MatchFlags {
   28|   460k|    return static_cast<MatchFlags>(static_cast<std::uint16_t>(aVal) &
   29|   460k|                                   static_cast<std::uint16_t>(bVal));
   30|   460k|}
   31|       |
   32|       |export constexpr auto operator^(MatchFlags aVal, MatchFlags bVal) noexcept
   33|       |    -> MatchFlags {
   34|       |    return static_cast<MatchFlags>(static_cast<std::uint16_t>(aVal) ^
   35|       |                                   static_cast<std::uint16_t>(bVal));
   36|       |}
   37|       |
   38|      0|export constexpr auto operator~(MatchFlags aVal) noexcept -> MatchFlags {
   39|      0|    return static_cast<MatchFlags>(~static_cast<std::uint16_t>(aVal));
   40|      0|}
   41|       |
   42|       |export inline auto operator|=(MatchFlags& aVal, MatchFlags bVal) noexcept
   43|      2|    -> MatchFlags& {
   44|      2|    aVal = (aVal | bVal);
   45|      2|    return aVal;
   46|      2|}
   47|       |
   48|       |export inline auto operator&=(MatchFlags& aVal, MatchFlags bVal) noexcept
   49|       |    -> MatchFlags& {
   50|       |    aVal = (aVal & bVal);
   51|       |    return aVal;
   52|       |}
   53|       |
   54|       |// check if any flag is set
   55|       |export constexpr auto any(MatchFlags flag) noexcept -> bool {
   56|       |    return (flag != MatchFlags::EMPTY);
   57|       |}
   58|       |
   59|       |// Null-safe flag manipulation helpers
   60|       |// These functions safely handle nullptr for optional flag output parameters
   61|       |export inline void setFlagsIfNotNull(MatchFlags* dest,
   62|  2.14M|                                     MatchFlags flags) noexcept {
   63|  2.14M|    if (dest != nullptr) {
   64|  2.13M|        *dest = flags;
   65|  2.13M|    }
   66|  2.14M|}
   67|       |
   68|       |export inline void orFlagsIfNotNull(MatchFlags* dest,
   69|      2|                                    MatchFlags flags) noexcept {
   70|      2|    if (dest != nullptr) {
   71|      2|        *dest |= flags;
   72|      2|    }
   73|      2|}

